{
  "version": 3,
  "file": "pageJonsQuest.js",
  "sources": [
    "js/plugins/jquery.colorbox-min.js",
    "games/jonsQuest/js/physics/SAT.js",
    "games/jonsQuest/js/utils.js",
    "games/jonsQuest/js/audio/audio.js",
    "games/jonsQuest/js/graphics/graphics.js",
    "games/jonsQuest/js/physics/physics.js",
    "games/jonsQuest/js/engine/gameObject.js",
    "games/jonsQuest/js/engine/gameItem.js",
    "games/jonsQuest/js/engine/hud.js",
    "games/jonsQuest/js/enemy/enemy.js",
    "games/jonsQuest/js/level/level.js",
    "games/jonsQuest/js/level/lvlComplete.js",
    "games/jonsQuest/js/level/startScreen.js",
    "games/jonsQuest/js/level/level1.js",
    "games/jonsQuest/js/level/level2.js",
    "games/jonsQuest/js/engine/game.js",
    "games/jonsQuest/js/hero/hero.js",
    "games/jonsQuest/js/hero/heroGraphics.js",
    "games/jonsQuest/js/hero/heroPhysics.js",
    "games/jonsQuest/js/hero/heroInput.js",
    "games/jonsQuest/js/main.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA,ipV;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,Q;ACnwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACzRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC/SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACzOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACpMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACvIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A",
  "sourcesContent": [
    "/*!\n\tColorbox v1.4.33 - 2013-10-31\n\tjQuery lightbox and modal window plugin\n\t(c) 2013 Jack Moore - http://www.jacklmoore.com/colorbox\n\tlicense: http://www.opensource.org/licenses/mit-license.php\n*/\n(function(e,t,i){function o(i,o,n){var r=t.createElement(i);return o&&(r.id=Z+o),n&&(r.style.cssText=n),e(r)}function n(){return i.innerHeight?i.innerHeight:e(i).height()}function r(e){var t=k.length,i=(z+e)%t;return 0>i?t+i:i}function h(e,t){return Math.round((/%/.test(e)?(\"x\"===t?E.width():n())/100:1)*parseInt(e,10))}function l(e,t){return e.photo||e.photoRegex.test(t)}function s(e,t){return e.retinaUrl&&i.devicePixelRatio>1?t.replace(e.photoRegex,e.retinaSuffix):t}function a(e){\"contains\"in g[0]&&!g[0].contains(e.target)&&(e.stopPropagation(),g.focus())}function d(){var t,i=e.data(N,Y);null==i?(B=e.extend({},X),console&&console.log&&console.log(\"Error: cboxElement missing settings object\")):B=e.extend({},i);for(t in B)e.isFunction(B[t])&&\"on\"!==t.slice(0,2)&&(B[t]=B[t].call(N));B.rel=B.rel||N.rel||e(N).data(\"rel\")||\"nofollow\",B.href=B.href||e(N).attr(\"href\"),B.title=B.title||N.title,\"string\"==typeof B.href&&(B.href=e.trim(B.href))}function c(i,o){e(t).trigger(i),lt.triggerHandler(i),e.isFunction(o)&&o.call(N)}function u(i){q||(N=i,d(),k=e(N),z=0,\"nofollow\"!==B.rel&&(k=e(\".\"+et).filter(function(){var t,i=e.data(this,Y);return i&&(t=e(this).data(\"rel\")||i.rel||this.rel),t===B.rel}),z=k.index(N),-1===z&&(k=k.add(N),z=k.length-1)),w.css({opacity:parseFloat(B.opacity),cursor:B.overlayClose?\"pointer\":\"auto\",visibility:\"visible\"}).show(),J&&g.add(w).removeClass(J),B.className&&g.add(w).addClass(B.className),J=B.className,B.closeButton?K.html(B.close).appendTo(y):K.appendTo(\"<div/>\"),U||(U=$=!0,g.css({visibility:\"hidden\",display:\"block\"}),H=o(st,\"LoadedContent\",\"width:0; height:0; overflow:hidden\"),y.css({width:\"\",height:\"\"}).append(H),O=x.height()+C.height()+y.outerHeight(!0)-y.height(),_=b.width()+T.width()+y.outerWidth(!0)-y.width(),D=H.outerHeight(!0),A=H.outerWidth(!0),B.w=h(B.initialWidth,\"x\"),B.h=h(B.initialHeight,\"y\"),H.css({width:\"\",height:B.h}),Q.position(),c(tt,B.onOpen),P.add(L).hide(),g.focus(),B.trapFocus&&t.addEventListener&&(t.addEventListener(\"focus\",a,!0),lt.one(rt,function(){t.removeEventListener(\"focus\",a,!0)})),B.returnFocus&&lt.one(rt,function(){e(N).focus()})),m())}function f(){!g&&t.body&&(V=!1,E=e(i),g=o(st).attr({id:Y,\"class\":e.support.opacity===!1?Z+\"IE\":\"\",role:\"dialog\",tabindex:\"-1\"}).hide(),w=o(st,\"Overlay\").hide(),F=e([o(st,\"LoadingOverlay\")[0],o(st,\"LoadingGraphic\")[0]]),v=o(st,\"Wrapper\"),y=o(st,\"Content\").append(L=o(st,\"Title\"),S=o(st,\"Current\"),I=e('<button type=\"button\"/>').attr({id:Z+\"Previous\"}),R=e('<button type=\"button\"/>').attr({id:Z+\"Next\"}),M=o(\"button\",\"Slideshow\"),F),K=e('<button type=\"button\"/>').attr({id:Z+\"Close\"}),v.append(o(st).append(o(st,\"TopLeft\"),x=o(st,\"TopCenter\"),o(st,\"TopRight\")),o(st,!1,\"clear:left\").append(b=o(st,\"MiddleLeft\"),y,T=o(st,\"MiddleRight\")),o(st,!1,\"clear:left\").append(o(st,\"BottomLeft\"),C=o(st,\"BottomCenter\"),o(st,\"BottomRight\"))).find(\"div div\").css({\"float\":\"left\"}),W=o(st,!1,\"position:absolute; width:9999px; visibility:hidden; display:none; max-width:none;\"),P=R.add(I).add(S).add(M),e(t.body).append(w,g.append(v,W)))}function p(){function i(e){e.which>1||e.shiftKey||e.altKey||e.metaKey||e.ctrlKey||(e.preventDefault(),u(this))}return g?(V||(V=!0,R.click(function(){Q.next()}),I.click(function(){Q.prev()}),K.click(function(){Q.close()}),w.click(function(){B.overlayClose&&Q.close()}),e(t).bind(\"keydown.\"+Z,function(e){var t=e.keyCode;U&&B.escKey&&27===t&&(e.preventDefault(),Q.close()),U&&B.arrowKey&&k[1]&&!e.altKey&&(37===t?(e.preventDefault(),I.click()):39===t&&(e.preventDefault(),R.click()))}),e.isFunction(e.fn.on)?e(t).on(\"click.\"+Z,\".\"+et,i):e(\".\"+et).live(\"click.\"+Z,i)),!0):!1}function m(){var n,r,a,u=Q.prep,f=++at;$=!0,j=!1,N=k[z],d(),c(ht),c(it,B.onLoad),B.h=B.height?h(B.height,\"y\")-D-O:B.innerHeight&&h(B.innerHeight,\"y\"),B.w=B.width?h(B.width,\"x\")-A-_:B.innerWidth&&h(B.innerWidth,\"x\"),B.mw=B.w,B.mh=B.h,B.maxWidth&&(B.mw=h(B.maxWidth,\"x\")-A-_,B.mw=B.w&&B.w<B.mw?B.w:B.mw),B.maxHeight&&(B.mh=h(B.maxHeight,\"y\")-D-O,B.mh=B.h&&B.h<B.mh?B.h:B.mh),n=B.href,G=setTimeout(function(){F.show()},100),B.inline?(a=o(st).hide().insertBefore(e(n)[0]),lt.one(ht,function(){a.replaceWith(H.children())}),u(e(n))):B.iframe?u(\" \"):B.html?u(B.html):l(B,n)?(n=s(B,n),j=t.createElement(\"img\"),e(j).addClass(Z+\"Photo\").bind(\"error\",function(){B.title=!1,u(o(st,\"Error\").html(B.imgError))}).one(\"load\",function(){var t;f===at&&(e.each([\"alt\",\"longdesc\",\"aria-describedby\"],function(t,i){var o=e(N).attr(i)||e(N).attr(\"data-\"+i);o&&j.setAttribute(i,o)}),B.retinaImage&&i.devicePixelRatio>1&&(j.height=j.height/i.devicePixelRatio,j.width=j.width/i.devicePixelRatio),B.scalePhotos&&(r=function(){j.height-=j.height*t,j.width-=j.width*t},B.mw&&j.width>B.mw&&(t=(j.width-B.mw)/j.width,r()),B.mh&&j.height>B.mh&&(t=(j.height-B.mh)/j.height,r())),B.h&&(j.style.marginTop=Math.max(B.mh-j.height,0)/2+\"px\"),k[1]&&(B.loop||k[z+1])&&(j.style.cursor=\"pointer\",j.onclick=function(){Q.next()}),j.style.width=j.width+\"px\",j.style.height=j.height+\"px\",setTimeout(function(){u(j)},1))}),setTimeout(function(){j.src=n},1)):n&&W.load(n,B.data,function(t,i){f===at&&u(\"error\"===i?o(st,\"Error\").html(B.xhrError):e(this).contents())})}var w,g,v,y,x,b,T,C,k,E,H,W,F,L,S,M,R,I,K,P,B,O,_,D,A,N,z,j,U,$,q,G,Q,J,V,X={html:!1,photo:!1,iframe:!1,inline:!1,transition:\"elastic\",speed:300,fadeOut:300,width:!1,initialWidth:\"600\",innerWidth:!1,maxWidth:!1,height:!1,initialHeight:\"450\",innerHeight:!1,maxHeight:!1,scalePhotos:!0,scrolling:!0,href:!1,title:!1,rel:!1,opacity:.9,preloading:!0,className:!1,overlayClose:!0,escKey:!0,arrowKey:!0,top:!1,bottom:!1,left:!1,right:!1,fixed:!1,data:void 0,closeButton:!0,fastIframe:!0,open:!1,reposition:!0,loop:!0,slideshow:!1,slideshowAuto:!0,slideshowSpeed:2500,slideshowStart:\"start slideshow\",slideshowStop:\"stop slideshow\",photoRegex:/\\.(gif|png|jp(e|g|eg)|bmp|ico|webp)((#|\\?).*)?$/i,retinaImage:!1,retinaUrl:!1,retinaSuffix:\"@2x.$1\",current:\"image {current} of {total}\",previous:\"previous\",next:\"next\",close:\"close\",xhrError:\"This content failed to load.\",imgError:\"This image failed to load.\",returnFocus:!0,trapFocus:!0,onOpen:!1,onLoad:!1,onComplete:!1,onCleanup:!1,onClosed:!1},Y=\"colorbox\",Z=\"cbox\",et=Z+\"Element\",tt=Z+\"_open\",it=Z+\"_load\",ot=Z+\"_complete\",nt=Z+\"_cleanup\",rt=Z+\"_closed\",ht=Z+\"_purge\",lt=e(\"<a/>\"),st=\"div\",at=0,dt={},ct=function(){function e(){clearTimeout(h)}function t(){(B.loop||k[z+1])&&(e(),h=setTimeout(Q.next,B.slideshowSpeed))}function i(){M.html(B.slideshowStop).unbind(s).one(s,o),lt.bind(ot,t).bind(it,e),g.removeClass(l+\"off\").addClass(l+\"on\")}function o(){e(),lt.unbind(ot,t).unbind(it,e),M.html(B.slideshowStart).unbind(s).one(s,function(){Q.next(),i()}),g.removeClass(l+\"on\").addClass(l+\"off\")}function n(){r=!1,M.hide(),e(),lt.unbind(ot,t).unbind(it,e),g.removeClass(l+\"off \"+l+\"on\")}var r,h,l=Z+\"Slideshow_\",s=\"click.\"+Z;return function(){r?B.slideshow||(lt.unbind(nt,n),n()):B.slideshow&&k[1]&&(r=!0,lt.one(nt,n),B.slideshowAuto?i():o(),M.show())}}();e.colorbox||(e(f),Q=e.fn[Y]=e[Y]=function(t,i){var o=this;if(t=t||{},f(),p()){if(e.isFunction(o))o=e(\"<a/>\"),t.open=!0;else if(!o[0])return o;i&&(t.onComplete=i),o.each(function(){e.data(this,Y,e.extend({},e.data(this,Y)||X,t))}).addClass(et),(e.isFunction(t.open)&&t.open.call(o)||t.open)&&u(o[0])}return o},Q.position=function(t,i){function o(){x[0].style.width=C[0].style.width=y[0].style.width=parseInt(g[0].style.width,10)-_+\"px\",y[0].style.height=b[0].style.height=T[0].style.height=parseInt(g[0].style.height,10)-O+\"px\"}var r,l,s,a=0,d=0,c=g.offset();if(E.unbind(\"resize.\"+Z),g.css({top:-9e4,left:-9e4}),l=E.scrollTop(),s=E.scrollLeft(),B.fixed?(c.top-=l,c.left-=s,g.css({position:\"fixed\"})):(a=l,d=s,g.css({position:\"absolute\"})),d+=B.right!==!1?Math.max(E.width()-B.w-A-_-h(B.right,\"x\"),0):B.left!==!1?h(B.left,\"x\"):Math.round(Math.max(E.width()-B.w-A-_,0)/2),a+=B.bottom!==!1?Math.max(n()-B.h-D-O-h(B.bottom,\"y\"),0):B.top!==!1?h(B.top,\"y\"):Math.round(Math.max(n()-B.h-D-O,0)/2),g.css({top:c.top,left:c.left,visibility:\"visible\"}),v[0].style.width=v[0].style.height=\"9999px\",r={width:B.w+A+_,height:B.h+D+O,top:a,left:d},t){var u=0;e.each(r,function(e){return r[e]!==dt[e]?(u=t,void 0):void 0}),t=u}dt=r,t||g.css(r),g.dequeue().animate(r,{duration:t||0,complete:function(){o(),$=!1,v[0].style.width=B.w+A+_+\"px\",v[0].style.height=B.h+D+O+\"px\",B.reposition&&setTimeout(function(){E.bind(\"resize.\"+Z,Q.position)},1),i&&i()},step:o})},Q.resize=function(e){var t;U&&(e=e||{},e.width&&(B.w=h(e.width,\"x\")-A-_),e.innerWidth&&(B.w=h(e.innerWidth,\"x\")),H.css({width:B.w}),e.height&&(B.h=h(e.height,\"y\")-D-O),e.innerHeight&&(B.h=h(e.innerHeight,\"y\")),e.innerHeight||e.height||(t=H.scrollTop(),H.css({height:\"auto\"}),B.h=H.height()),H.css({height:B.h}),t&&H.scrollTop(t),Q.position(\"none\"===B.transition?0:B.speed))},Q.prep=function(i){function n(){return B.w=B.w||H.width(),B.w=B.mw&&B.mw<B.w?B.mw:B.w,B.w}function h(){return B.h=B.h||H.height(),B.h=B.mh&&B.mh<B.h?B.mh:B.h,B.h}if(U){var a,d=\"none\"===B.transition?0:B.speed;H.empty().remove(),H=o(st,\"LoadedContent\").append(i),H.hide().appendTo(W.show()).css({width:n(),overflow:B.scrolling?\"auto\":\"hidden\"}).css({height:h()}).prependTo(y),W.hide(),e(j).css({\"float\":\"none\"}),a=function(){function i(){e.support.opacity===!1&&g[0].style.removeAttribute(\"filter\")}var n,h,a=k.length,u=\"frameBorder\",f=\"allowTransparency\";U&&(h=function(){clearTimeout(G),F.hide(),c(ot,B.onComplete)},L.html(B.title).add(H).show(),a>1?(\"string\"==typeof B.current&&S.html(B.current.replace(\"{current}\",z+1).replace(\"{total}\",a)).show(),R[B.loop||a-1>z?\"show\":\"hide\"]().html(B.next),I[B.loop||z?\"show\":\"hide\"]().html(B.previous),ct(),B.preloading&&e.each([r(-1),r(1)],function(){var i,o,n=k[this],r=e.data(n,Y);r&&r.href?(i=r.href,e.isFunction(i)&&(i=i.call(n))):i=e(n).attr(\"href\"),i&&l(r,i)&&(i=s(r,i),o=t.createElement(\"img\"),o.src=i)})):P.hide(),B.iframe?(n=o(\"iframe\")[0],u in n&&(n[u]=0),f in n&&(n[f]=\"true\"),B.scrolling||(n.scrolling=\"no\"),e(n).attr({src:B.href,name:(new Date).getTime(),\"class\":Z+\"Iframe\",allowFullScreen:!0,webkitAllowFullScreen:!0,mozallowfullscreen:!0}).one(\"load\",h).appendTo(H),lt.one(ht,function(){n.src=\"//about:blank\"}),B.fastIframe&&e(n).trigger(\"load\")):h(),\"fade\"===B.transition?g.fadeTo(d,1,i):i())},\"fade\"===B.transition?g.fadeTo(d,0,function(){Q.position(0,a)}):Q.position(d,a)}},Q.next=function(){!$&&k[1]&&(B.loop||k[z+1])&&(z=r(1),u(k[z]))},Q.prev=function(){!$&&k[1]&&(B.loop||z)&&(z=r(-1),u(k[z]))},Q.close=function(){U&&!q&&(q=!0,U=!1,c(nt,B.onCleanup),E.unbind(\".\"+Z),w.fadeTo(B.fadeOut||0,0),g.stop().fadeTo(B.fadeOut||0,0,function(){g.add(w).css({opacity:1,cursor:\"auto\"}).hide(),c(ht),H.empty().remove(),setTimeout(function(){q=!1,c(rt,B.onClosed)},1)}))},Q.remove=function(){g&&(g.stop(),e.colorbox.close(),g.stop().remove(),w.remove(),q=!1,g=null,e(\".\"+et).removeData(Y).removeClass(et),e(t).unbind(\"click.\"+Z))},Q.element=function(){return e(N)},Q.settings=X)})(jQuery,document,window);",
    "/*! \r\n    Authored by Jim Riecken - released under the MIT License. \r\n    Modified by Jon Wiedmann\r\n*/\r\n\r\n/*\r\n    A simple library for determining intersections of circles and\r\n    polygons using the Separating Axis Theorem.\r\n\r\n    jshint shadow:true, sub:true, forin:true, noarg:true, noempty:true, \r\n    eqeqeq:true, bitwise:true, strict:true, undef:true, \r\n    curly:true, browser:true \r\n*/\r\n\r\nvar SAT = {};\r\n(function(SAT) {\r\n    \"use strict\";\r\n  \r\n    /*\r\n        Represents a vector in two dimensions.\r\n     \r\n        @param {?number=} x The x position.\r\n        @param {?number=} y The y position.\r\n        @constructor\r\n    */\r\n    var Vector = function(x, y) {\r\n        this.x = x || 0;\r\n        this.y = y || 0;\r\n    };\r\n    SAT.Vector = Vector;\r\n\r\n    /*\r\n        Copy the values of another Vector into this one.\r\n    \r\n        @param {Vector} other The other Vector.\r\n        @return {Vector} This for chaining.\r\n    */\r\n    Vector.prototype.copy = function(other) {\r\n        this.x = other.x; \r\n        this.y = other.y;\r\n\r\n        return this;\r\n    };\r\n    \r\n    /*\r\n        Rotate this vector by 90 degrees\r\n    \r\n        @return {Vector} This for chaining.\r\n    */\r\n    Vector.prototype.perp = function() {\r\n        var x = this.x;\r\n        this.x = this.y; \r\n        this.y = -x;\r\n\r\n        return this;\r\n    };\r\n    \r\n    /*\r\n        Reverse this vector.\r\n    \r\n        @return {Vector} This for chaining.\r\n    */\r\n    Vector.prototype.reverse = function() {\r\n        this.x = -this.x; \r\n        this.y = -this.y;\r\n\r\n        return this;\r\n    };\r\n  \r\n    /*\r\n        Normalize (make unit length) this vector.\r\n        \r\n        @return {Vector} This for chaining.\r\n    */\r\n    Vector.prototype.normalize = function() {\r\n        var d = this.len();\r\n\r\n        if(d > 0) {\r\n            this.x = this.x / d; \r\n            this.y = this.y / d;\r\n        }\r\n\r\n        return this;\r\n    };\r\n  \r\n    /*\r\n        Add another vector to this one.\r\n    \r\n        @param {Vector} other The other Vector.\r\n        @return {Vector} This for chaining.\r\n    */\r\n    Vector.prototype.add = function(other) {\r\n        this.x += other.x; \r\n        this.y += other.y;\r\n\r\n        return this;\r\n    };\r\n  \r\n    /*\r\n        Subtract another vector from this one.\r\n    \r\n        @param {Vector} other The other Vector.\r\n        @return {Vector} This for chaiing.\r\n    */\r\n    Vector.prototype.sub = function(other) {\r\n        this.x -= other.x;\r\n        this.y -= other.y;\r\n\r\n        return this;\r\n    };\r\n  \r\n    /*\r\n        Scale this vector.\r\n    \r\n        @param {number} x The scaling factor in the x direction.\r\n        @param {?number=} y The scaling factor in the y direction.  If this\r\n        is not specified, the x scaling factor will be used.\r\n        @return {Vector} This for chaining.\r\n    */\r\n    Vector.prototype.scale = function(x,y) {\r\n        this.x *= x; \r\n        this.y *= y || x;\r\n\r\n        return this; \r\n    };\r\n  \r\n    /*\r\n        Project this vector on to another vector.\r\n    \r\n        @param {Vector} other The vector to project onto.\r\n        @return {Vector} This for chaining.\r\n    */\r\n    Vector.prototype.project = function(other) {\r\n        var amt = this.dot(other) / other.len2();\r\n\r\n        this.x = amt * other.x; \r\n        this.y = amt * other.y;\r\n\r\n        return this;\r\n    };\r\n  \r\n    /*\r\n        Project this vector onto a vector of unit length.\r\n    \r\n        @param {Vector} other The unit vector to project onto.\r\n        @return {Vector} This for chaining.\r\n    */\r\n    Vector.prototype.projectN = function(other) {\r\n    var amt = this.dot(other);\r\n    this.x = amt * other.x; \r\n    this.y = amt * other.y;\r\n    return this;\r\n    };\r\n    Vector.prototype['projectN'] = Vector.prototype.projectN;\r\n  \r\n    /*\r\n        Reflect this vector on an arbitrary axis.\r\n    \r\n        @param {Vector} axis The vector representing the axis.\r\n        @return {Vector} This for chaining.\r\n    */\r\n    Vector.prototype.reflect = function(axis) {\r\n        var x = this.x;\r\n        var y = this.y;\r\n\r\n        this.project(axis).scale(2);\r\n\r\n        this.x -= x;\r\n        this.y -= y;\r\n\r\n        return this;\r\n    };\r\n  \r\n    /*\r\n        Reflect this vector on an arbitrary axis (represented by a unit vector)\r\n    \r\n        @param {Vector} axis The unit vector representing the axis.\r\n        @return {Vector} This for chaining.\r\n    */\r\n    Vector.prototype.reflectN = function(axis) {\r\n        var x = this.x;\r\n        var y = this.y;\r\n\r\n        this.projectN(axis).scale(2);\r\n\r\n        this.x -= x;\r\n        this.y -= y;\r\n\r\n        return this;\r\n    };\r\n  \r\n    /*\r\n        Get the dot product of this vector against another.\r\n     \r\n        @param {Vector}  other The vector to dot this one against.\r\n        @return {number} The dot product.\r\n    */\r\n    Vector.prototype.dot = function(other) {\r\n        return this.x * other.x + this.y * other.y;\r\n    };\r\n  \r\n    /*\r\n        Get the length^2 of this vector.\r\n    \r\n        @return {number} The length^2 of this vector.\r\n    */\r\n    Vector.prototype.len2 = function() {\r\n        return this.dot(this);\r\n    };\r\n  \r\n    /*\r\n        Get the length of this vector.\r\n    \r\n        @return {number} The length of this vector.\r\n    */\r\n    Vector.prototype.len = function() {\r\n        return Math.sqrt(this.len2());\r\n    };\r\n  \r\n\r\n    /*\r\n        A circle.\r\n    \r\n        @param {Vector=} pos A vector representing the position of the center of the circle\r\n        @param {?number=} r The radius of the circle\r\n        @constructor\r\n    */\r\n    //var Circle = function(pos, r) {\r\n    //    this.pos = pos || new Vector();\r\n    //    this.r = r || 0;\r\n    //};\r\n    //SAT.Circle = Circle;\r\n  \r\n\r\n    /*\r\n        A *convex* clockwise polygon.\r\n    \r\n        @param {Vector=} pos A vector representing the origin of the polygon. (all other\r\n            points are relative to this one)\r\n        @param {Array.<Vector>=} points An array of vectors representing the points in the polygon,\r\n            in clockwise order.\r\n        @constructor\r\n    */\r\n    var Polygon = function(pos, points) {\r\n        this.pos = pos || new Vector();\r\n        this.points = points || [];\r\n\r\n        this.recalc();\r\n    };\r\n    SAT.Polygon = Polygon;\r\n  \r\n    /*\r\n        Recalculate the edges and normals of the polygon.  This\r\n        MUST be called if the points array is modified at all and\r\n        the edges or normals are to be accessed.\r\n    */\r\n    Polygon.prototype.recalc = function() {\r\n        var points = this.points;\r\n        var len = points.length;\r\n\r\n        this.edges = []; \r\n        this.normals = [];\r\n\r\n        for (var i = 0; i < len; i++) {\r\n            var p1 = points[i]; \r\n            var p2 = i < len - 1 ? points[i + 1] : points[0];\r\n\r\n            var e = new Vector().copy(p2).sub(p1);\r\n            var n = new Vector().copy(e).perp().normalize();\r\n\r\n            this.edges.push(e);\r\n            this.normals.push(n);\r\n        }\r\n    };\r\n    \r\n  \r\n    /*\r\n        An axis-aligned box, with width and height.\r\n    \r\n        @param {Vector=} pos A vector representing the top-left of the box.\r\n        @param {?number=} w The width of the box.\r\n        @param {?number=} h The height of the box.\r\n        @constructor\r\n    */\r\n    var Box = function(pos, w, h) {\r\n        this.pos = pos || new Vector();\r\n        this.w = w || 0; \r\n        this.h = h || 0;\r\n    };\r\n    SAT.Box = Box;\r\n\r\n    /*\r\n        Create a polygon that is the same as this box.\r\n    \r\n        @return {Polygon} A new Polygon that represents this box.\r\n    */\r\n    Box.prototype.toPolygon = function() {\r\n        var pos = this.pos;\r\n        var w = this.w;\r\n        var h = this.h;\r\n\r\n        return new Polygon(new Vector(pos.x, pos.y), [\r\n            new Vector(), new Vector(w, 0), \r\n            new Vector(w,h), new Vector(0,h)\r\n        ]);\r\n    };\r\n  \r\n    /*\r\n        Pool of Vectors used in calculations.\r\n    \r\n        @type {Array.<Vector>}\r\n    */\r\n    var T_VECTORS = [];\r\n    for (var i = 0; i < 10; ++i) { T_VECTORS.push(new Vector()); }\r\n\r\n    /*\r\n        Pool of Arrays used in calculations.\r\n    \r\n        @type {Array.<Array.<*>>}\r\n    */\r\n    var T_ARRAYS = [];\r\n    for (var i = 0; i < 5; ++i) { T_ARRAYS.push([]); }\r\n\r\n    /*\r\n        An object representing the result of an intersection. Contain information about:\r\n            - The two objects participating in the intersection\r\n            - The vector representing the minimum change necessary to extract the first object\r\n              from the second one.\r\n            - Whether the first object is entirely inside the second, or vice versa.\r\n    \r\n        @constructor\r\n    */  \r\n    var Response = function() {\r\n        this.a = null;\r\n        this.b = null;\r\n\r\n        this.overlapN = new Vector(); // Unit vector in the direction of overlap\r\n        this.overlapV = new Vector(); // Subtract this from a's position to extract it from b\r\n\r\n        this.clear();\r\n    };\r\n    SAT.Response = Response;\r\n\r\n    /*\r\n        Set some values of the response back to their defaults.  Call this between tests if \r\n        you are going to reuse a single Response object for multiple intersection tests (recommented)\r\n    \r\n        @return {Response} This for chaining\r\n    */\r\n    Response.prototype.clear = function() {\r\n        this.aInB = true; // Is a fully inside b?\r\n        this.bInA = true; // Is b fully inside a?\r\n        this.overlap = Number.MAX_VALUE; // Amount of overlap (magnitude of overlapV). Can be 0 (if a and b are touching)\r\n\r\n        return this;\r\n    };\r\n  \r\n    /*\r\n        Flattens the specified array of points onto a unit vector axis,\r\n        resulting in a one dimensional range of the minimum and \r\n        maximum value on that axis.\r\n    \r\n        @param {Array.<Vector>} points The points to flatten.\r\n        @param {Vector} normal The unit vector axis to flatten on.\r\n        @param {Array.<number>} result An array.  After calling this function,\r\n            result[0] will be the minimum value,\r\n        result[1] will be the maximum value.\r\n    */\r\n    var flattenPointsOn = function(points, normal, result) {\r\n        var min = Number.MAX_VALUE;\r\n        var max = -Number.MAX_VALUE;\r\n        var len = points.length;\r\n\r\n        for (var i = 0; i < len; ++i ) {\r\n            // Get the magnitude of the projection of the point onto the normal\r\n            var dot = points[i].dot(normal);\r\n\r\n            if (dot < min) { min = dot; }\r\n            if (dot > max) { max = dot; }\r\n        }\r\n\r\n        result[0] = min;\r\n        result[1] = max;\r\n    };\r\n  \r\n    /*\r\n        Check whether two convex clockwise polygons are separated by the specified\r\n        axis (must be a unit vector).\r\n    \r\n        @param {Vector} aPos The position of the first polygon.\r\n        @param {Vector} bPos The position of the second polygon.\r\n        @param {Array.<Vector>} aPoints The points in the first polygon.\r\n        @param {Array.<Vector>} bPoints The points in the second polygon.\r\n        @param {Vector} axis The axis (unit sized) to test against.  The points of both polygons\r\n            will be projected onto this axis.\r\n        @param {Response=} response A Response object (optional) which will be populated\r\n            if the axis is not a separating axis.\r\n        @return {boolean} true if it is a separating axis, false otherwise.  If false,\r\n            and a response is passed in, information about how much overlap and\r\n            the direction of the overlap will be populated.\r\n    */\r\n    var isSeparatingAxis = function(aPos, bPos, aPoints, bPoints, axis, response) {\r\n        var rangeA = T_ARRAYS.pop();\r\n        var rangeB = T_ARRAYS.pop();\r\n\r\n        // Get the magnitude of the offset between the two polygons\r\n        var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);\r\n        var projectedOffset = offsetV.dot(axis);\r\n\r\n        // Project the polygons onto the axis.\r\n        flattenPointsOn(aPoints, axis, rangeA);\r\n        flattenPointsOn(bPoints, axis, rangeB);\r\n\r\n        // Move B's range to its position relative to A.\r\n        rangeB[0] += projectedOffset;\r\n        rangeB[1] += projectedOffset;\r\n\r\n        // Check if there is a gap. If there is, this is a separating axis and we can stop\r\n        if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {\r\n            T_VECTORS.push(offsetV); \r\n            T_ARRAYS.push(rangeA); \r\n            T_ARRAYS.push(rangeB);\r\n\r\n            return true;\r\n        }\r\n\r\n        // If we're calculating a response, calculate the overlap.\r\n        if (response) {\r\n            var overlap = 0;\r\n\r\n            // A starts further left than B\r\n            if (rangeA[0] < rangeB[0]) {\r\n                response.aInB = false;\r\n\r\n                // A ends before B does. We have to pull A out of B\r\n                if (rangeA[1] < rangeB[1]) { \r\n                    overlap = rangeA[1] - rangeB[0];\r\n                    response.bInA = false;\r\n                }\r\n                else {  // B is fully inside A.  Pick the shortest way out.\r\n                    var option1 = rangeA[1] - rangeB[0];\r\n                    var option2 = rangeB[1] - rangeA[0];\r\n                    overlap = option1 < option2 ? option1 : -option2;\r\n                }\r\n            \r\n            }\r\n            else {  // B starts further left than A\r\n                response.bInA = false;\r\n\r\n                // B ends before A ends. We have to push A out of B\r\n                if (rangeA[1] > rangeB[1]) { \r\n                    overlap = rangeA[0] - rangeB[1];\r\n                    response.aInB = false;\r\n                }\r\n                else {  // A is fully inside B.  Pick the shortest way out.\r\n                    var option1 = rangeA[1] - rangeB[0];\r\n                    var option2 = rangeB[1] - rangeA[0];\r\n\r\n                    overlap = option1 < option2 ? option1 : -option2;\r\n                }\r\n            }\r\n\r\n            // If this is the smallest amount of overlap we've seen so far, set it as the minimum overlap.\r\n            var absOverlap = Math.abs(overlap);\r\n            if (absOverlap < response.overlap) {\r\n                response.overlap = absOverlap;\r\n                response.overlapN.copy(axis);\r\n\r\n                if (overlap < 0) {\r\n                    response.overlapN.reverse();\r\n                }\r\n            }      \r\n        }\r\n\r\n        T_VECTORS.push(offsetV); \r\n        T_ARRAYS.push(rangeA); \r\n        T_ARRAYS.push(rangeB);\r\n\r\n        return false;\r\n    };\r\n  \r\n    /*\r\n        Calculates which Vornoi region a point is on a line segment.\r\n        It is assumed that both the line and the point are relative to (0, 0)\r\n    \r\n                 |       (0)      | \r\n          (-1)  [0]--------------[1]  (1)\r\n                 |       (0)      | \r\n     \r\n        @param {Vector} line The line segment.\r\n        @param {Vector} point The point.\r\n        @return {number} LEFT_VORNOI_REGION (-1) if it is the left region, \r\n               MIDDLE_VORNOI_REGION (0) if it is the middle region, \r\n               RIGHT_VORNOI_REGION (1) if it is the right region.\r\n    */\r\n    var vornoiRegion = function(line, point) {\r\n        var len2 = line.len2();\r\n        var dp = point.dot(line);\r\n\r\n        if (dp < 0) { return LEFT_VORNOI_REGION; }\r\n        else if (dp > len2) { return RIGHT_VORNOI_REGION; }\r\n        else { return MIDDLE_VORNOI_REGION; }\r\n    };\r\n\r\n    // @const\r\n    var LEFT_VORNOI_REGION = -1;\r\n\r\n    // @const\r\n    var MIDDLE_VORNOI_REGION = 0;\r\n    \r\n    // @const\r\n    var RIGHT_VORNOI_REGION = 1;\r\n  \r\n    /*\r\n        Check if two circles intersect.\r\n    \r\n        @param {Circle} a The first circle.\r\n        @param {Circle} b The second circle.\r\n        @param {Response=} response Response object (optional) that will be populated if\r\n            the circles intersect.\r\n        @return {boolean} true if the circles intersect, false if they don't. \r\n    */\r\n    //SAT.testCircleCircle = function (a, b, response) {\r\n    //    var differenceV = T_VECTORS.pop().copy(b.pos).sub(a.pos);\r\n    //    var totalRadius = a.r + b.r;\r\n    //    var totalRadiusSq = totalRadius * totalRadius;\r\n    //    var distanceSq = differenceV.len2();\r\n\r\n    //    if (distanceSq > totalRadiusSq) {\r\n    //        // They do not intersect \r\n    //        T_VECTORS.push(differenceV);\r\n    //        return false;\r\n    //    }\r\n\r\n    //    // They intersect.  If we're calculating a response, calculate the overlap.\r\n    //    if (response) {\r\n    //        var dist = Math.sqrt(distanceSq);\r\n    //        response.a = a;\r\n    //        response.b = b;\r\n    //        response.overlap = totalRadius - dist;\r\n    //        response.overlapN.copy(differenceV.normalize());\r\n    //        response.overlapV.copy(differenceV).scale(response.overlap);\r\n    //        response.aInB = a.r <= b.r && dist <= b.r - a.r;\r\n    //        response.bInA = b.r <= a.r && dist <= a.r - b.r;\r\n    //    }\r\n\r\n    //    T_VECTORS.push(differenceV);\r\n\r\n    //    return true;\r\n    //};\r\n  \r\n    /*\r\n        Check if a polygon and a circle intersect.\r\n    \r\n        @param {Polygon} polygon The polygon.\r\n        @param {Circle} circle The circle.\r\n        @param {Response=} response Response object (optional) that will be populated if\r\n            they interset.\r\n        @return {boolean} true if they intersect, false if they don't.\r\n    */\r\n    //var testPolygonCircle = function(polygon, circle, response) {\r\n    //    var circlePos = T_VECTORS.pop().copy(circle.pos).sub(polygon.pos);\r\n    //    var radius = circle.r;\r\n    //    var radius2 = radius * radius;\r\n    //    var points = polygon.points;\r\n    //    var len = points.length;\r\n    //    var edge = T_VECTORS.pop();\r\n    //    var point = T_VECTORS.pop();\r\n    \r\n    //    // For each edge in the polygon\r\n    //    for (var i = 0; i < len; ++i) {\r\n    //        var next = i === len - 1 ? 0 : i + 1;\r\n    //        var prev = i === 0 ? len - 1 : i - 1;\r\n    //        var overlap = 0;\r\n    //        var overlapN = null;\r\n      \r\n    //        // Get the edge\r\n    //        edge.copy(polygon.edges[i]);\r\n\r\n    //        // Calculate the center of the cirble relative to the starting point of the edge\r\n    //        point.copy(circlePos).sub(points[i]);\r\n      \r\n    //        // If the distance between the center of the circle and the point\r\n    //        // is bigger than the radius, the polygon is definitely not fully in\r\n    //        // the circle.\r\n    //        if (response && point.len2() > radius2) {\r\n    //            response.aInB = false;\r\n    //        }\r\n      \r\n    //        // Calculate which Vornoi region the center of the circle is in.\r\n    //        var region = vornoiRegion(edge, point);\r\n    //        if (region === LEFT_VORNOI_REGION) { \r\n    //            // Need to make sure we're in the RIGHT_VORNOI_REGION of the previous edge.\r\n    //            edge.copy(polygon.edges[prev]);\r\n    //            // Calculate the center of the circle relative the starting point of the previous edge\r\n    //            var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);\r\n    //            region = vornoiRegion(edge, point2);\r\n    //            if (region === RIGHT_VORNOI_REGION) {\r\n    //                // It's in the region we want.  Check if the circle intersects the point.\r\n    //                var dist = point.len();\r\n    //                if (dist > radius) {\r\n    //                    // No intersection\r\n    //                    T_VECTORS.push(circlePos); \r\n    //                    T_VECTORS.push(edge);\r\n    //                    T_VECTORS.push(point); \r\n    //                    T_VECTORS.push(point2);\r\n\r\n    //                    return false;\r\n    //                }\r\n    //                else if (response) {\r\n    //                    // It intersects, calculate the overlap\r\n    //                    response.bInA = false;\r\n    //                    overlapN = point.normalize();\r\n    //                    overlap = radius - dist;\r\n    //                }\r\n    //            }\r\n\r\n    //            T_VECTORS.push(point2);\r\n    //        }\r\n    //        else if (region === RIGHT_VORNOI_REGION) {\r\n    //            // Need to make sure we're in the left region on the next edge\r\n    //            edge.copy(polygon.edges[next]);\r\n\r\n    //            // Calculate the center of the circle relative to the starting point of the next edge\r\n    //            point.copy(circlePos).sub(points[next]);\r\n    //            region = vornoiRegion(edge, point);\r\n\r\n    //            if (region === LEFT_VORNOI_REGION) {\r\n    //                // It's in the region we want.  Check if the circle intersects the point.\r\n    //                var dist = point.len();\r\n    //                if (dist > radius) {\r\n    //                    // No intersection\r\n    //                    T_VECTORS.push(circlePos); \r\n    //                    T_VECTORS.push(edge); \r\n    //                    T_VECTORS.push(point);\r\n\r\n    //                    return false;              \r\n    //                }\r\n    //                else if (response) {\r\n    //                    // It intersects, calculate the overlap\r\n    //                    response.bInA = false;\r\n    //                    overlapN = point.normalize();\r\n    //                    overlap = radius - dist;\r\n    //                }\r\n    //            }\r\n                \r\n    //        }\r\n    //        else {  // MIDDLE_VORNOI_REGION\r\n    //            // Need to check if the circle is intersecting the edge,\r\n    //            // Change the edge into its \"edge normal\".\r\n    //            var normal = edge.perp().normalize();\r\n\r\n    //            // Find the perpendicular distance between the center of the \r\n    //            // circle and the edge.\r\n    //            var dist = point.dot(normal);\r\n    //            var distAbs = Math.abs(dist);\r\n\r\n    //            // If the circle is on the outside of the edge, there is no intersection\r\n    //            if (dist > 0 && distAbs > radius) {\r\n    //                T_VECTORS.push(circlePos); \r\n    //                T_VECTORS.push(normal); \r\n    //                T_VECTORS.push(point);\r\n\r\n    //                return false;\r\n    //            }\r\n    //            else if (response) {\r\n    //                // It intersects, calculate the overlap.\r\n    //                overlapN = normal;\r\n    //                overlap = radius - dist;\r\n\r\n    //                // If the center of the circle is on the outside of the edge, or part of the\r\n    //                // circle is on the outside, the circle is not fully inside the polygon.\r\n    //                if (dist >= 0 || overlap < 2 * radius) {\r\n    //                    response.bInA = false;\r\n    //                }\r\n    //            }\r\n    //        }\r\n      \r\n    //        // If this is the smallest overlap we've seen, keep it. \r\n    //        // (overlapN may be null if the circle was in the wrong Vornoi region)\r\n    //        if (overlapN && response && Math.abs(overlap) < Math.abs(response.overlap)) {\r\n    //            response.overlap = overlap;\r\n    //            response.overlapN.copy(overlapN);\r\n    //        }\r\n    //    }\r\n    \r\n    //    // Calculate the final overlap vector - based on the smallest overlap.\r\n    //    if (response) {\r\n    //        response.a = polygon;\r\n    //        response.b = circle;\r\n    //        response.overlapV.copy(response.overlapN).scale(response.overlap);\r\n    //    }\r\n\r\n    //    T_VECTORS.push(circlePos); \r\n    //    T_VECTORS.push(edge); \r\n    //    T_VECTORS.push(point);\r\n\r\n    //    return true;\r\n    //};\r\n    //SAT.testPolygonCircle = testPolygonCircle;\r\n  \r\n    /*\r\n        Check if a circle and a polygon intersect.\r\n    \r\n        NOTE: This runs slightly slower than polygonCircle as it just\r\n            runs polygonCircle and reverses everything at the end.\r\n    \r\n        @param {Circle} circle The circle.\r\n        @param {Polygon} polygon The polygon.\r\n        @param {Response=} response Response object (optional) that will be populated if\r\n            they interset.\r\n        @return {boolean} true if they intersect, false if they don't.\r\n    */\r\n    //SAT.testCirclePolygon = function (circle, polygon, response) {\r\n    //    var result = testPolygonCircle(polygon, circle, response);\r\n\r\n    //    if (result && response) {\r\n    //        // Swap A and B in the response.\r\n    //        var a = response.a;\r\n    //        var aInB = response.aInB;\r\n    //        response.overlapN.reverse();\r\n    //        response.overlapV.reverse();\r\n    //        response.a = response.b;\r\n    //        response.b = a;\r\n    //        response.aInB = response.bInA;\r\n    //        response.bInA = aInB;\r\n    //    }\r\n\r\n    //    return result;\r\n    //};\r\n  \r\n    /*\r\n        Checks whether two convex, clockwise polygons intersect.\r\n    \r\n        @param {Polygon} a The first polygon.\r\n        @param {Polygon} b The second polygon.\r\n        @param {Response=} response Response object (optional) that will be populated if\r\n        they interset.\r\n        @return {boolean} true if they intersect, false if they don't.\r\n    */\r\n    SAT.testPolygonPolygon = function (a, b, response) {\r\n        var aPoints = a.points;\r\n        var aLen = aPoints.length;\r\n        var bPoints = b.points;\r\n        var bLen = bPoints.length;\r\n\r\n        // If any of the edge normals of A is a separating axis, no intersection.\r\n        for (var i = 0; i < aLen; i++) {\r\n            if (isSeparatingAxis(a.pos, b.pos, aPoints, bPoints, a.normals[i], response)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // If any of the edge normals of B is a separating axis, no intersection.\r\n        for (var i = 0; i < bLen; i++) {\r\n            if (isSeparatingAxis(a.pos, b.pos, aPoints, bPoints, b.normals[i], response)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Since none of the edge normals of A or B are a separating axis, there is an intersection\r\n        // and we've already calculated the smallest overlap (in isSeparatingAxis).  Calculate the\r\n        // final overlap vector.\r\n        if (response) {\r\n            response.a = a;\r\n            response.b = b;\r\n            response.overlapV.copy(response.overlapN).scale(response.overlap);\r\n        }\r\n\r\n        return true;\r\n    };\r\n}(SAT));",
    "/// <reference path=\"linker.js\" />\r\n\r\n/*\r\n    A place for generic math, set/get methods, and other small functions.\r\n    Also used for global data structures, enums, and functions.\r\n*/\r\nvar utils = (function () {\r\n    var cboxMenu;\r\n\r\n\r\n    return {\r\n        /*\r\n            extends an oldObj into a newObj\r\n            while keeping certain objects properties in sync\r\n        */\r\n        extend: function (newObj, oldObj) {\r\n            // merge-copy current oldObj into newObj\r\n            $.extend(newObj, oldObj);\r\n\r\n            // force newObj to get oldObj's imgReady property\r\n            var prop = \"imgReady\";\r\n            Object.defineProperty(newObj, prop, {\r\n                get: function () {\r\n                    return oldObj[prop];\r\n                },\r\n                //set: function (arg) {\r\n                //    oldObj[prop] = arg;\r\n                //},\r\n                //configurable: true\r\n            });\r\n\r\n        },\r\n\r\n        repeatAction: function (timeStep, numTimes, callback) {\r\n            var num = 0;\r\n            var theAnimation = setInterval(function () {\r\n                if (num++ > numTimes) {\r\n                    clearInterval(theAnimation);\r\n                }\r\n                else {\r\n                    callback();\r\n                }\r\n            }, timeStep);\r\n        },\r\n\r\n        deathSequence: function(){\r\n            if (!game.over) {\r\n                game.over = true;\r\n\r\n                audio.heroDeath.play();\r\n                audio.bgMusic.muted = true;\r\n\r\n                setTimeout(function () {\r\n                    Graphics.fadeCanvas(function () {\r\n                        level.reset();\r\n                        level.curLvl.deinit();\r\n                        level.curLvl.init();\r\n\r\n                        if (audio.isOn)\r\n                            audio.bgMusic.muted = false;\r\n                    });\r\n                }, 3000);\r\n            }\r\n        },\r\n\r\n        degToRad: function(deg){\r\n            return deg * 0.0174532925199432957;\r\n        },\r\n\r\n        getTimeObj: function (t) {\r\n            if (t === 0) {\r\n                return { min: \"00\", sec: \"00\" };\r\n            }\r\n            \r\n            var min = Math.floor(t / 60);\r\n            var sec = t % 60;\r\n\r\n            if (sec < 10) {\r\n                sec = '0' + sec;\r\n            }\r\n\r\n            if (min < 10) {\r\n                min = '0' + min;\r\n            }\r\n\r\n            return {\r\n                min: min,\r\n                sec: sec\r\n            };\r\n        },\r\n\r\n        /**** Debug Printers ****/\r\n        // A method to print to the console less frequently then within the game loop.\r\n        printSlow: function(msg){\r\n            if (game.actualTime % 10 === 0) {\r\n                console.log(msg);\r\n            }\r\n        },\r\n\r\n\t\tprintMouse: function () {\r\n\t\t    $(\"canvas\").on(\"mousemove\", function (e) {\r\n\t\t        console.log(e.offsetX, e.offsetY);\r\n\t\t    });\r\n\t\t},\r\n\r\n\t\tprintDir: function (dir) {\r\n\t\t    switch (dir) {\r\n\t\t        case 0:\r\n\t\t            console.log(\"Dir.NONE\");\r\n\t\t            break;\r\n\t\t        case 1:\r\n\t\t            console.log(\"Dir.TOP\");\r\n\t\t            break;\r\n\t\t        case 2:\r\n\t\t            console.log(\"Dir.BOT\");\r\n\t\t            break;\r\n\t\t        case 3:\r\n\t\t            console.log(\"Dir.LEFT\");\r\n\t\t            break;\r\n\t\t        case 4:\r\n\t\t            console.log(\"Dir.RIGHT\");\r\n\t\t            break;\r\n\t\t        case 5:\r\n\t\t            console.log(\"Dir.IN\");\r\n\t\t            break;\r\n\t\t        default:\r\n\t\t            console.log(\"Dir.unknown\");\r\n\t\t    }\r\n\t\t},\r\n\r\n\t\ttoggleMenu: function () {\r\n\r\n\t\t    if ($(\"#colorbox\").css(\"display\") === \"block\") {\r\n\t\t        cboxMenu.colorbox.close();\r\n\t\t    }\r\n\t\t    else {\r\n\t\t        cboxMenu = $.colorbox({\r\n\t\t            html: $(\".gameInstructions\").html(),\r\n\t\t            width: 320,\r\n\t\t            height: 530\r\n\t\t        });\r\n\t\t    }\r\n\t\t},\r\n\r\n\t\ttoggleFullScreen: function () {\r\n\r\n\r\n\t\t    // fill browser window\r\n\t\t    if ($(\"body\").hasClass(\"fullscreen\")) {\r\n\t\t        $(\".canvasWrap\").css({\r\n\t\t            width: \"\",\r\n\t\t            marginLeft: \"\"\r\n\t\t        });\r\n\r\n\t\t        $(\"body\").removeClass(\"fullscreen\");\r\n\t\t    }\r\n\t\t    else {\r\n\t\t        $(\"body\").addClass(\"fullscreen\");\r\n\r\n\t\t        var scaledW = $(window).height() * 1.777778;\r\n\r\n\t\t        $(\".canvasWrap\").css({\r\n\t\t            width: scaledW,\r\n\t\t            marginLeft: -scaledW / 2\r\n\t\t        });\r\n\t\t    }\r\n\r\n\r\n\r\n            // fullscreen API\r\n            //if (!document.fullscreenElement &&    // alternative standard method\r\n            //    !document.mozFullScreenElement && !document.webkitFullscreenElement) {  // current working methods\r\n\r\n            //    if (canvas.requestFullscreen) {\r\n            //        canvas.requestFullscreen();\r\n            //    }\r\n            //    else if (canvas.mozRequestFullScreen) {\r\n            //        canvas.mozRequestFullScreen();\r\n            //    }\r\n            //    else if (canvas.webkitRequestFullscreen) {\r\n            //        canvas.webkitRequestFullscreen(); //Element.ALLOW_KEYBOARD_INPUT\r\n            //    }\r\n            //}\r\n            //else {\r\n            //    if (document.cancelFullScreen) {\r\n            //        document.cancelFullScreen();\r\n            //    }\r\n            //    else if (document.mozCancelFullScreen) {\r\n            //        document.mozCancelFullScreen();\r\n            //    }\r\n            //    else if (document.webkitCancelFullScreen) {\r\n            //        document.webkitCancelFullScreen();\r\n            //    }\r\n            //}\r\n        }\r\n\r\n\t};\r\n})();\r\n\r\n\r\n// global enums\r\nvar Dir = Object.freeze({\r\n    NONE: 0,\r\n    TOP: 1,\r\n    BOT: 2,\r\n    LEFT: 3,\r\n    RIGHT: 4,\r\n    IN: 5\r\n});\r\n\r\nvar Inv_e = Object.freeze({\r\n    NOT_HIT: 0,\r\n    HIT_WHITE: 1,\r\n    HIT_RED: 2\r\n});\r\n\r\nvar KeyCode = Object.freeze({\r\n    ENTER: 13,\r\n    J: 74,\r\n    K: 75,\r\n    O: 79,\r\n    S: 83,\r\n    W: 87,\r\n    EMPTY: -1\r\n});\r\n\r\nvar Color = Object.freeze({\r\n    LIGHT_BROWN: \"#c44525\",\r\n    DARK_BROWN: \"#672819\",\r\n    LIGHT_GREEN: \"#166a38\",\r\n    SILVER: \"#c0c0c0\",\r\n    BLACK: \"#000\",\r\n    GOLD: \"#ddaa13\",\r\n    ORANGE: \"#ff6a00\"\r\n});\r\n\r\nvar JQObject = Object.freeze({\r\n    EMPTY: 0,\r\n    CRATE: 1,\r\n    LADDER: 2,\r\n    SACK: 3,\r\n    ENEMY: 4,\r\n    CASH: 5,\r\n    DOOR: 6,\r\n    SCALE: 7,\r\n    SMALL_CLOUD: 8,\r\n    CLOUD: 9,\r\n    PLATFORM: 10,\r\n    FLOOR: 11\r\n});\r\n\r\nvar JQObject_names = Object.freeze({\r\n    0: \"EMPTY\",\r\n    1: \"CRATE\",\r\n    2: \"LADDER\",\r\n    3: \"SACK\",\r\n    4: \"ENEMY\",\r\n    5: \"CASH\",\r\n    6: \"DOOR\",\r\n    7: \"SCALE\",\r\n    8: \"SMALL_CLOUD\",\r\n    9: \"CLOUD\",\r\n    10: \"PLATFORM\",\r\n    11: \"FLOOR\"\r\n});\r\n\r\n\r\nvar bullet = {\r\n    w: 19.5,\r\n    h: 9,\r\n    speed: 4.4\r\n};\r\n\r\n// global functions\r\nwindow.requestAnimFrame = (function () {\r\n    return window.requestAnimationFrame ||\r\n\t\t   window.webkitRequestAnimationFrame ||\r\n\r\n\t\t   function (callback) {\r\n\t\t       setTimeout(callback, 16.6666666667); // 60fps fallback\r\n\t\t   };\r\n})();\r\n",
    "var audio = (function () {\r\n\r\n    return {\r\n        bgMusic: new Audio(\"audio/firstChiptune/firstChiptune.mp3\"),\r\n        enterSound: new Audio(\"audio/synthetic_explosion_1.mp3\"),\r\n        exitSound: new Audio(\"audio/annulet.mp3\"),\r\n        itemPickedUp: new Audio(\"audio/life_pickup.mp3\"),\r\n        heartbeat: new Audio(\"audio/heartbeat.mp3\"),\r\n        jump: new Audio(\"audio/jump.mp3\"),\r\n        thud: new Audio(\"audio/thud.mp3\"),\r\n        step: new Audio(\"audio/step.mp3\"),\r\n        effort: new Audio(\"audio/woosh.mp3\"),\r\n        discovery: new Audio(\"audio/spell3.mp3\"),\r\n        enemyDeath: new Audio(\"audio/death.mp3\"),\r\n        heroDeath: new Audio(\"audio/DiscsOfTron_Cascade.mp3\"),\r\n        enchant: new Audio(\"audio/enchant.mp3\"),\r\n        isOn: false,\r\n\r\n\r\n        init: function(){\r\n            audio.bgMusic.loop = true;\r\n            audio.bgMusic.volume = 0.7;\r\n            audio.bgMusic.pause();\r\n\r\n            audio.enemyDeath.volume = 0.6;\r\n            audio.jump.volume = 0.4;\r\n            audio.thud.volume = 0.78;\r\n            audio.discovery.volume = 0.7;\r\n\r\n            audio.mute(true);\r\n            $(document).on(\"click\", \".audioState\", audio.handleMuteButton);\r\n\r\n            $(\".menu\").on(\"click\", function (e) {\r\n                e.preventDefault();\r\n                utils.toggleMenu();\r\n            })\r\n\r\n            //----- enable audio on start -----\r\n            audio.handleMuteButton()\r\n        },\r\n\r\n        lvlComplete: function () {\r\n            audio.bgMusic.pause();\r\n\r\n            var newBgMusic;\r\n\r\n            switch(game.lvl) {\r\n                case 0:\r\n                    audio.enterSound.play();\r\n                    newBgMusic = \"inspiredBySparkMan/sparkBoy.mp3\";\r\n                    break;\r\n                default:\r\n                    audio.exitSound.play();\r\n                    newBgMusic = \"sweetAcoustic.mp3\";\r\n                    break;\r\n            }\r\n\r\n            setTimeout(function () {\r\n                audio.bgMusic = new Audio(\"audio/\" + newBgMusic);\r\n                audio.bgMusic.loop = true;\r\n                audio.bgMusic.volume = 0.45;\r\n\r\n                audio.isOn ?\r\n                    audio.bgMusic.play() :\r\n                    audio.bgMusic.pause();\r\n            }, 1000);\r\n        },\r\n\r\n        play: function (sound, stopPrev) {\r\n            stopPrev = (typeof (stopPrev) !== \"undefined\") ? stopPrev : true;\r\n\r\n            if (sound.ended)\r\n                sound.play();\r\n            else {\r\n                if (stopPrev || sound.currentTime === 0) {\r\n                    sound.pause();\r\n                    sound.currentTime = 0;\r\n                    sound.play();\r\n                }\r\n            }\r\n        },\r\n\r\n        handleMuteButton: function () {\r\n            if ($('.audioState').hasClass('off')) {\r\n                $('.audioState span').removeClass('icon-volume-mute').addClass('icon-volume-medium');\r\n                $('.audioState').removeClass('off');\r\n                $('.audioState').addClass('on');\r\n\r\n                audio.mute(false);\r\n            }\r\n            else {\r\n                $('.audioState span').removeClass('icon-volume-medium').addClass('icon-volume-mute');\r\n                $('.audioState').removeClass('on');\r\n                $('.audioState').addClass('off');\r\n\r\n                audio.mute(true);\r\n            }\r\n        },\r\n\r\n        mute: function (onOrOff) {\r\n            audio.discovery.muted =\r\n            audio.enterSound.muted =\r\n            audio.bgMusic.muted =\r\n            audio.itemPickedUp.muted =\r\n            audio.heartbeat.muted =\r\n            audio.effort.muted = \r\n            audio.thud.muted = \r\n            audio.jump.muted = \r\n            audio.step.muted = \r\n            audio.enemyDeath.muted =\r\n            audio.heroDeath.muted =\r\n            audio.enchant.muted =\r\n            audio.exitSound.muted =\r\n                onOrOff;\r\n\r\n            onOrOff ?\r\n                audio.bgMusic.pause() :\r\n                audio.bgMusic.play();\r\n\r\n            audio.isOn = !onOrOff;\r\n        }\r\n    };\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\n/*\r\n    A library of generic graphics functions.\r\n*/\r\nvar Graphics = (function () {\r\n\r\n    var alpha = 1,\r\n        canvasTransition = null\r\n    ;\r\n\r\n    return {\r\n        ticker: 1,              // 1.0 --> 0.0 --> 1.0 --> ...\r\n        tickerStep: 0.01,\r\n        fadeOut: false,\r\n        projectX: 9,\r\n        projectY: 12,\r\n\r\n\r\n        fadeCanvas: function(callback){\r\n            $(canvas).removeClass(\"preTransition\");\r\n            $(canvas).addClass(\"duringTransition\");\r\n\r\n            canvasTransition = $(canvas).on(\"transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd\", function () {\r\n                canvasTransition.off();\r\n\r\n                $(this).removeClass(\"duringTransition\");\r\n                $(this).addClass(\"preTransition\");\r\n\r\n                callback();\r\n            });\r\n        },\r\n\r\n        blinkText: function (fontSize, x, y, str) {\r\n            str = (typeof (str) !== \"undefined\") ? str : \"PRESS ENTER\";\r\n\r\n            if (Graphics.ticker >= 1.35 || Graphics.ticker <= Graphics.tickerStep) {\r\n                Graphics.fadeOut = !Graphics.fadeOut;\r\n            }\r\n\r\n            if (Graphics.ticker >= 1) {\r\n                alpha = 1;\r\n            }\r\n            else if (Graphics.ticker <= Graphics.tickerStep) {\r\n                alpha = 0;\r\n            }\r\n            else {\r\n                alpha = Graphics.ticker;\r\n            }\r\n\r\n            ctx.font = fontSize + \"px 'Press Start 2P'\";\r\n            var tmpW = ctx.measureText(str).width;\r\n            ctx.fillStyle = \"rgba(233, 233, 233,\" + alpha + ')';\r\n            ctx.fillText(str, x - tmpW / 2, y);\r\n        },\r\n\r\n        /*\r\n            Converts a rectangle into a 'skewed rectangle' polygon\r\n\r\n            @param(number) x\r\n            @param(number) y\r\n            @param(number) w\r\n            @param(number) h\r\n            @return (SAT.Polygon)\r\n        */\r\n        getSkewedRect: function (x, y, w, h) {\r\n            y += Graphics.projectY / 2;\r\n\r\n            var poly = new SAT.Polygon(new SAT.Vector(x, y), [\r\n                new SAT.Vector(),\r\n                new SAT.Vector(w - Graphics.projectX, 0),\r\n                new SAT.Vector(w, Graphics.projectY),\r\n                new SAT.Vector(w, h),\r\n                new SAT.Vector(Graphics.projectX, h),\r\n                new SAT.Vector(0, h - Graphics.projectY)\r\n            ]);\r\n\r\n            //poly = new SAT.Box(new SAT.Vector(x, y), w, h).toPolygon();\r\n            poly.type = JQObject.PLATFORM;  // allows not to be GameObj?????\r\n\r\n            return poly;\r\n        },\r\n\r\n        drawLadder: function (platform) {\r\n            var x = platform.pos.x,\r\n                y = platform.pos.y,\r\n                w = platform.edges[0].x,\r\n                h = platform.edges[1].y\r\n            ;\r\n\r\n            // sides\r\n            ctx.fillStyle = Color.LIGHT_BROWN;\r\n            ctx.fillRect(x, y, 5, h);\r\n            ctx.fillRect(x + w-5, y, 5, h);\r\n\r\n            // rungs\r\n            for (var i = 13; i < h; i+=20) {\r\n                ctx.fillRect(x, y+i, w, 8);\r\n            }\r\n        },\r\n\r\n        drawScale: function (platform) {\r\n            var x = platform.pos.x,\r\n                y = platform.pos.y,\r\n                w = platform.edges[0].x,\r\n                h = platform.edges[1].y\r\n            ;\r\n            \r\n            // draw top border 1px above bounding box\r\n            ctx.fillStyle = Color.BLACK;\r\n            ctx.fillRect(x, y - 1, w, 1);\r\n\r\n            // draw platform\r\n            ctx.fillStyle = Color.DARK_BROWN;\r\n            ctx.fillRect(x, y, w, h);\r\n        },\r\n\r\n        drawPlatform: function (poly) {\r\n            var y = poly.pos.y - Graphics.projectY / 2;\r\n\r\n            // top\r\n            ctx.fillStyle = Color.LIGHT_BROWN;\r\n            ctx.beginPath();\r\n            ctx.moveTo(poly.pos.x, y );\r\n            ctx.lineTo(poly.pos.x + poly.points[1].x, y + poly.points[1].y);\r\n            ctx.lineTo(poly.pos.x + poly.points[2].x, y + poly.points[2].y);\r\n            ctx.lineTo(poly.pos.x + Graphics.projectX, y + Graphics.projectY);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n\r\n            // body\r\n            ctx.fillStyle = Color.DARK_BROWN;\r\n            ctx.beginPath();\r\n            ctx.moveTo(poly.pos.x + poly.points[2].x, y + poly.points[2].y);\r\n            ctx.lineTo(poly.pos.x + poly.points[3].x, y + poly.points[3].y);\r\n            ctx.lineTo(poly.pos.x + poly.points[4].x, y + poly.points[4].y);\r\n            ctx.lineTo(poly.pos.x + poly.points[5].x, y + poly.points[5].y);\r\n            ctx.lineTo(poly.pos.x + poly.points[0].x, y + poly.points[0].y);\r\n            ctx.lineTo(poly.pos.x + Graphics.projectX, y + Graphics.projectY);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n        },\r\n\r\n        drawPlatformStatus: function (platform) {\r\n            var x = platform.pos.x,\r\n                y = platform.pos.y,\r\n                w = platform.w,\r\n                h = platform.h,\r\n                theShape = 26,\r\n                halfTheShape = theShape/2,\r\n                midX = x + w/2 - halfTheShape,\r\n                midY = y + h/2 - halfTheShape\r\n            ;\r\n\r\n            ctx.lineWidth = 3;\r\n\r\n            if (platform.holdingItem === JQObject.CRATE) {\r\n                // draw check mark\r\n                ctx.strokeStyle = \"green\";\r\n\r\n                --midY;\r\n                ctx.beginPath();\r\n                ctx.moveTo(midX, midY + halfTheShape);\r\n                ctx.lineTo(midX + halfTheShape, midY + theShape);\r\n                ctx.moveTo(midX + halfTheShape-1, midY + theShape);\r\n                ctx.lineTo(midX + theShape+2, midY+2);\r\n                ctx.stroke();\r\n                ctx.closePath();\r\n\r\n            }\r\n            else {\r\n                // draw 'X'\r\n                ctx.strokeStyle = \"red\";\r\n\r\n                ctx.beginPath();\r\n                ctx.moveTo(midX, midY);\r\n                ctx.lineTo(midX + theShape, midY + theShape);\r\n                ctx.moveTo(midX, midY + theShape);\r\n                ctx.lineTo(midX + theShape, midY);\r\n                ctx.stroke();\r\n                ctx.closePath();\r\n            }\r\n        },\r\n\r\n        // @param(GameObj) g A game object.\r\n        drawDoor: function (g) {\r\n            // door\r\n            ctx.fillStyle = Color.LIGHT_BROWN;\r\n            ctx.fillRect(g.pos.x + 2, g.pos.y + 2, g.w - 2, g.h - 2);\r\n\r\n            ctx.fillStyle = Color.DARK_BROWN;\r\n\r\n            ctx.fillRect(g.pos.x, g.pos.y, 2, g.h);   // left frame\r\n            ctx.fillRect(g.pos.x, g.pos.y, g.w, 2);   // top frame\r\n            ctx.fillRect(g.pos.x + g.w, g.pos.y, 2, g.h);   // right frame\r\n\r\n            // door handle\r\n            ctx.beginPath();\r\n            ctx.arc(g.pos.x + g.w - (g.w / 3.2), g.pos.y + g.h - (g.h / 3.4), 3, 0, 2 * Math.PI, false);\r\n            ctx.fill();\r\n            ctx.closePath();\r\n\r\n            // door\r\n            ctx.fillStyle = \"#e1e1e1\";\r\n            ctx.font = \"12px 'Press Start 2P'\";\r\n            ctx.fillText(\"EXIT\", g.pos.x - 8, g.pos.y - 5);\r\n\r\n        },\r\n\r\n        drawEllipse: function (x, y, w, h) {\r\n            var kappa = 0.5522848,\r\n\t\t\t\tox = (w / 2) * kappa, // control point offset horizontal\r\n\t\t\t\toy = (h / 2) * kappa, // control point offset vertical\r\n\t\t\t\txe = x + w, // x-end\r\n\t\t\t\tye = y + h, // y-end\r\n\t\t\t\txm = x + w / 2, // x-middle\r\n\t\t\t\tym = y + h / 2 // y-middle\r\n            ;\r\n\r\n            ctx.beginPath();\r\n            ctx.moveTo(x, ym);\r\n            ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\r\n            ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\r\n            ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\r\n            ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n        },\r\n\r\n        drawRotate: function (img, x, y, angle) {\r\n            ctx.save();\r\n\r\n            ctx.translate(x, y);\t\t\t\t\t\t\t\t// move co-ord sys to img origin\r\n            ctx.rotate(utils.degToRad(angle));\r\n            ctx.translate(-img.width * 0.5, -img.height * 0.5); // move to top left of img\r\n\r\n            //ctx.scale(0.75, 0.75);\r\n            ctx.drawImage(img, 0, 0);\r\n\r\n            ctx.restore();\r\n        }\r\n    };\r\n})();\r\n\r\n\r\n/* Images */\r\n//lvl = new Array(NUM_LEVELS),\r\n//lvlBgImg = {}\r\n//function loadBgImages(imgArr, callback) {\r\n//    var count = 0;\r\n\r\n//    for (var key in imgArr) {\r\n//        if (imgArr[key] !== \"none\") {\r\n//            lvlBgImg[key] = new Image();\r\n//            lvlBgImg[key].onload = function () {\r\n//                callback(this.num);\r\n//            };\r\n\r\n//            lvlBgImg[key].src = imgArr[key];\r\n//            lvlBgImg[key].num = count;\r\n//        }\r\n\r\n//        ++count;\r\n//    }\r\n//}\r\n\r\n//for (var i = 0; i < NUM_LEVELS; ++i) {\r\n//    lvl[i] = {\r\n//        status: false,\r\n//        bgColor: '#' + Math.floor(Math.random() * 16777215).toString(16)\r\n//    };\r\n//}\r\n\r\n//loadBgImages({\r\n//    lvl0: \"img/lvl0.jpg\",\r\n//    lvl1: \"none\"\r\n//}, function (num) {\r\n//    lvl[num].status = true;\r\n//});\r\n\r\n\r\n\r\n\r\n//var wasClicked = false;\r\n//$(\".resize\").on(\"click\", function(){\r\n//    if (wasClicked) {\r\n//        $(canvas).css({ width: \"\", height: \"\" });\r\n//        $(this).attr(\"class\", \"resize off\");\r\n//        $(this).children(\"span\").attr(\"class\", \"icon-expand\");\r\n//    }\r\n//    else {\r\n//        $(canvas).css({ width: \"100%\" });\r\n\r\n//        // fix for IE\r\n//        var width = $(canvas).width();\r\n//        $(canvas).css({ height: 0.611 * width });\r\n\r\n\r\n//        $(this).attr(\"class\", \"resize on\");\r\n//        $(this).children(\"span\").attr(\"class\", \"icon-contract\");\r\n//    }\r\n\r\n//    wasClicked = !wasClicked;\r\n//});\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\n/*\r\n    A library of generic physics functions.\r\n*/\r\nvar Physics = (function () {\r\n\r\n\r\n    return {\r\n        // TODO: speed up by checking if a does NOT intersect with b (i.e. using OR)\r\n        // Uses simple Speculative Contacts\r\n        isCollision: function (a, b, moe, isLvl) {\r\n            var aX = (typeof (isLvl) !== \"undefined\") ? a.pos.x + a.lvlX : a.pos.x;\r\n\r\n            if ((aX + moe <= (b.pos.x + b.w)) && // a is to the left of the right side of b\r\n\t\t\t\t(b.pos.x + moe <= (aX + a.w)) && // a is to the right of the left side of b\r\n\t\t\t\t(a.pos.y + moe <= (b.pos.y + b.h)) && // a is higher than the bot of b\r\n\t\t\t\t(b.pos.y + moe <= (a.pos.y + a.h)) \t  // a is lower than the top of b\r\n\t\t\t) {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        },\r\n        \r\n        // Checks for a collision between two polygons (uses SAT and AABB).\r\n        // @param(GameObj) a A game object.\r\n        // @param(GameObj) b A game object.\r\n        // @param(function) callback A function invoked with SAT.Response ONLY IF a collision occurred.\r\n        isSATcollision: function (a, b, callback) {\r\n            var r = new SAT.Response();\r\n            if (SAT.testPolygonPolygon(a, b, r)) {\r\n                callback(r);\r\n            }\r\n        },\r\n\r\n        // Tests collision between gObj and level.objs[]\r\n        // @param(GameObj) gObj A game object\r\n        // @param(function) callback A callback function. Called with a SAT.Response().\r\n        testObjObjs: function (gObj, callback) {\r\n            var response = new SAT.Response();\r\n            for (var i = 0; i < level.objs.length; ++i) {\r\n                if (typeof level.objs[i].collidable === \"undefined\"\r\n                    //&& level.objs[i] !== gObj         // checks if object is in list (by reference)\r\n                ) {\r\n\r\n                    // Check Level Object Collision\r\n                    var collided = SAT.testPolygonPolygon(gObj, level.objs[i], response);\r\n\r\n                    // Respond to Level Object Collision\r\n                    if (collided) {\r\n                        response.a.pos.x -= response.overlapV.x;\r\n                        response.a.pos.y -= response.overlapV.y;\r\n\r\n                        callback(response);\r\n                        break;\r\n                    }\r\n\r\n                    response.clear();\r\n                }\r\n            }\r\n\r\n            // idea to fix \"hooking\" around edges of platform\r\n            // http://stackoverflow.com/a/1355695/353166\r\n        },\r\n\r\n        // Tests collision between item and level.items[]\r\n        // @param(GameItem) item A game item.\r\n        // @param(function) callback A callback function.  Called with a SAT.Response().\r\n        testItemItems: function (item, callback) {\r\n            var response = new SAT.Response();\r\n\r\n            for (var i = 0; i < level.items.length; ++i) {\r\n                if (!level.items[i].holding){\r\n                        \r\n                    if (level.items[i].type !== JQObject.CRATE)       // TODO: allow non-crates\r\n                        continue;\r\n\r\n                    var collided = SAT.testPolygonPolygon(item, level.items[i], response);\r\n                        \r\n                    if (collided) {\r\n                        if (response.overlapN.y === 1) {   // a is on top of b\r\n                            response.a.pos.x -= response.overlapV.x;\r\n                            response.a.pos.y -= response.overlapV.y;\r\n\r\n                            callback(response);\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    response.clear();\r\n                }\r\n            }\r\n        },\r\n\r\n        // Tests collision between hero and the level.items[]\r\n        testHeroItems: function (callback) {\r\n            for (var i = 0; i < level.items.length; ++i) {\r\n                if (level.items[i].visible) {\r\n\r\n                    // TODO: check if player has left item before allowing re-pickup (instad of only checking spacebar) .. wait till hero no longer colliding??\r\n                    if (level.items[i].type === JQObject.CRATE && hero.isCarrying && !(32 in keysDown))\r\n                        continue;\r\n\r\n                    Physics.isSATcollision(hero, level.items[i], function (r) {\r\n                        callback(r, i);\r\n                    });\r\n                }\r\n            }\r\n        },\r\n\r\n        // Tests collision between items\r\n        //testAllItems: function () {\r\n        //    var response = new SAT.Response();\r\n\r\n        //    for (var i = 0; i < level.items.length; ++i) {\r\n        //        for (var j = 0; j < level.items.length; ++j) {\r\n        //            if (i !== j && !level.items[i].holding && !level.items[j].holding) {\r\n                        \r\n        //                if (level.items[i].type !== JQObject.CRATE || level.items[j].type !== JQObject.CRATE)       // TODO: allow non-crates\r\n        //                    continue;\r\n\r\n        //                var collided = SAT.testPolygonPolygon(level.items[i], level.items[j], response);\r\n                        \r\n        //                if (collided) {\r\n        //                    if (response.overlapN.y === 1) {   // a is on top of b\r\n        //                        response.a.pos.x -= response.overlapV.x;\r\n        //                        response.a.pos.y -= response.overlapV.y;\r\n\r\n        //                        response.a.isOnObj = true;\r\n        //                        response.a.onObj = response.b;\r\n        //                        response.b.grabbable = false;\r\n\r\n        //                        level.items.push(response.a);\r\n        //                    }\r\n        //                }\r\n\r\n        //                response.clear();\r\n        //            }\r\n        //        }\r\n        //    }\r\n        //}\r\n    };\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\n/*\r\n    GameObj is the base class from which all objects in the game inherit from.\r\n    Every GameObj has a SAT.Vector (pos);       TODO: make Vector not Polygon\r\n    \r\n    @param(JQObject) type The type of the object.\r\n    @param(number) x The x position of the object.\r\n    @param(number) y The y position of the object.\r\n    @param(number?) w The width of the object.\r\n    @param(number?) h The height of the object.\r\n    @param(Image?) src The filename of the object sprite.  unused by default\r\n    \r\n    @constructor\r\n*/\r\nvar GameObj = function (type, x, y, w, h, src) {\r\n    this.type = type;\r\n\r\n    // set this.pos\r\n    if (type === JQObject.FLOOR) {\r\n        $.extend(this, Graphics.getSkewedRect(x, y, w, h));\r\n        this.type = JQObject.FLOOR; // TODO: fix api here\r\n    }\r\n    else {\r\n        $.extend(this, new SAT.Box(new SAT.Vector(x, y), w, h).toPolygon());\r\n    }\r\n\r\n    this.imgReady = false;     // TODO: make private\r\n\r\n    if (typeof (src) === \"undefined\") {\r\n        this.w = w;\r\n        this.h = h;\r\n    }\r\n    else {\r\n        this.w = 0;\r\n        this.h = 0;\r\n\r\n        this.img = new Image();\r\n\r\n        var that = this;\r\n        this.img.onload = function () {\r\n            that.imgReady = true;\r\n            that.w = this.width;\r\n            that.h = this.height;\r\n        };\r\n\r\n        this.img.src = \"img/\" + src;\r\n    }\r\n};\r\n\r\nGameObj.prototype = {\r\n    draw: function () {\r\n        if (this.imgReady) {\r\n            ctx.drawImage(this.img, this.pos.x, this.pos.y);\r\n        }\r\n        else {\r\n            ctx.fillStyle = \"red\";\r\n            ctx.fillRect(this.pos.x, this.pos.y, this.w, this.h);\r\n        }\r\n    }\r\n};\r\n",
    "/*\r\n    GameItem extends GameObj\r\n    GameItem may extend SAT.Vector to be SAT.Polygon\r\n\r\n    @param(GameObj) gObj A game object.\r\n    @param(?bool) grabbable Whether the game item can be pickup up or not.\r\n    @param(?number) val The value of the game item.\r\n    @param(?bool) visible Whether the game item is displayed or not.\r\n    @param(?bool) sat Whether to setup AABB.\r\n*/\r\nvar GameItem = function (gObj, grabbable, val, visible, sat) {\r\n    utils.extend(this, gObj);\r\n    \r\n    this.grabbable = (typeof (grabbable) !== \"undefined\") ? grabbable : false;\r\n    this.val = (typeof(val) !== \"undefined\") ? val : -1;\r\n    this.visible = (typeof (visible) !== \"undefined\") ? visible : true;\r\n\r\n    this.vY = 0;\r\n    this.isOnObj = false;\r\n    this.onObj = null;         // contains the object holding up the object (directly below)\r\n\r\n    this.holding = false;   // TODO: rename to isBeingCarried\r\n\r\n\r\n    //if (typeof (sat) !== \"undefined\" && sat === true) {\r\n    //    $.extend(true, this, new SAT.Box(this.pos, this.w, this.h).toPolygon());\r\n    //}\r\n\r\n\r\n    // TODO: make private\r\n    var parentDraw = this.draw;\r\n    this.draw = function () {\r\n        if (this.visible) {\r\n            parentDraw.apply(this);\r\n        }\r\n    };\r\n};\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar HUD = (function () {\r\n\r\n    var cash = null,\r\n        medKit = null,\r\n        shuriken = null,\r\n        syringe = null\r\n    ;\r\n\r\n\r\n    function drawHealth(){\r\n        for(var i=0; i < hero.health; ++i){\r\n            ctx.fillStyle = \"red\";\r\n            ctx.fillRect(80 + i*21, FULLH + 14, 19, 8);\r\n        }\r\n    }\r\n\t\r\n    function drawMana(){\r\n        for(var i=0; i < hero.mana; ++i){\r\n            ctx.fillStyle = \"#00b6ff\";\r\n            ctx.fillRect(80 + i*21, FULLH + 37, 19, 8);\r\n        }\r\n    }\r\n\t\r\n    function drawXP() {\r\n        ctx.fillStyle = \"#ddd\";\r\n        ctx.font = \"12px 'Press Start 2P'\";\r\n        \t\r\n        var zero = (hero.xp < 10) ? '0' : '';\r\n        ctx.fillText(zero + hero.xp + '/' + hero.xpNeeded, 80, FULLH + 71);\r\n    }\r\n\r\n\r\n    return {\r\n        init: function () {\r\n            // HUD icons\r\n            cash = new GameObj(JQObject.EMPTY, 548, FULLH + 33, 22, 24, \"cash.png\");\r\n            medKit = new GameObj(JQObject.EMPTY, 238, FULLH + 31, 25, 24, \"medKit.png\");\r\n            shuriken = new GameObj(JQObject.EMPTY, 447, FULLH + 32, 24, 24, \"shuriken.png\");\r\n            syringe = new GameObj(JQObject.EMPTY, 342, FULLH + 31, 25, 25, \"syringe.png\");\r\n        },\r\n\r\n        draw: function () {// TODO: break out static parts\r\n            // background\r\n            ctx.fillStyle = \"#070707\";\r\n            ctx.fillRect(0, FULLH, FULLW, game.padHUD);\r\n\r\n            ctx.fillStyle = \"#ddd\";\r\n            ctx.font = \"12px 'Press Start 2P'\";\r\n\r\n\r\n            ctx.fillText(\"HP-\" + hero.healthLvl, 15, FULLH + 24);\r\n            ctx.fillText(\"MP-\" + hero.manaLvl, 15, FULLH + 48);\r\n            ctx.fillText(\"XP\", 15, FULLH + 71);\r\n            \r\n            drawHealth();\r\n            drawMana();\r\n            drawXP();\r\n\r\n            // hp kit\r\n            ctx.fillText(hero.medKits, 210, FULLH + 50);\r\n            medKit.draw();\r\n\r\n            // mp kit\r\n            ctx.fillText(hero.manaKits, 315, FULLH + 50);\r\n            syringe.draw();\r\n\r\n            // ammo\r\n            ctx.fillText(hero.ammo, 410, FULLH + 50);\r\n            shuriken.draw();\r\n\r\n            // money\r\n            ctx.fillText(hero.cash, 515, FULLH + 50);\r\n            cash.draw();\r\n\r\n            // time\r\n            var time = utils.getTimeObj(game.actualTime);\r\n            ctx.fillText(time.min + ':' + time.sec, FULLW - 84, FULLH + 34);\r\n        }\r\n    };\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar JQEnemy = Object.freeze({\r\n    STILL: 0,\r\n    PATROL: 1,\r\n    FOLLOW: 2\r\n});\r\n\r\n\r\n/*\r\n    Enemy extends GameObj\r\n\r\n    @param(GameObj) gObj A game object (super class).\r\n    @param(number) health The hp of the enemy.\r\n    @param(number) leftXBound The left x coordinate boundary.\r\n    @param(number) rightXBound The right x coordinate boundary.\r\n    @param(EnemyType) enemy_t The type of the enemy.\r\n    @param(bool?) active Is the enemy allowed to move?\r\n    @constructor\r\n*/\r\nvar Enemy = function (gObj, health, leftXBound, rightXBound, enemy_t, active) {\r\n    utils.extend(this, gObj);\r\n\r\n    this.initHealth = this.health = health;\r\n    this.leftXBound = leftXBound;\r\n    this.rightXBound = rightXBound;\r\n    this.enemy_t = enemy_t;\r\n    this.active = (typeof (active) !== \"undefined\") ? active : false;\r\n    this.deadOffScreen = false;\r\n\r\n    // TODO: make private (and initHealth)\r\n    this.dir = Dir.RIGHT;\r\n    this.alive = true;\r\n    this.deadOnScreen = false;\r\n    this.clearDir = true;\t\t// true = right; false = left;\r\n\r\n    // draw\r\n    function drawHealth(that) {\r\n        var healthLen = (that.w / that.initHealth) * that.health;\r\n\r\n        ctx.fillStyle = \"red\";\r\n        ctx.fillRect(that.x, that.y - 12, healthLen, 4);\r\n    }\r\n\r\n    var parentDraw = this.draw;\r\n    this.draw = function () {\r\n        if (this.alive || this.deadOnScreen) {\r\n            if (this.initHealth > 1) {\r\n                drawHealth(this);\r\n            }\r\n\r\n            ctx.save();\r\n            if (this.deadOnScreen) {\r\n                ctx.globalAlpha = 0.3;\r\n            }\r\n\r\n            parentDraw.apply(this);\r\n            ctx.restore();\r\n        }\r\n    }\r\n};\r\n\r\nEnemy.prototype = {\r\n\r\n    update: function () {\r\n        if (this.deadOnScreen) {\r\n            this.pos.x += this.clearDir ? 2 : -2;\r\n            this.pos.y -= 9;\r\n\r\n            if (this.pos.x < 0 || this.pos.x > FULLW) {\r\n                this.deadOnScreen = false;\r\n                this.deadOffScreen = true;\r\n            }\r\n        }\r\n        else if (this.active && game.totalTicks % 3 === 0) {\r\n            this.movement();\r\n        }\r\n    },\r\n\r\n    // TODO: make private\r\n    movement: function() {\r\n        if (this.enemy_t === JQEnemy.PATROL) {\r\n            if (this.pos.x + hero.lvlX <= this.leftXBound)\r\n                this.dir = Dir.RIGHT;\r\n            else if (this.pos.x + hero.lvlX >= this.rightXBound)\r\n                this.dir = Dir.LEFT;\r\n\r\n            if (this.dir === Dir.RIGHT) {\r\n                ++this.pos.x;\r\n            }\r\n            else {\r\n                --this.pos.x;\r\n            }\r\n        }\r\n        else if (this.enemy_t === JQEnemy.FOLLOW) {\r\n            if (this.pos.x < hero.pos.x)\r\n                ++this.pos.x;\r\n            else if (this.pos.x > hero.pos.x)\r\n                --this.pos.x;\r\n        }\r\n    },\r\n\r\n    death: function () {\r\n        this.clearDir = (hero.dir == Dir.RIGHT);\r\n\r\n        audio.enemyDeath.play();\r\n        hero.xp += 15;\r\n        this.alive = false;\r\n        this.deadOnScreen = true;\r\n    }\r\n};",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar level = (function () {\r\n\r\n    var maxVy = 10; // applys to GameObj's and GameItem's\r\n\r\n    /********** Update **********/\r\n    function updateObjsView() {\r\n        for (var i = 0; i < level.objs.length; ++i) {\r\n            level.objs[i].pos.x -= hero.vX;\r\n        }\r\n    }\r\n\r\n    function updateItemsView() {\r\n        for (var i = 0; i < level.items.length; ++i) {\r\n            level.items[i].pos.x -= hero.vX;\r\n        }\r\n    }\r\n\r\n    function updateBgView() {\r\n        // layer 1\r\n        for (var i = 0; i < level.bg[1].length; ++i) {\r\n            level.bg[1][i].pos.x -= hero.vX / 3;\r\n        }\r\n\r\n        // layer 0\r\n        for (var i = 0; i < level.bg[0].length; ++i) {\r\n            level.bg[0][i].pos.x -= hero.vX / 2;\r\n        }\r\n    }\r\n\r\n    function updateItems() {\r\n        for (var i = 0; i < level.items.length; ++i) {\r\n            if (level.items[i].visible && !level.items[i].isOnObj) {\r\n                // gravity/position\r\n                if (level.items[i].vY < maxVy)\r\n                    level.items[i].vY += game.gravity;\r\n                else\r\n                    level.items[i].vY = maxVy;\r\n\r\n                level.items[i].pos.y += level.items[i].vY;\r\n\r\n                // obj collision\r\n                Physics.testObjObjs(level.items[i], function (r) {\r\n                    if (r.overlapN.y === 1) {       // on top\r\n                        r.a.isOnObj = true;\r\n                    }\r\n                });\r\n\r\n                // item collision\r\n                Physics.testItemItems(level.items[i], function (r) {\r\n                    r.a.isOnObj = true;\r\n                    r.a.onObj = r.b;\r\n                    r.b.grabbable = false;\r\n\r\n                    level.items.push(r.a);\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /********** Render **********/\r\n    // the parallax background\r\n    function drawBg() {\r\n        // color background\r\n        ctx.fillStyle = Color.LIGHT_GREEN;\r\n        ctx.fillRect(0, 0, FULLW, FULLH - game.padFloor - 1);\r\n\r\n        ctx.fillStyle = \"#000\";\r\n        ctx.fillRect(0, FULLH - game.padFloor - 1, FULLW, game.padFloor + 1);\r\n\r\n        // layer 1\r\n        for (var i = 0; i < level.bg[1].length; ++i) {\r\n            level.bg[1][i].draw();\r\n        }\r\n\r\n        // layer 0\r\n        for (var i = 0; i < level.bg[0].length; ++i) {\r\n            level.bg[0][i].draw();\r\n        }\r\n    }\r\n\r\n    // all of the collision rectangles in the level\r\n    function drawObjs() {\r\n        for (var i = 0; i < level.objs.length; ++i) {\r\n            // check if visible\r\n            if (typeof (level.objs[i].visible) !== \"undefined\" &&   // TODO: all objs should have visible property (fix api)\r\n                !level.objs[i].visible\r\n            ) {\r\n                continue;\r\n            }\r\n            \r\n            if (level.objs[i].type === JQObject.LADDER) {           // ladder\r\n                Graphics.drawLadder(level.objs[i]);\r\n            }\r\n            else if (level.objs[i].type === JQObject.SCALE) {       // scale\r\n                Graphics.drawScale(level.objs[i]);\r\n                Graphics.drawPlatformStatus(level.objs[i]);\r\n            }\r\n            else if(level.objs[i].type === JQObject.PLATFORM || level.objs[i].type === JQObject.FLOOR) {\r\n                Graphics.drawPlatform(level.objs[i]);\r\n            }\r\n            else if (level.objs[i].type === JQObject.DOOR) {\r\n                Graphics.drawDoor(level.objs[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function drawItems() {\r\n        for (var i = 0; i < level.items.length; ++i) {\r\n            level.items[i].draw();\r\n        }\r\n    }\r\n\r\n    return {\r\n        bg: [   // parallax background; TODO: make one array with variable depth (z dimension) and variable scroll speed per entry\r\n            [], // backgorund obj's 1\r\n            []  // background obj's 2\r\n        ],\r\n        objs: [],           // dynamically holds all of the objects for the level;\r\n        items: [],          // dynamically holds all of the items for the level (movable items)\r\n        curLvl: null,       // alias for the current level object e.g. lvl1\r\n        isCutscene: false,\r\n        time: 0,\r\n        hiddenItemsFound: 0,\r\n        hiddenItems: 0,\r\n        isTransitioning: false,\r\n        \r\n\r\n        init: function () {\r\n            level.curLvl = startScreen;     // startScreen == level '0'\r\n            level.curLvl.init();\r\n            level.reset();\r\n        },\r\n\r\n        // called before start of level\r\n        reset: function () {\r\n            // reset game stats\r\n            game.over = false;\r\n            game.actualTime = 0;\r\n\r\n            // reset level\r\n            level.hiddenItemsFound = 0;\r\n            hero.lvlX = 0;\r\n            level.objs = [];\r\n            level.items = [];\r\n            level.crates = [];\r\n            level.bg = [\r\n                [],\r\n                []\r\n            ];\r\n\r\n            // reset hero\r\n            hero.pos.x = 23;\r\n            hero.pos.y = FULLH - game.padFloor - hero.h + 4;    // TODO: find out '4' offset??\r\n            hero.vX = hero.vY = 0;\r\n            hero.isJumping = false;\r\n            hero.bulletArr.length = 0;\t\t// prevents leftover thrown shurikens\r\n            hero.invincible = false;\r\n            hero.isCarrying = false;\r\n            hero.curItem = null;\r\n            hero.dir = Dir.RIGHT;\r\n            hero.health = hero.maxHealth;\r\n        },\r\n\r\n        // called at end of level\r\n        complete: function () {\r\n            level.isTransitioning = true;\r\n            audio.lvlComplete();\r\n\r\n            // reset graphics timers (to fix blink text)\r\n            Graphics.ticker = 1;\r\n            Graphics.fadeOut = true;\r\n\r\n            Graphics.fadeCanvas(function () {\r\n                level.isTransitioning = false;\r\n\r\n                level.reset();\r\n                level.curLvl = lvlComplete;\r\n                level.isCutscene = true;\r\n                level.time = game.actualTime;\r\n\r\n                // TODO: audio.lvlCompleted.play()\r\n            });\r\n        },\r\n\r\n        /******************** Update ********************/\r\n        update: function () {\r\n            if (!level.isTransitioning) {\r\n                updateItems();\r\n\r\n                level.curLvl.update();\r\n            }\r\n        },\r\n\r\n        // fix positions relative to the \"camera\" view\r\n        updateView: function(){\r\n            updateObjsView();\r\n            updateItemsView();\r\n            updateBgView();\r\n        },\r\n\r\n\r\n        /******************** Render ********************/\r\n        render: function () {\r\n            drawBg();\r\n            drawObjs();\r\n            drawItems();\r\n            \r\n            level.curLvl.render();\r\n        }\r\n    };\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar lvlComplete = (function () {\r\n\r\n    return {\r\n\r\n        update: function () {\r\n            if (KeyCode.ENTER in keysDown || game.lvl === 0 || window.DEBUG) {\r\n                lastKeyDown = KeyCode.EMPTY;\r\n\r\n                switch (++game.lvl) {\r\n                    case 1:\r\n                        lvl1.init();\r\n                        level.curLvl = lvl1;\r\n                        break;\r\n                    case 2:\r\n                        lvl2.init();\r\n                        level.curLvl = lvl2;\r\n                        break;\r\n                }\r\n\r\n                level.isCutscene = false;\r\n                //level.reset();\r\n            }\r\n        },\r\n\r\n        render: function () {\r\n\r\n            // background\r\n            ctx.fillStyle = \"#000\";\r\n            ctx.fillRect(0, 0, FULLW, canvas.height);\r\n\r\n            // title\r\n            ctx.font = \"24px 'Press Start 2P'\";\r\n            var title = \"LEVEL \" + game.lvl + \" COMPLETE\";\r\n            var titleW = ctx.measureText(title).width;\r\n            ctx.fillStyle = Color.ORANGE;\r\n            ctx.fillText(title, HALFW - titleW/2, 70);\r\n            \r\n            // level time\r\n            ctx.font = \"18px 'Press Start 2P'\";\r\n            var time = utils.getTimeObj(level.time);\r\n            var timeTxt = \"LEVEL TIME......\" + time.min + ':' + time.sec;\r\n            var timeW = ctx.measureText(timeTxt).width;\r\n            ctx.fillStyle = \"#e1e1e1\";\r\n            ctx.fillText(timeTxt, HALFW - titleW / 2, 150);\r\n\r\n            // hidden items\r\n            ctx.font = \"18px 'Press Start 2P'\";\r\n            var hdnItems = \"HIDDEN ITEMS.....\" + level.hiddenItemsFound + '/' + level.hiddenItems;\r\n            var hdnItemsW = ctx.measureText(hdnItems).width;\r\n            ctx.fillStyle = \"#e1e1e1\";\r\n            ctx.fillText(hdnItems, HALFW - hdnItemsW / 2, 190);\r\n\r\n\r\n            // cta\r\n            Graphics.blinkText(16, HALFW, HALFH + 120);     // TODO: not working\r\n        }\r\n    };\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\n// level '0'\r\nvar startScreen = (function () {\r\n\r\n    var copyTitle1 = \"JON'S\",\r\n\t\tcopyTitle2 = \"QUEST\",\r\n\t\tcopyLine = String.fromCharCode(\"169\") + \" 2013 JON WIEDMANN\"\r\n    ;\r\n\r\n    return {\r\n        init: function(){\r\n            level.isCutscene = true;\r\n        },\r\n\r\n        update: function(){\r\n            if (lastKeyDown === KeyCode.ENTER) {\r\n                level.complete();\r\n            }\r\n        },\r\n\r\n        render: function(){\r\n            ctx.fillStyle = \"#000\";\r\n            ctx.fillRect(0, 0, FULLW, FULLH + game.padHUD);\r\n\r\n            //---- title\r\n\r\n            // title 1\r\n            ctx.font = \"29px 'Press Start 2P'\";\r\n            var startX = HALFW - ctx.measureText(copyTitle1).width / 2 + 11,\r\n                startY = 58;\r\n\r\n            ctx.setTransform(1, 0, -0.4, 1.4, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('J', startX + 4, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('J', startX, startY);\r\n            ctx.setTransform(1, 0, -0.2, 1.4, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('O', startX + 32, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('O', startX + 28, startY);\r\n            ctx.setTransform(1, 0, 0.05, 1.41, 0, -1);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('N', startX + 58, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('N', startX + 54, startY);\r\n            ctx.setTransform(1, 0, 0.23, 1.4, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText(\"'\", startX + 78, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText(\"'\", startX + 74, startY);\r\n            ctx.setTransform(1, 0, 0.42, 1.4, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('S', startX + 95, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('S', startX + 91, startY);\r\n\r\n\r\n            // title 2\r\n            ctx.font = \"36px 'Press Start 2P'\";\r\n            startX = HALFW - ctx.measureText(copyTitle2).width / 2 + 30;\r\n            startY = 98;\r\n\r\n            ctx.setTransform(1, 0, -0.5, 1.6, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('Q', startX + 4, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('Q', startX, startY);\r\n            ctx.setTransform(1, 0, -0.25, 1.6, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('U', startX + 26, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('U', startX + 22, startY);\r\n            ctx.setTransform(1, 0, 0.03, 1.6, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('E', startX + 50, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('E', startX + 46, startY);\r\n            ctx.setTransform(1, 0, 0.25, 1.6, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('S', startX + 74, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('S', startX + 70, startY);\r\n            ctx.setTransform(1, 0, 0.5, 1.6, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('T', startX + 90, startY + 4);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('T', startX + 86, startY);\r\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\t// reset\r\n\r\n            //---- press enter\r\n            Graphics.blinkText(22, HALFW, HALFH + 81);\r\n\r\n            //---- copyright\r\n            ctx.font = \"13px 'Press Start 2P'\";\r\n            ctx.fillStyle = \"#ddd\";\r\n\r\n            ctx.fillText(copyLine, HALFW - ctx.measureText(copyLine).width / 2, FULLH + 44);\r\n        }\r\n    };\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar lvl1 = (function () {\r\n\r\n    var cyborg,\r\n\t\thiddenCash,\r\n\t\tsack,\r\n\t\tdoor,\r\n        scales = [],\r\n        ladder,\r\n        doLadder = false\r\n    ;\r\n\r\n    function handle_crates_scale_ladder() {\r\n        // all crates on scale\r\n        if (doLadder) {\r\n            hero.onLadder = SAT.testPolygonPolygon(hero, ladder);\r\n        }\r\n        else {\r\n            var numCratesOnScales = 0;\r\n            for (var i = 0; i < level.objs.length; ++i) {\r\n                if (level.objs[i].type === JQObject.SCALE &&\r\n                    typeof (level.objs[i].holdingItem) !== \"undefined\" && level.objs[i].holdingItem === JQObject.CRATE\r\n                ) {\r\n                    ++numCratesOnScales;\r\n                }\r\n            }\r\n\r\n            doLadder = (numCratesOnScales === 3);\r\n\r\n            if (doLadder) {\r\n                var result = $.grep(level.objs, function (e) {\r\n                    return e.type === JQObject.LADDER;\r\n                });\r\n                result[0].visible = true;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function setBackground() {\r\n        var i = 0,\r\n            x1offset = HALFW / 1.2,\r\n            x2offset = HALFW / 2.7,\r\n            x = 60 - x1offset,\r\n            fixY\r\n        ;\r\n\r\n        while (x < lvl1.width) {\r\n            fixY = (++i % 2 == 0) ? 100 : 0;\r\n            x += x1offset;\r\n            level.bg[0].push(new GameObj(JQObject.CLOUD, x, 60 + fixY, 0, 0, \"cloud.png\"));        // TODO: convert api to get w/h\r\n        }\r\n\r\n        x = 0;\r\n        while (x < lvl1.width) {\r\n            if (++i % 2 == 0)\r\n                fixY = 70;\r\n            else if (i % 3 == 0)\r\n                fixY = 140;\r\n            else\r\n                fixY = 10;\r\n\r\n            x += x2offset;\r\n            level.bg[1].push(new GameObj(JQObject.SMALL_CLOUD, x, 100 + fixY, 0, 0, \"cloud_small.png\"));        // TODO: convert api to get w/h\r\n        }\r\n    }\r\n\r\n    function setExit() {\r\n        // stairs\r\n        var stairs = {\r\n                x: 1160,\r\n                y: 210,\r\n                w: 0,\r\n                h: 0\r\n            },\r\n            rise = 5,   // delta h between steps\r\n            run = 17    // delta w between steps\r\n        ;\r\n\r\n        for (var i = 0; i < 15; ++i) {\r\n            level.objs.push(Graphics.getSkewedRect(stairs.x + run * i, stairs.y - rise * i, run + 1, 50));\r\n            stairs.w += run;\r\n            stairs.h += rise;\r\n        }\r\n\r\n        // platform + door\r\n        level.objs.push(Graphics.getSkewedRect(stairs.x + stairs.w, stairs.y - stairs.h, 200, 50));\r\n        door = new GameObj(JQObject.DOOR, stairs.x + stairs.w + 155, stairs.y - stairs.h - 53 + Graphics.projectY/2, 25, 53);\r\n        level.objs.push(door);\r\n\r\n        ladder = new GameItem(new GameObj(JQObject.LADDER, stairs.x - 37, stairs.y - 1, 38, FULLH - stairs.y - game.padFloor), false, 0, false);\r\n        //ladder.collidable = false;      // allows ladder to not be in normal collision detection\r\n        //level.objs.push(ladder);\r\n    }\r\n\r\n    function setCyborg() {\r\n        cyborg = new Enemy(\r\n            new GameObj(JQObject.ENEMY, 1600, FULLH - game.padFloor - 38 + 5, 28, 38, \"cyborgBnW.png\"),\r\n            1,\r\n            1087,\r\n            1600,\r\n            JQEnemy.FOLLOW,\r\n            false\r\n        );\r\n        cyborg.collidable = false;  // TODO: fix api\r        level.objs.push(cyborg);\r\n    }\r\n\r\n    function setItems() {\r        // crates\r        var crate = [];\r        for (var i = 0; i < 3; ++i) {\r\n            crate.push(\r\n                new GameItem(\r\n                    new GameObj(JQObject.CRATE, 246, FULLH - game.padFloor - 26 + 5, 24, 26, \"crate.png\"),      // 446\r\n                    true,\r\n                    0,\r\n                    true\r\n                )\r\n            );\r\n        }\r\n        crate[1].pos.x = 300;//scales[1].pos.x + scales[1].w / 2 - crate[0].w / 2;\r\n        crate[2].pos.x = 350;//scales[2].pos.x + scales[2].w / 2 - crate[0].w / 2;\r\r        // sack\r\n        sack = new GameItem(new GameObj(JQObject.SACK, 680, 111 + Graphics.projectY / 2, 20, 24, \"sack.png\"), false, 5);\r\n\r\n        // hidden cash\r\n        hiddenCash = new GameItem(new GameObj(JQObject.CASH, 113, 80, 22, 24, \"cash.png\"), false, 10, false);\r\n\r\n        level.items.push(crate[0], crate[1], crate[2], sack, hiddenCash);\r\n    }\r\n\r\n\r\n    return {\r\n        width: 2700,\r\n\r\n\r\n        init: function () {\r\n            level.hiddenItems = 1;\r\n\r\n            setBackground();\r\n\r\n            // floor + 3 initial platforms\r\n            level.objs.push(\r\n                new GameObj(JQObject.FLOOR, -Graphics.projectX, FULLH - game.padFloor - 1, lvl1.width + Graphics.projectX * 2, game.padFloor + 1),\r\n                Graphics.getSkewedRect(200, 216, 267, 50),\r\n                Graphics.getSkewedRect(562, 315, 300, 50),\r\n                Graphics.getSkewedRect(585, 135, 220, 50)\r\n            );\r\n\r\n            // scales\r\n            for (var i = 0; i < 3; ++i) {\r\n                scales[i] = new GameObj(JQObject.SCALE, this.width - 330 - i * 230, FULLH - game.padFloor - 107, 150, 36);\r\n                scales[i].holdingItem = JQObject.EMPTY; // TODO: fix api\r\n                level.objs.push(scales[i]);\r\n            }\r            \r            setExit();\r            setCyborg();\r            setItems();\r\n        },\r\n\r\n        deinit: function(){\r\n            cyborg = null;\r\n            hiddenCash = null;\r\n            sack = null;\r\n            door = null;\r\n            scales = [];\r\n            ladder = null;\r\n            doLadder = false;\r\n        },\r\n\r\n        update: function () {\r\n            // TODO: move to better location\r\n            //if (window.DEBUG) {\r\n            //    level.complete();\r\n            //}\r\n\r\n            handle_crates_scale_ladder();\r\n\r\n            // hidden cash\r\n            if (!hiddenCash.visible) {\r\n                for (var i = 0; i < hero.bulletArr.length; ++i) {\r\n                    if (Physics.isCollision(hero.bulletArr[i], hiddenCash, -17)) {\r\n                        hiddenCash.visible = true;\r\n                        audio.discovery.play();\r\n                        ++level.hiddenItemsFound;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // cyborg; TODO: should be a level.enemies[]\r\n            cyborg.update();\r\n\r\n            if (cyborg.health > 0) {\r\n                // hero and cyborg\r\n                if (Physics.isCollision(hero, cyborg, 0)) {\r\n                    cyborg.active = true;\r\n                    \r\n                    if (!hero.invincible) {\r\n                        audio.play(audio.heartbeat, true);\r\n\r\n                        hero.invincible = true;\r\n                        --hero.health;\r\n                    }\r\n                }\r\n\r\n                // bullets and cyborg\r\n                for (var i = 0; i < hero.bulletArr.length; ++i) {\r\n                    var wasCollision = false;\r\n\r\n                    if (Physics.isCollision(hero.bulletArr[i], cyborg, 0)) {\r\n                        wasCollision = true;\r\n                        audio.play(audio.thud, true);\r\n                    }\r\n\r\n                    if (wasCollision) {\r\n                        cyborg.active = true;\r\n\r\n                        hero.bulletArr.splice(i, 1); // remove ith item\r\n                        --cyborg.health;\r\n\r\n                        if (cyborg.health <= 0) {\r\n                            cyborg.death();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // door\r\n            if (!game.over && Physics.isCollision(hero, door, 0)) {     // TODO: why checking game.over???\r\n                level.complete();\r\n            }\r\n        },\r\n\r\n        render: function () {\r\n            if(!cyborg.deadOffScreen)\r\n                cyborg.draw();\r\n        }\r\n    };\r\n\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar lvl2 = (function () {\r\n    var enemy;\r\n\r\n    return {\r\n        width: 800,\r\n\r\n\r\n        init: function () {\r\n            // floor\r\n            var floor1 = new GameObj(\r\n                JQObject.FLOOR,\r\n                -Graphics.projectX,\r\n                FULLH - game.padFloor - 1,\r\n                FULLW / 3,\r\n                game.padFloor + 1\r\n            );\r\n            \r\n            var floor2 = new GameObj(\r\n                JQObject.FLOOR,\r\n                HALFW,\r\n                FULLH - game.padFloor - 1,\r\n                FULLW / 3,\r\n                game.padFloor + 1\r\n            );\r\n\r\n            level.objs.push(floor1, floor2);\r\n\r\n            // enemy\r\n            enemy = new Enemy(\r\n                new GameObj(JQObject.ENEMY, floor2.pos.x, floor2.pos.y - 38, 28, 38, \"cyborgBnW.png\"),\r\n                1,\r\n                floor2.pos.x,\r\n                floor2.pos.x + floor2.w - 28,\r\n                JQEnemy.PATROL,\r\n                true\r\n            );\r\n            enemy.collidable = true;\r\n            level.objs.push(enemy);\r\n        },\r\n\r\n        deinit: function(){\r\n            enemy = null;\r\n        },\r\n\r\n        update: function(){\r\n            enemy.update();\r\n        },\r\n\r\n        render: function () {\r\n            ctx.font = \"18px 'Press Start 2P'\";\r\n            \r\n            var lvlTxt = \"LEVEL 2 -- COMING SOON\";\r\n            var lvlTxtW = ctx.measureText(lvlTxt).width;\r\n            ctx.fillStyle = \"#e1e1e1\";\r\n            ctx.fillText(lvlTxt, HALFW - lvlTxtW / 2, 150);\r\n\r\n\r\n            if (!enemy.deadOffScreen)\r\n                enemy.draw();\r\n        }\r\n    };\r\n})();",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar game = (function () {\r\n\tvar\tavgFPS = 0,\r\n        renderTimePrev = 0,\r\n        renderTimeBtw = 16,\r\n\t\tfpsHistory = [60],\r\n        //updateTimePrev = 0,\r\n        //lag = 0,\r\n        renderLoop,         // used to turn off game\r\n        updateLoop          // used to turn off game\r\n\t;\r\n\t\r\n\tfunction update() {\r\n\t    if (!level.isCutscene && !level.isTransitioning && !game.over) {\r\n\t        hero.update();\r\n\t    }\r\n\r\n\t\tlevel.update();\r\n\t}\r\n\t\r\n\tfunction render(renderTimeCur) {\r\n        // timers\r\n\t    if ((renderTimeCur - renderTimePrev) > 0) {\r\n\t        renderTimeBtw = renderTimeCur - renderTimePrev;\r\n\t    }\r\n\t    renderTimePrev = renderTimeCur;\r\n\r\n\r\n\t    renderLoop = requestAnimFrame(render);\r\n\r\n        \r\n\t    // drawing\r\n\t    level.render();\r\n\r\n\t    if (!level.isCutscene) {\r\n            if(!game.over)\r\n                hero.render();\r\n\r\n\t        HUD.draw();\r\n\t        drawFPS();\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction drawFPS(fps) {\r\n\t    fpsHistory.push(1000 / renderTimeBtw);\r\n\t    \r\n    \tif (game.totalTicks % 120 === 0) {\r\n    \t    var tot = 0,\r\n                i = fpsHistory.length\r\n    \t    ;\r\n    \t    \r\n    \t    while (--i) {\r\n        \t\ttot += fpsHistory[i];\r\n        \t}\r\n    \t    \r\n    \t    if (fpsHistory.length > 0) {\r\n    \t        avgFPS = Math.floor(tot / fpsHistory.length);\r\n    \t    }\r\n    \t    else {\r\n    \t        avgFPS = 0;\r\n    \t    }\r\n\r\n    \t    while (fpsHistory.length > 0) {\r\n    \t        fpsHistory.pop();\r\n    \t    }\r\n        }\r\n    \t\r\n    \tctx.fillStyle = \"#ddd\";\r\n    \tctx.font = \"12px 'Press Start 2P'\";\r\n\t  \tctx.fillText(avgFPS + \" FPS\", FULLW - 84, FULLH + 65);\r\n\t}\r\n   \t\r\n\r\n\treturn {\r\n        over: false,        // indicates the game is finished\r\n\t    gravity: 0.07,\r\n\t    padHUD: 80,\r\n\t    padFloor: 32,\r\n\t    lvl: 0,                 // TODO: make startscreen level 0\r\n\t    totalTicks: 0,          // ticks are update iterations\r\n\t    actualTime: 0,\r\n\r\n\r\n\t    start: function () {\r\n            // update at fixed time interval\r\n\t        updateLoop = setInterval(function () {\r\n\t            ++game.totalTicks;\r\n\t            Graphics.ticker += Graphics.fadeOut ? -Graphics.tickerStep : Graphics.tickerStep;\r\n\r\n\t            //var updateTimeCur = new Date().getTime();\r\n\r\n\t            //if ((updateTimeCur - updateTimePrev) > 0) {\r\n\t                //game.updateTimeBtw = updateTimeCur - updateTimePrev;\r\n\t            //}\r\n\r\n\t            //updateTimePrev = updateTimeCur;\r\n\t            //lag += game.updateTimeBtw;\r\n\t            \r\n\t            //while (lag >= game.updateTimeBtw) {      // TODO: interpolate if needed\r\n\t                update();\r\n\t                //lag -= game.updateTimeBtw;\r\n\t            //}\r\n\t        }, 8.3333); // 1000 / 120 ==> 2x target rate of 60fps\r\n\t        \r\n            // render w/vsync (let browser decide)\r\n\t        render();\r\n\t    },\r\n\r\n\t    stop: function () {\r\n\t        window.cancelAnimationFrame(renderLoop);\r\n\t        clearInterval(updateLoop);\r\n\t    }\r\n\t};\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\n/*\r\n    The hero object.\r\n*/\r\nvar hero = (function () {\r\n    var input = null,           // the hero input component\r\n        graphics = null,        // the hero graphics component\r\n        imgReady = false,       \r\n\t\timg = null,             // TODO: convert to be of GameObj type\r\n        idleTime = 0,\r\n\t\tspriteArr = [],\r\n\t\tinvincibleTimer = 170,\r\n        invincibleTimer0 = 170  // TODO: should be const\r\n\t;\r\n\t\r\n\t\t\r\n\t/*********************** Update ***********************/\r\n    function checkHealth() {\r\n        if (hero.invincible)\r\n            --invincibleTimer;\r\n\r\n        if (invincibleTimer <= 0) {\r\n            hero.invincible = false;\r\n            invincibleTimer = invincibleTimer0;\r\n        }\r\n        \r\n        if (hero.health <= 0 && !game.over) {\r\n            utils.deathSequence();\r\n        }\r\n    }\r\n\r\n    function getSpritePos() {\r\n\t\tvar pos = {x: 0, y: 0};\r\n\t\t\r\n\t\tif(hero.isCarrying && hero.vX === 0){\r\n\t\t\tpos = spriteArr[\"playerDown\"];\r\n\t\t}\r\n\t\telse if (hero.onLadder) {               // TODO: check if holding crate (shouldn't be allowed on ladder)\r\n\t\t    pos = spriteArr[\"playerUp\"];\r\n\t\t}\r\n\t\telse if (hero.dir === Dir.RIGHT || hero.dir === Dir.LEFT) {\r\n\t\t    var dirR = (hero.dir === Dir.RIGHT);\r\n\t\t    var theDir = \"player\" + (dirR ? \"Right\" : \"Left\");\r\n\r\n\t\t    if (dirR && hero.vX > 0 ||  // right\r\n\t\t        !dirR && hero.vX < 0    // left\r\n            ) {\r\n\t\t        var runTimer = (game.totalTicks % 60);\r\n\r\n\t\t        if(!hero.isOnObj){\r\n\t\t            pos = spriteArr[theDir + \"_Run1\"];\r\n\t\t        }\r\n                else if(Math.abs(hero.vX) <= hero.aX*10){\r\n\t\t            pos = spriteArr[theDir + \"_Step\"];\r\n\t\t        }\r\n\t\t        else if(runTimer >= 0 && runTimer < 20) {\r\n\t\t            pos = spriteArr[theDir + \"_Run1\"];\r\n\t\t        }\r\n\t\t        else if (runTimer >= 20 && runTimer < 40) {\r\n\t\t            pos = spriteArr[theDir + \"_Run2\"];\r\n\t\t        }\r\n\t\t        else {\r\n\t\t            pos = spriteArr[theDir + \"_Run3\"];\r\n\t\t        }\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tpos = spriteArr[theDir];\r\n\t\t}\r\n\t\t\r\n        // idle animation\r\n\t\tif (!hero.onLadder && hero.vX === 0 && hero.vY === 0)\r\n\t\t    ++idleTime;\r\n\t\telse\r\n\t\t    idleTime = 0;\r\n\r\n\t\tif (idleTime > 210) {\r\n\t\t    var foo = idleTime % 200;\r\n\t\t    \r\n\t\t    if (foo >= 0 && foo <= 50 || foo > 100 && foo <= 150 || hero.isCarrying)\r\n\t\t        pos = spriteArr[\"playerDown\"];\r\n\t\t    else if (foo > 50  && foo <= 100)\r\n\t\t        pos = spriteArr[\"playerDown_breatheIn\"];\r\n\t\t    else if (foo > 150 && foo <= 200)\r\n\t\t        pos = spriteArr[\"playerDown_breatheOut\"];\r\n\t\t}\r\n\r\n        // invincible\r\n\t\tvar inv = invincibleTimer % 40;\r\n\t\t\r\n\t\tif(hero.invincible && (inv >= 0 && inv <= 16)){\r\n\t\t\tpos = {x: -1, y: -1};\r\n\t\t}\r\n\r\n\t\t\r\n\t\thero.sx = pos.x;\r\n\t\thero.sy = pos.y;\r\n\t}\r\n\t\r\n\t/*********************** Render ***********************/\r\n\tfunction drawHero(){\r\n\t\tif(imgReady && hero.sx >= 0 && hero.sy >= 0){\r\n\t\t    ctx.drawImage(img, hero.sx, hero.sy, hero.w, hero.h, hero.pos.x, hero.pos.y, hero.w, hero.h);\r\n    \t}\r\n\t}\r\n\t\t\r\n    // used to draw things over the hero\r\n\tfunction drawAfterHero() {\r\n\t    if (hero.isCarrying){\r\n\t        hero.curItem.draw();\r\n\t    }\r\n\t}\r\n\t\t\r\n\treturn {\r\n\t\tsx: 0,\t\t\t\t// sprite position\r\n\t\tsy: 0,\r\n\t\tlvlX: 0,\t\t\t\r\n\t\tw: 28,\r\n\t\th: 38,\r\n\t\tvX: 0,          // maxVx/y are in heroInput.js\r\n\t\tvY: 0,\r\n\t\taX: 0.17,\r\n\t\taY: 0.52,\r\n\t\tjumpMod: 4,\r\n\t\tjumpMod0: 4,            // TODO: should be const\r\n\t\tdir: Dir.RIGHT,\r\n\t\tisJumping: false,\r\n\t\tisCarrying: false,\r\n        onLadder: false,\r\n        curItem: null,          // the item in hand\r\n\t\tisOnObj: true,\r\n\t\tinvincible: false,\r\n\t\thealth: 3,\r\n\t\tmaxHealth: 3,\r\n\t\tmedKits: 1,\r\n\t\thealthLvl: 1,\r\n\t\tmana: 0,\r\n\t\tmaxMana: 4,\r\n\t\tmanaKits: 1,\r\n\t\tmanaLvl: 1,\r\n\t\tammo: 20,\r\n\t\tcash: 0,\r\n\t\tlvl: 1,\r\n\t\txp: 0,\r\n\t\txpNeeded: 50,\r\n\t\tbulletArr: [],\r\n\t\tphysics: null,         // the hero physics component\r\n\t\t\r\n\r\n\t\tinit: function(){\r\n\t\t\timg = new Image();\r\n\t\t\timg.onload = function () { imgReady = true; };\r\n\t\t\timg.src = \"../dungeon/web/img/sprites/player/player.png\";\r\n\t\t\t\r\n\t\t\t// grab texturePacker's sprite coords\r\n\t\t\t$.get(\"../dungeon/web/img/sprites/player/player.xml\", function(xml){\r\n\t\t\t\tvar wrap = $(xml).find(\"sprite\");\r\n\t\t\t\t\r\n\t\t\t\t$(wrap).each(function(){\r\n\t\t\t\t\tvar name = $(this).attr('n'),\r\n\t\t\t\t\t\tx = $(this).attr('x'),\r\n\t\t\t\t\t\ty = $(this).attr('y');\r\n\t\t\t\t\t\r\n\t\t\t\t\tname = name.substring(0, name.length-4);\r\n\t\t\t\t\tspriteArr[name] = {x: x, y: y};\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tinput = HeroInputComponent();\r\n\t\t\tinput.init();\r\n\r\n\t\t\thero.physics = HeroPhysicsComponent();\r\n\r\n\t\t\tgraphics = HeroGraphicsComponent();\r\n\t\t\tgraphics.init();\r\n\r\n            // setup hero bounding box for collision detection\r\n\t\t\t$.extend(hero, new SAT.Box(new SAT.Vector(0, 0), hero.w, hero.h).toPolygon());\r\n\t\t},\r\n\t\t\r\n\t\tupdate: function () {\r\n\t\t    input.check();                          // updates velocities\r\n\t\t\thero.physics.updatePosition();          // updates positions\r\n\t\t\thero.physics.checkCollision();          // fix positions\r\n\t\t\t\r\n\t\t\tcheckHealth();\r\n\t\t\tgetSpritePos();\r\n\t\t},\r\n\t\r\n\t\trender: function () {\r\n\t\t    drawHero();\r\n\t\t    graphics.drawBullets();\r\n\t\t    drawAfterHero();\r\n\t\t}\r\n\t};\r\n})();\r\n",
    "/*\r\n    The graphics component of hero.\r\n*/\r\nvar HeroGraphicsComponent = function () {\r\n\r\n    var shuriken = null,\r\n        shurikenReady = false\r\n    ;\r\n\r\n    return {\r\n        init: function(){\r\n            shuriken = new Image();\r\n            shuriken.src = \"img/shuriken.png\";\r\n            shuriken.onload = function () { shurikenReady = true; };\r\n        },\r\n\r\n        drawBullets: function(){\r\n\t\t    for(var i=0; i < hero.bulletArr.length; ++i){\r\n\t\t        var dirOffset = hero.bulletArr[i].dirR ?\r\n    \t\t\t\t\t\t\t    hero.w : \r\n    \t\t\t\t\t\t\t    0;\r\n\t            \r\n\t\t        hero.bulletArr[i].deg += 5;\r\n            \r\n\t\t        Graphics.drawRotate(\r\n            \t    shuriken, \r\n            \t    hero.bulletArr[i].pos.x + dirOffset,\r\n            \t    hero.bulletArr[i].pos.y + 20,\r\n        \t \t    hero.bulletArr[i].deg\r\n    \t \t    );\r\n\t\t    }\r\n        }\r\n    };\r\n};\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\n/*\r\n    The physics component of hero.\r\n*/\r\nvar HeroPhysicsComponent = function () {\r\n\r\n    function bulletHandler() {\r\n        for (var i = 0; i < hero.bulletArr.length; ++i) {\r\n            hero.bulletArr[i].pos.x += hero.bulletArr[i].dirR ? bullet.speed : -bullet.speed;   // update position\r\n\r\n            if (hero.bulletArr[i].pos.x > FULLW || hero.bulletArr[i].pos.x < 0) {\t\t    // bullet and screen\r\n                hero.bulletArr.splice(i, 1); // remove ith item\r\n            }\r\n        }\r\n    }\r\n\r\n    function screenCollision() {\r\n        if (hero.pos.y < -hero.h) {                 // feet above top of screen\r\n            hero.pos.y = -hero.h;\r\n            hero.vY = 0;\r\n        }\r\n        else if (hero.pos.y >= FULLH) {\r\n            if (!game.over) {\r\n                utils.deathSequence();\r\n            }\r\n        }\r\n\r\n        if (hero.pos.x < 0) { \t\t\t\t\t\t// left\r\n            hero.pos.x = 0;\r\n            hero.vX = 0;\r\n        }\r\n        else if (hero.pos.x > (FULLW - hero.w)) { \t// right \r\n            hero.pos.x = FULLW - hero.w;\r\n            hero.vX = 0;\r\n        }\r\n    }\r\n\r\n    function levelCollision() {\r\n        hero.isOnObj = false;   // prevents jumping after walking off platform\r\n\r\n        Physics.testObjObjs(hero, function (r) {\r\n            if (r.overlapN.y === 1) {                       // on top\r\n                hero.isOnObj = true;\r\n                hero.isJumping = false;\r\n                hero.vY = 0;\r\n            }\r\n            else if (r.overlapN.y === -1) {                 // on bot\r\n                hero.vY = 0;\r\n            }\r\n        });\r\n        \r\n        if (hero.isCarrying) {\r\n            if (hero.vX === 0) {\r\n                hero.curItem.pos.x = hero.pos.x + 2;\r\n                hero.curItem.pos.y = hero.pos.y + 11;\r\n            }\r\n            else {\r\n                hero.curItem.pos.x = hero.pos.x + ((hero.dir === Dir.RIGHT) ? 22 : -22);\r\n                hero.curItem.pos.y = hero.pos.y + 5;\r\n            }\r\n        }\r\n\r\n        Physics.testHeroItems(function (r, idx) {\r\n            if (r.b.type === JQObject.CRATE) {      // TODO: make more generic\r\n                if (r.overlapN.y === 1) {           // on top\r\n                    hero.pos.y -= r.overlapV.y;\r\n                    hero.isOnObj = true;\r\n                    hero.isJumping = false;\r\n                    hero.vY = 0;\r\n                }\r\n                else if (r.b.grabbable) {\r\n                    if (r.b.isOnObj === true) {\r\n                        r.b.isOnObj = false;\r\n\r\n                        if (r.b.onObj !== null) {\r\n                            r.b.onObj.grabbable = true;\r\n                            r.b.onObj = null;\r\n                        }\r\n                    }\r\n\r\n                    r.b.holding = true;\r\n\r\n                    hero.curItem = r.b;\r\n                    hero.isCarrying = true;\r\n\r\n                    level.items.splice(idx, 1);\r\n                }\r\n            }\r\n            else {\r\n                audio.itemPickedUp.play();\r\n\r\n                if (r.b.type === JQObject.SACK) {\r\n                    hero.ammo += r.b.val;\r\n                }\r\n                else if (r.b.type === JQObject.CASH) {\r\n                    hero.cash += r.b.val;\r\n                }\r\n\r\n                level.items.splice(idx, 1);\r\n            }\r\n        });\r\n    }\r\n\r\n    return {\r\n        updatePosition: function (){\t\r\n            if (!hero.isJumping && !hero.onLadder && hero.pos.x !== (hero.pos.x + hero.vX)) {\r\n                audio.step.play();\r\n            }\r\n\r\n            // TODO: buggy at edges, quickly changin direction incorrectly causes an updateView()\r\n            \r\n            if(((hero.dir === Dir.RIGHT && hero.pos.x >= (HALFW + 35)) ||\r\n               (hero.dir === Dir.LEFT && hero.pos.x <= (HALFW - 45))) &&\r\n               (hero.lvlX + hero.vX >= 0) &&\r\n               (hero.lvlX + hero.vX <= level.curLvl.width - FULLW)\r\n            ){\r\n                hero.lvlX += hero.vX;\r\n                level.updateView();\r\n            }\r\n            else {\r\n                hero.pos.x += hero.vX;\r\n            }\r\n\r\n            if (!hero.onLadder) {\r\n                hero.pos.y += hero.vY;\r\n            }\r\n        },\r\n\r\n        checkCollision: function () {\r\n\t        bulletHandler();\t\t// bullet's and screen\r\n            screenCollision();\t    // hero and screen\r\n            levelCollision();\r\n        }\r\n    };\r\n};\r\n",
    "/// <reference path=\"hero.js\" />\r\n/// <reference path=\"heroGraphics.js\" />\r\n/// <reference path=\"heroPhysics.js\" />\r\n/// <reference path=\"../physics/physics.js\" />\r\n\r\n/*\r\n    The input component of hero.\r\n*/\r\nvar HeroInputComponent = function () {\r\n\r\n    var maxVx = 2.6,       // TODO: should be const\r\n        maxVy = 10         // TODO: should be const\r\n    ;\r\n\r\n\r\n    return {\r\n        init: function () {\r\n            // global key vars\r\n\t        keysDown = {};\r\n            lastKeyDown = -1;\r\n\r\n            $(document).on(\"click\", \".resize\", function () {\r\n                if ($(this).hasClass(\"off\")) {\r\n                    $(this).removeClass(\"off\").addClass(\"on\");\r\n                    $(this).children(\"span\").removeClass(\"icon-expand\").addClass(\"icon-contract\");\r\n                }\r\n                else if ($(this).hasClass(\"on\")) {\r\n                    $(this).removeClass(\"on\").addClass(\"off\");\r\n                    $(this).children(\"span\").removeClass(\"icon-contract\").addClass(\"icon-expand\");\r\n                }\r\n\r\n                utils.toggleFullScreen();\r\n            });\r\n\r\n            addEventListener(\"keydown\", function (e) {\r\n\r\n                if (e.keyCode == 32)\r\n                    e.preventDefault(); \t\t\t//----- space bar (scrolling to bottom of page)\r\n                else if (e.keyCode == 77)\t\t\t//----- mute/unmute (m)\r\n                    audio.handleMuteButton();\r\n                else if(e.keyCode == 70)            //----- resize (f)\r\n                    $(\".resize\").trigger(\"click\");\r\n                else if (e.keyCode == 75 &&\t\t\t//----- jump (k);       TODO: move to check() function\r\n                       (!hero.isJumping && ((lastKeyDown != 75) || !(75 in keysDown))) &&\r\n                       hero.isOnObj\r\n                ) {\r\n                    audio.jump.play();\r\n                    hero.vY = 0;\r\n                    hero.isJumping = true;\r\n                    hero.isOnObj = false;\r\n                }\r\n                else if (e.keyCode == 74 &&\t\t//----- shoot (j);          TODO: move to check() function\r\n                        ((lastKeyDown != 74) || !(74 in keysDown))\r\n                ) {\r\n                    if (hero.ammo > 0 && !hero.isCarrying) {\r\n                        audio.play(audio.effort);\r\n\r\n                        hero.bulletArr[hero.bulletArr.length] = {\r\n                            pos: {\r\n                                x: hero.pos.x,\r\n                                y: hero.pos.y\r\n                            },\r\n                            w: bullet.w,\r\n                            h: bullet.h,\r\n                            dirR: (hero.dir === Dir.RIGHT),\r\n                            deg: 0\r\n                        };\r\n\r\n                        --hero.ammo;\r\n                    }\r\n                }\r\n                else if (e.keyCode == KeyCode.O) {      //----- options (o)\r\n                    utils.toggleMenu();\r\n                }\r\n\r\n                lastKeyDown = e.keyCode;\r\n                keysDown[e.keyCode] = true;\r\n            }, false);\r\n\t\r\n            addEventListener(\"keyup\", function (e) { delete keysDown[e.keyCode];}, false);\r\n        },\r\n\r\n        check: function () {\r\n            var doGravity = false;\r\n\r\n            if (hero.isJumping) {\r\n                if (hero.jumpMod > 0) {\r\n                    hero.vY -= hero.aY * hero.jumpMod--;\r\n                }\r\n                else {\r\n                    doGravity = true;\r\n                }\r\n            }\r\n            else {\r\n                hero.jumpMod = hero.jumpMod0;\r\n                doGravity = true;\r\n            }\r\n\r\n\r\n            if (doGravity && !hero.onLadder) {\r\n                var fixVy = hero.vY + game.gravity*2;\r\n\r\n                if (fixVy > maxVy) {\r\n                    hero.vY = maxVy;\r\n                }\r\n                else {\r\n                    hero.vY = fixVy;\r\n                }\r\n            }\r\n\r\n\r\n            // --------- keys pressed --------\r\n            var leftOrRight = false;\r\n            //----- left (a)\r\n            if(65 in keysDown){\r\n                hero.vX = (Math.abs(hero.vX - hero.aX) > maxVx) ? -maxVx : (hero.vX - hero.aX);\r\n                hero.dir = Dir.LEFT;\r\n                leftOrRight = true;\r\n            }\r\n\r\n\t\t\r\n            //----- right (d)\r\n            if (68 in keysDown) {\r\n                hero.vX = (Math.abs(hero.vX + hero.aX) > maxVx) ? maxVx : (hero.vX + hero.aX);\r\n                hero.dir = Dir.RIGHT;\r\n                leftOrRight = true;\r\n            }\r\n\t    \r\n            if(Math.abs(hero.vX) < hero.aX){    \r\n                hero.vX = 0;\r\n            }\r\n            else if(!leftOrRight){\r\n                //hero.vX += (hero.vX > 0) ? -game.friction : game.friction;\r\n                hero.vX /= 1.26;\r\n            }\r\n\t    \r\n\r\n            //----- up (w)\r\n            if (KeyCode.W in keysDown) {\r\n                if (hero.onLadder) {\r\n                    --hero.pos.y;\r\n                }\r\n            }\r\n\r\n            //----- down (s)\r\n            if (KeyCode.S in keysDown) {\r\n                if (hero.onLadder) {\r\n                    ++hero.pos.y;\r\n                }\r\n            }\r\n\r\n\t    \r\n            //----- drop object (spacebar)\r\n            if (32 in keysDown) {\r\n                if (hero.isCarrying) {\r\n                    hero.isCarrying = false;\r\n                    hero.curItem.holding = false;\r\n                    level.items.push(hero.curItem);\r\n                    hero.curItem = null;\r\n                }\r\n            }\r\n\r\n\t\t\r\n            //----- heal (h)\r\n            if(72 in keysDown){\r\n                if(hero.medKits > 0 && hero.health < hero.maxHealth){\r\n                    ++hero.health;\r\n                    --hero.medKits;\r\n\r\n                    audio.play(audio.enchant, true);\r\n                }\r\n            }\r\n\t\t\r\n\t\t\r\n            //----- restore (r)\r\n            if(82 in keysDown && !(17 in keysDown)){\t// 17 = ctrl\r\n                if(hero.manaKits > 0 && hero.mana < hero.maxMana){\r\n                    ++hero.mana;\r\n                    --hero.manaKits;\r\n\r\n                    audio.play(audio.enchant, true);\r\n                }\r\n            }\r\n\t\t\r\n        }\r\n    };\r\n};\r\n",
    "/// <reference path=\"linker.js\" />\r\n\r\nvar Main = (function () {\r\n\r\n    function setCanvasGlobals() {\r\n        canvas = $(\"canvas\")[0];\r\n        ctx = canvas.getContext(\"2d\");\r\n        \r\n        FULLW = canvas.width;\r\n        FULLH = canvas.height - game.padHUD;\r\n        HALFW = FULLW / 2;\r\n        HALFH = FULLH / 2;\r\n    }\r\n\r\n    function loadingScreen() {\r\n        ctx.fillStyle = \"#e1e1e1\";\r\n        ctx.font = \"25px 'Press Start 2P'\";\r\n        ctx.fillText(\"LOADING...\", HALFW - 80, HALFH + 20);\r\n    }\r\n\r\n    function debug() {\r\n        // dev enviroment\r\n        if (location.host === \"jon\") {\r\n            //window.DEBUG = true;\r\n\r\n            // skip start screen\r\n            lastKeyDown = KeyCode.ENTER;\r\n\r\n            // mute audio\r\n            audio.handleMuteButton();\r\n        }\r\n    }\r\n\r\n\r\n    return {\r\n        init: function () {\r\n            setCanvasGlobals();\r\n            loadingScreen();\r\n\r\n            hero.init();\r\n            audio.init();\r\n            level.init();\r\n            HUD.init();\r\n\r\n            // wait for google font\r\n            $(document).on(\"fontLoaded\", function () {\r\n\r\n                // game timer\r\n                setInterval(function () {\r\n                    ++game.actualTime;\r\n                }, 1000);\r\n\r\n                // start the game\r\n                //startScreen.start();\r\n                game.start();\r\n            });\r\n                \r\n\r\n            debug();\r\n        }\r\n    }\r\n})();\r\n\r\n$(function () {\r\n    // load font\r\n    window.WebFontConfig = {\r\n        google: {\r\n            families: ['Press Start 2P']\r\n        },\r\n        active: function () {\r\n            $(document).trigger(\"fontLoaded\");\r\n        },\r\n        inactive: function () {\r\n            alert(\"There was a problem loading a font from google, some text may not render correctly (refreshing the page may fix the issue).\");\r\n            $(document).trigger(\"fontLoaded\");\r\n        }\r\n    };\r\n\r\n    (function () {\r\n        var wf = document.createElement(\"script\");\r\n        wf.src = \"//ajax.googleapis.com/ajax/libs/webfont/1/webfont.js\";\r\n        wf.type = \"text/javascript\";\r\n        wf.async = \"true\";\r\n        var s = document.getElementsByTagName(\"script\")[0];\r\n        s.parentNode.insertBefore(wf, s);\r\n    })();\r\n\r\n\r\n    Main.init();\r\n});\r\n"
  ]
}