{
  "version": 3,
  "file": "pageJonsQuest.js",
  "sources": [
    "js/plugins/jquery.colorbox-min.js",
    "games/jonsQuest/js/physics/SAT.js",
    "games/jonsQuest/js/utils.js",
    "games/jonsQuest/js/audio/audio.js",
    "games/jonsQuest/js/graphics/graphics.js",
    "games/jonsQuest/js/physics/physics.js",
    "games/jonsQuest/js/engine/gameObject.js",
    "games/jonsQuest/js/engine/gameItem.js",
    "games/jonsQuest/js/engine/hud.js",
    "games/jonsQuest/js/enemy/enemy.js",
    "games/jonsQuest/js/level/level.js",
    "games/jonsQuest/js/level/lvlComplete.js",
    "games/jonsQuest/js/level/startScreen.js",
    "games/jonsQuest/js/level/level1.js",
    "games/jonsQuest/js/level/level2.js",
    "games/jonsQuest/js/engine/game.js",
    "games/jonsQuest/js/hero/hero.js",
    "games/jonsQuest/js/hero/heroGraphics.js",
    "games/jonsQuest/js/hero/heroPhysics.js",
    "games/jonsQuest/js/hero/heroInput.js",
    "games/jonsQuest/js/main.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA,ipV;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,I;ACrzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AChSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC9eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACrUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACvOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACxNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A",
  "sourcesContent": [
    "/*!\n\tColorbox v1.4.33 - 2013-10-31\n\tjQuery lightbox and modal window plugin\n\t(c) 2013 Jack Moore - http://www.jacklmoore.com/colorbox\n\tlicense: http://www.opensource.org/licenses/mit-license.php\n*/\n(function(e,t,i){function o(i,o,n){var r=t.createElement(i);return o&&(r.id=Z+o),n&&(r.style.cssText=n),e(r)}function n(){return i.innerHeight?i.innerHeight:e(i).height()}function r(e){var t=k.length,i=(z+e)%t;return 0>i?t+i:i}function h(e,t){return Math.round((/%/.test(e)?(\"x\"===t?E.width():n())/100:1)*parseInt(e,10))}function l(e,t){return e.photo||e.photoRegex.test(t)}function s(e,t){return e.retinaUrl&&i.devicePixelRatio>1?t.replace(e.photoRegex,e.retinaSuffix):t}function a(e){\"contains\"in g[0]&&!g[0].contains(e.target)&&(e.stopPropagation(),g.focus())}function d(){var t,i=e.data(N,Y);null==i?(B=e.extend({},X),console&&console.log&&console.log(\"Error: cboxElement missing settings object\")):B=e.extend({},i);for(t in B)e.isFunction(B[t])&&\"on\"!==t.slice(0,2)&&(B[t]=B[t].call(N));B.rel=B.rel||N.rel||e(N).data(\"rel\")||\"nofollow\",B.href=B.href||e(N).attr(\"href\"),B.title=B.title||N.title,\"string\"==typeof B.href&&(B.href=e.trim(B.href))}function c(i,o){e(t).trigger(i),lt.triggerHandler(i),e.isFunction(o)&&o.call(N)}function u(i){q||(N=i,d(),k=e(N),z=0,\"nofollow\"!==B.rel&&(k=e(\".\"+et).filter(function(){var t,i=e.data(this,Y);return i&&(t=e(this).data(\"rel\")||i.rel||this.rel),t===B.rel}),z=k.index(N),-1===z&&(k=k.add(N),z=k.length-1)),w.css({opacity:parseFloat(B.opacity),cursor:B.overlayClose?\"pointer\":\"auto\",visibility:\"visible\"}).show(),J&&g.add(w).removeClass(J),B.className&&g.add(w).addClass(B.className),J=B.className,B.closeButton?K.html(B.close).appendTo(y):K.appendTo(\"<div/>\"),U||(U=$=!0,g.css({visibility:\"hidden\",display:\"block\"}),H=o(st,\"LoadedContent\",\"width:0; height:0; overflow:hidden\"),y.css({width:\"\",height:\"\"}).append(H),O=x.height()+C.height()+y.outerHeight(!0)-y.height(),_=b.width()+T.width()+y.outerWidth(!0)-y.width(),D=H.outerHeight(!0),A=H.outerWidth(!0),B.w=h(B.initialWidth,\"x\"),B.h=h(B.initialHeight,\"y\"),H.css({width:\"\",height:B.h}),Q.position(),c(tt,B.onOpen),P.add(L).hide(),g.focus(),B.trapFocus&&t.addEventListener&&(t.addEventListener(\"focus\",a,!0),lt.one(rt,function(){t.removeEventListener(\"focus\",a,!0)})),B.returnFocus&&lt.one(rt,function(){e(N).focus()})),m())}function f(){!g&&t.body&&(V=!1,E=e(i),g=o(st).attr({id:Y,\"class\":e.support.opacity===!1?Z+\"IE\":\"\",role:\"dialog\",tabindex:\"-1\"}).hide(),w=o(st,\"Overlay\").hide(),F=e([o(st,\"LoadingOverlay\")[0],o(st,\"LoadingGraphic\")[0]]),v=o(st,\"Wrapper\"),y=o(st,\"Content\").append(L=o(st,\"Title\"),S=o(st,\"Current\"),I=e('<button type=\"button\"/>').attr({id:Z+\"Previous\"}),R=e('<button type=\"button\"/>').attr({id:Z+\"Next\"}),M=o(\"button\",\"Slideshow\"),F),K=e('<button type=\"button\"/>').attr({id:Z+\"Close\"}),v.append(o(st).append(o(st,\"TopLeft\"),x=o(st,\"TopCenter\"),o(st,\"TopRight\")),o(st,!1,\"clear:left\").append(b=o(st,\"MiddleLeft\"),y,T=o(st,\"MiddleRight\")),o(st,!1,\"clear:left\").append(o(st,\"BottomLeft\"),C=o(st,\"BottomCenter\"),o(st,\"BottomRight\"))).find(\"div div\").css({\"float\":\"left\"}),W=o(st,!1,\"position:absolute; width:9999px; visibility:hidden; display:none; max-width:none;\"),P=R.add(I).add(S).add(M),e(t.body).append(w,g.append(v,W)))}function p(){function i(e){e.which>1||e.shiftKey||e.altKey||e.metaKey||e.ctrlKey||(e.preventDefault(),u(this))}return g?(V||(V=!0,R.click(function(){Q.next()}),I.click(function(){Q.prev()}),K.click(function(){Q.close()}),w.click(function(){B.overlayClose&&Q.close()}),e(t).bind(\"keydown.\"+Z,function(e){var t=e.keyCode;U&&B.escKey&&27===t&&(e.preventDefault(),Q.close()),U&&B.arrowKey&&k[1]&&!e.altKey&&(37===t?(e.preventDefault(),I.click()):39===t&&(e.preventDefault(),R.click()))}),e.isFunction(e.fn.on)?e(t).on(\"click.\"+Z,\".\"+et,i):e(\".\"+et).live(\"click.\"+Z,i)),!0):!1}function m(){var n,r,a,u=Q.prep,f=++at;$=!0,j=!1,N=k[z],d(),c(ht),c(it,B.onLoad),B.h=B.height?h(B.height,\"y\")-D-O:B.innerHeight&&h(B.innerHeight,\"y\"),B.w=B.width?h(B.width,\"x\")-A-_:B.innerWidth&&h(B.innerWidth,\"x\"),B.mw=B.w,B.mh=B.h,B.maxWidth&&(B.mw=h(B.maxWidth,\"x\")-A-_,B.mw=B.w&&B.w<B.mw?B.w:B.mw),B.maxHeight&&(B.mh=h(B.maxHeight,\"y\")-D-O,B.mh=B.h&&B.h<B.mh?B.h:B.mh),n=B.href,G=setTimeout(function(){F.show()},100),B.inline?(a=o(st).hide().insertBefore(e(n)[0]),lt.one(ht,function(){a.replaceWith(H.children())}),u(e(n))):B.iframe?u(\" \"):B.html?u(B.html):l(B,n)?(n=s(B,n),j=t.createElement(\"img\"),e(j).addClass(Z+\"Photo\").bind(\"error\",function(){B.title=!1,u(o(st,\"Error\").html(B.imgError))}).one(\"load\",function(){var t;f===at&&(e.each([\"alt\",\"longdesc\",\"aria-describedby\"],function(t,i){var o=e(N).attr(i)||e(N).attr(\"data-\"+i);o&&j.setAttribute(i,o)}),B.retinaImage&&i.devicePixelRatio>1&&(j.height=j.height/i.devicePixelRatio,j.width=j.width/i.devicePixelRatio),B.scalePhotos&&(r=function(){j.height-=j.height*t,j.width-=j.width*t},B.mw&&j.width>B.mw&&(t=(j.width-B.mw)/j.width,r()),B.mh&&j.height>B.mh&&(t=(j.height-B.mh)/j.height,r())),B.h&&(j.style.marginTop=Math.max(B.mh-j.height,0)/2+\"px\"),k[1]&&(B.loop||k[z+1])&&(j.style.cursor=\"pointer\",j.onclick=function(){Q.next()}),j.style.width=j.width+\"px\",j.style.height=j.height+\"px\",setTimeout(function(){u(j)},1))}),setTimeout(function(){j.src=n},1)):n&&W.load(n,B.data,function(t,i){f===at&&u(\"error\"===i?o(st,\"Error\").html(B.xhrError):e(this).contents())})}var w,g,v,y,x,b,T,C,k,E,H,W,F,L,S,M,R,I,K,P,B,O,_,D,A,N,z,j,U,$,q,G,Q,J,V,X={html:!1,photo:!1,iframe:!1,inline:!1,transition:\"elastic\",speed:300,fadeOut:300,width:!1,initialWidth:\"600\",innerWidth:!1,maxWidth:!1,height:!1,initialHeight:\"450\",innerHeight:!1,maxHeight:!1,scalePhotos:!0,scrolling:!0,href:!1,title:!1,rel:!1,opacity:.9,preloading:!0,className:!1,overlayClose:!0,escKey:!0,arrowKey:!0,top:!1,bottom:!1,left:!1,right:!1,fixed:!1,data:void 0,closeButton:!0,fastIframe:!0,open:!1,reposition:!0,loop:!0,slideshow:!1,slideshowAuto:!0,slideshowSpeed:2500,slideshowStart:\"start slideshow\",slideshowStop:\"stop slideshow\",photoRegex:/\\.(gif|png|jp(e|g|eg)|bmp|ico|webp)((#|\\?).*)?$/i,retinaImage:!1,retinaUrl:!1,retinaSuffix:\"@2x.$1\",current:\"image {current} of {total}\",previous:\"previous\",next:\"next\",close:\"close\",xhrError:\"This content failed to load.\",imgError:\"This image failed to load.\",returnFocus:!0,trapFocus:!0,onOpen:!1,onLoad:!1,onComplete:!1,onCleanup:!1,onClosed:!1},Y=\"colorbox\",Z=\"cbox\",et=Z+\"Element\",tt=Z+\"_open\",it=Z+\"_load\",ot=Z+\"_complete\",nt=Z+\"_cleanup\",rt=Z+\"_closed\",ht=Z+\"_purge\",lt=e(\"<a/>\"),st=\"div\",at=0,dt={},ct=function(){function e(){clearTimeout(h)}function t(){(B.loop||k[z+1])&&(e(),h=setTimeout(Q.next,B.slideshowSpeed))}function i(){M.html(B.slideshowStop).unbind(s).one(s,o),lt.bind(ot,t).bind(it,e),g.removeClass(l+\"off\").addClass(l+\"on\")}function o(){e(),lt.unbind(ot,t).unbind(it,e),M.html(B.slideshowStart).unbind(s).one(s,function(){Q.next(),i()}),g.removeClass(l+\"on\").addClass(l+\"off\")}function n(){r=!1,M.hide(),e(),lt.unbind(ot,t).unbind(it,e),g.removeClass(l+\"off \"+l+\"on\")}var r,h,l=Z+\"Slideshow_\",s=\"click.\"+Z;return function(){r?B.slideshow||(lt.unbind(nt,n),n()):B.slideshow&&k[1]&&(r=!0,lt.one(nt,n),B.slideshowAuto?i():o(),M.show())}}();e.colorbox||(e(f),Q=e.fn[Y]=e[Y]=function(t,i){var o=this;if(t=t||{},f(),p()){if(e.isFunction(o))o=e(\"<a/>\"),t.open=!0;else if(!o[0])return o;i&&(t.onComplete=i),o.each(function(){e.data(this,Y,e.extend({},e.data(this,Y)||X,t))}).addClass(et),(e.isFunction(t.open)&&t.open.call(o)||t.open)&&u(o[0])}return o},Q.position=function(t,i){function o(){x[0].style.width=C[0].style.width=y[0].style.width=parseInt(g[0].style.width,10)-_+\"px\",y[0].style.height=b[0].style.height=T[0].style.height=parseInt(g[0].style.height,10)-O+\"px\"}var r,l,s,a=0,d=0,c=g.offset();if(E.unbind(\"resize.\"+Z),g.css({top:-9e4,left:-9e4}),l=E.scrollTop(),s=E.scrollLeft(),B.fixed?(c.top-=l,c.left-=s,g.css({position:\"fixed\"})):(a=l,d=s,g.css({position:\"absolute\"})),d+=B.right!==!1?Math.max(E.width()-B.w-A-_-h(B.right,\"x\"),0):B.left!==!1?h(B.left,\"x\"):Math.round(Math.max(E.width()-B.w-A-_,0)/2),a+=B.bottom!==!1?Math.max(n()-B.h-D-O-h(B.bottom,\"y\"),0):B.top!==!1?h(B.top,\"y\"):Math.round(Math.max(n()-B.h-D-O,0)/2),g.css({top:c.top,left:c.left,visibility:\"visible\"}),v[0].style.width=v[0].style.height=\"9999px\",r={width:B.w+A+_,height:B.h+D+O,top:a,left:d},t){var u=0;e.each(r,function(e){return r[e]!==dt[e]?(u=t,void 0):void 0}),t=u}dt=r,t||g.css(r),g.dequeue().animate(r,{duration:t||0,complete:function(){o(),$=!1,v[0].style.width=B.w+A+_+\"px\",v[0].style.height=B.h+D+O+\"px\",B.reposition&&setTimeout(function(){E.bind(\"resize.\"+Z,Q.position)},1),i&&i()},step:o})},Q.resize=function(e){var t;U&&(e=e||{},e.width&&(B.w=h(e.width,\"x\")-A-_),e.innerWidth&&(B.w=h(e.innerWidth,\"x\")),H.css({width:B.w}),e.height&&(B.h=h(e.height,\"y\")-D-O),e.innerHeight&&(B.h=h(e.innerHeight,\"y\")),e.innerHeight||e.height||(t=H.scrollTop(),H.css({height:\"auto\"}),B.h=H.height()),H.css({height:B.h}),t&&H.scrollTop(t),Q.position(\"none\"===B.transition?0:B.speed))},Q.prep=function(i){function n(){return B.w=B.w||H.width(),B.w=B.mw&&B.mw<B.w?B.mw:B.w,B.w}function h(){return B.h=B.h||H.height(),B.h=B.mh&&B.mh<B.h?B.mh:B.h,B.h}if(U){var a,d=\"none\"===B.transition?0:B.speed;H.empty().remove(),H=o(st,\"LoadedContent\").append(i),H.hide().appendTo(W.show()).css({width:n(),overflow:B.scrolling?\"auto\":\"hidden\"}).css({height:h()}).prependTo(y),W.hide(),e(j).css({\"float\":\"none\"}),a=function(){function i(){e.support.opacity===!1&&g[0].style.removeAttribute(\"filter\")}var n,h,a=k.length,u=\"frameBorder\",f=\"allowTransparency\";U&&(h=function(){clearTimeout(G),F.hide(),c(ot,B.onComplete)},L.html(B.title).add(H).show(),a>1?(\"string\"==typeof B.current&&S.html(B.current.replace(\"{current}\",z+1).replace(\"{total}\",a)).show(),R[B.loop||a-1>z?\"show\":\"hide\"]().html(B.next),I[B.loop||z?\"show\":\"hide\"]().html(B.previous),ct(),B.preloading&&e.each([r(-1),r(1)],function(){var i,o,n=k[this],r=e.data(n,Y);r&&r.href?(i=r.href,e.isFunction(i)&&(i=i.call(n))):i=e(n).attr(\"href\"),i&&l(r,i)&&(i=s(r,i),o=t.createElement(\"img\"),o.src=i)})):P.hide(),B.iframe?(n=o(\"iframe\")[0],u in n&&(n[u]=0),f in n&&(n[f]=\"true\"),B.scrolling||(n.scrolling=\"no\"),e(n).attr({src:B.href,name:(new Date).getTime(),\"class\":Z+\"Iframe\",allowFullScreen:!0,webkitAllowFullScreen:!0,mozallowfullscreen:!0}).one(\"load\",h).appendTo(H),lt.one(ht,function(){n.src=\"//about:blank\"}),B.fastIframe&&e(n).trigger(\"load\")):h(),\"fade\"===B.transition?g.fadeTo(d,1,i):i())},\"fade\"===B.transition?g.fadeTo(d,0,function(){Q.position(0,a)}):Q.position(d,a)}},Q.next=function(){!$&&k[1]&&(B.loop||k[z+1])&&(z=r(1),u(k[z]))},Q.prev=function(){!$&&k[1]&&(B.loop||z)&&(z=r(-1),u(k[z]))},Q.close=function(){U&&!q&&(q=!0,U=!1,c(nt,B.onCleanup),E.unbind(\".\"+Z),w.fadeTo(B.fadeOut||0,0),g.stop().fadeTo(B.fadeOut||0,0,function(){g.add(w).css({opacity:1,cursor:\"auto\"}).hide(),c(ht),H.empty().remove(),setTimeout(function(){q=!1,c(rt,B.onClosed)},1)}))},Q.remove=function(){g&&(g.stop(),e.colorbox.close(),g.stop().remove(),w.remove(),q=!1,g=null,e(\".\"+et).removeData(Y).removeClass(et),e(t).unbind(\"click.\"+Z))},Q.element=function(){return e(N)},Q.settings=X)})(jQuery,document,window);",
    "// Version 0.2 - Copyright 2013 -  Jim Riecken <jimr@jimr.ca>\n//\n// Released under the MIT License - https://github.com/jriecken/sat-js\n//\n// A simple library for determining intersections of circles and\n// polygons using the Separating Axis Theorem.\n/** @preserve SAT.js - Version 0.2 - Copyright 2013 - Jim Riecken <jimr@jimr.ca> - released under the MIT License. https://github.com/jriecken/sat-js */\n\n/*global define: false, module: false*/\n/*jshint shadow:true, sub:true, forin:true, noarg:true, noempty:true, \n  eqeqeq:true, bitwise:true, strict:true, undef:true, \n  curly:true, browser:true */\n\n// Create a UMD wrapper for SAT. Works in:\n//\n//  - Plain browser via global SAT variable\n//  - AMD loader (like require.js)\n//  - Node.js\n//\n// The quoted properties all over the place are used so that the Closure Compiler\n// does not mangle the exposed API in advanced mode.\n/**\n * @param {*} root - The global scope\n * @param {Function} factory - Factory that creates SAT module\n */\n(function (root, factory) {\n  \"use strict\";\n  if (typeof define === 'function' && define['amd']) {\n    define(factory);\n  } else if (typeof exports === 'object') {\n    module['exports'] = factory();\n  } else {\n    root['SAT'] = factory();\n  }\n}(this, function () {\n  \"use strict\";\n\n  var SAT = {};\n\n  //\n  // ## Vector\n  //\n  // Represents a vector in two dimensions with `x` and `y` properties.\n\n\n  // Create a new Vector, optionally passing in the `x` and `y` coordinates. If\n  // a coordinate is not specified, it will be set to `0`\n  /** \n   * @param {?number=} x The x position.\n   * @param {?number=} y The y position.\n   * @constructor\n   */\n  function Vector(x, y) {\n    this['x'] = x || 0;\n    this['y'] = y || 0;\n  }\n  SAT['Vector'] = Vector;\n  // Alias `Vector` as `V`\n  SAT['V'] = Vector;\n\n\n  // Copy the values of another Vector into this one.\n  /**\n   * @param {Vector} other The other Vector.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['copy'] = Vector.prototype.copy = function(other) {\n    this['x'] = other['x'];\n    this['y'] = other['y'];\n    return this;\n  };\n\n  // Change this vector to be perpendicular to what it was before. (Effectively\n  // roatates it 90 degrees in a clockwise direction)\n  /**\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['perp'] = Vector.prototype.perp = function() {\n    var x = this['x'];\n    this['x'] = this['y'];\n    this['y'] = -x;\n    return this;\n  };\n\n  // Rotate this vector (counter-clockwise) by the specified angle (in radians).\n  /**\n   * @param {number} angle The angle to rotate (in radians)\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['rotate'] = Vector.prototype.rotate = function (angle) {\n    var x = this['x'];\n    var y = this['y'];\n    this['x'] = x * Math.cos(angle) - y * Math.sin(angle);\n    this['y'] = x * Math.sin(angle) + y * Math.cos(angle);\n    return this;\n  };\n\n  // Reverse this vector.\n  /**\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['reverse'] = Vector.prototype.reverse = function() {\n    this['x'] = -this['x'];\n    this['y'] = -this['y'];\n    return this;\n  };\n  \n\n  // Normalize this vector.  (make it have length of `1`)\n  /**\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['normalize'] = Vector.prototype.normalize = function() {\n    var d = this.len();\n    if(d > 0) {\n      this['x'] = this['x'] / d;\n      this['y'] = this['y'] / d;\n    }\n    return this;\n  };\n  \n  // Add another vector to this one.\n  /**\n   * @param {Vector} other The other Vector.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['add'] = Vector.prototype.add = function(other) {\n    this['x'] += other['x'];\n    this['y'] += other['y'];\n    return this;\n  };\n  \n  // Subtract another vector from this one.\n  /**\n   * @param {Vector} other The other Vector.\n   * @return {Vector} This for chaiing.\n   */\n  Vector.prototype['sub'] = Vector.prototype.sub = function(other) {\n    this['x'] -= other['x'];\n    this['y'] -= other['y'];\n    return this;\n  };\n  \n  // Scale this vector. An independant scaling factor can be provided\n  // for each axis, or a single scaling factor that will scale both `x` and `y`.\n  /**\n   * @param {number} x The scaling factor in the x direction.\n   * @param {?number=} y The scaling factor in the y direction.  If this\n   *   is not specified, the x scaling factor will be used.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['scale'] = Vector.prototype.scale = function(x,y) {\n    this['x'] *= x;\n    this['y'] *= y || x;\n    return this; \n  };\n  \n  // Project this vector on to another vector.\n  /**\n   * @param {Vector} other The vector to project onto.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['project'] = Vector.prototype.project = function(other) {\n    var amt = this.dot(other) / other.len2();\n    this['x'] = amt * other['x'];\n    this['y'] = amt * other['y'];\n    return this;\n  };\n  \n  // Project this vector onto a vector of unit length. This is slightly more efficient\n  // than `project` when dealing with unit vectors.\n  /**\n   * @param {Vector} other The unit vector to project onto.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['projectN'] = Vector.prototype.projectN = function(other) {\n    var amt = this.dot(other);\n    this['x'] = amt * other['x'];\n    this['y'] = amt * other['y'];\n    return this;\n  };\n  \n  // Reflect this vector on an arbitrary axis.\n  /**\n   * @param {Vector} axis The vector representing the axis.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['reflect'] = Vector.prototype.reflect = function(axis) {\n    var x = this['x'];\n    var y = this['y'];\n    this.project(axis).scale(2);\n    this['x'] -= x;\n    this['y'] -= y;\n    return this;\n  };\n  \n  // Reflect this vector on an arbitrary axis (represented by a unit vector). This is\n  // slightly more efficient than `reflect` when dealing with an axis that is a unit vector.\n  /**\n   * @param {Vector} axis The unit vector representing the axis.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['reflectN'] = Vector.prototype.reflectN = function(axis) {\n    var x = this['x'];\n    var y = this['y'];\n    this.projectN(axis).scale(2);\n    this['x'] -= x;\n    this['y'] -= y;\n    return this;\n  };\n  \n  // Get the dot product of this vector and another.\n  /**\n   * @param {Vector}  other The vector to dot this one against.\n   * @return {number} The dot product.\n   */\n  Vector.prototype['dot'] = Vector.prototype.dot = function(other) {\n    return this['x'] * other['x'] + this['y'] * other['y'];\n  };\n  \n  // Get the squared length of this vector.\n  /**\n   * @return {number} The length^2 of this vector.\n   */\n  Vector.prototype['len2'] = Vector.prototype.len2 = function() {\n    return this.dot(this);\n  };\n  \n  // Get the length of this vector.\n  /**\n   * @return {number} The length of this vector.\n   */\n  Vector.prototype['len'] = Vector.prototype.len = function() {\n    return Math.sqrt(this.len2());\n  };\n  \n  // ## Circle\n  //\n  // Represents a circle with a position and a radius.\n\n  // Create a new circle, optionally passing in a position and/or radius. If no position\n  // is given, the circle will be at `(0,0)`. If no radius is provided, the circle will\n  // have a radius of `0`.\n  /**\n   * @param {Vector=} pos A vector representing the position of the center of the circle\n   * @param {?number=} r The radius of the circle\n   * @constructor\n   */\n  function Circle(pos, r) {\n    this['pos'] = pos || new Vector();\n    this['r'] = r || 0;\n  }\n  SAT['Circle'] = Circle;\n\n  // ## Polygon\n  //\n  // Represents a *convex* polygon with any number of points (specified in counter-clockwise order)\n  //\n  // The edges/normals of the polygon will be calculated on creation and stored in the\n  // `edges` and `normals` properties. If you change the polygon's points, you will need\n  // to call `recalc` to recalculate the edges/normals.\n\n  // Create a new polygon, passing in a position vector, and an array of points (represented\n  // by vectors relative to the position vector). If no position is passed in, the position\n  // of the polygon will be `(0,0)`.\n  /**\n   * @param {Vector=} pos A vector representing the origin of the polygon. (all other\n   *   points are relative to this one)\n   * @param {Array.<Vector>=} points An array of vectors representing the points in the polygon,\n   *   in counter-clockwise order.\n   * @constructor\n   */\n  function Polygon(pos, points) {\n    this['pos'] = pos || new Vector();\n    this['points'] = points || [];\n    this.recalc();\n  }\n  SAT['Polygon'] = Polygon;\n  \n  // Recalculates the edges and normals of the polygon. This **must** be called\n  // if the `points` array is modified at all and the edges or normals are to be\n  // accessed.\n  /**\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['recalc'] = Polygon.prototype.recalc = function() {\n    // The edges here are the direction of the `n`th edge of the polygon, relative to\n    // the `n`th point. If you want to draw a given edge from the edge value, you must\n    // first translate to the position of the starting point.\n    this['edges'] = [];\n    // The normals here are the direction of the normal for the `n`th edge of the polygon, relative\n    // to the position of the `n`th point. If you want to draw an edge normal, you must first\n    // translate to the position of the starting point.\n    this['normals'] = [];\n    var points = this['points'];\n    var len = points.length;\n    for (var i = 0; i < len; i++) {\n      var p1 = points[i]; \n      var p2 = i < len - 1 ? points[i + 1] : points[0];\n      var e = new Vector().copy(p2).sub(p1);\n      var n = new Vector().copy(e).perp().normalize();\n      this['edges'].push(e);\n      this['normals'].push(n);\n    }\n    return this;\n  };\n\n  // Rotates this polygon counter-clockwise around the origin of *its local coordinate system* (i.e. `pos`).\n  //\n  // Note: You do **not** need to call `recalc` after rotation.\n  /**\n   * @param {number} angle The angle to rotate (in radians)\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['rotate'] = Polygon.prototype.rotate = function(angle) {\n    var i;\n    var points = this['points'];\n    var edges = this['edges'];\n    var normals = this['normals'];\n    var len = points.length;\n    for (i = 0; i < len; i++) {\n      points[i].rotate(angle);\n      edges[i].rotate(angle);\n      normals[i].rotate(angle);\n    }\n    return this;\n  };\n\n  // Translates the points of this polygon by a specified amount relative to the origin of *its own coordinate\n  // system* (i.e. `pos`).\n  //\n  // This is most useful to change the \"center point\" of a polygon.\n  //\n  // Note: You do **not** need to call `recalc` after translation.\n  /**\n   * @param {number} x The horizontal amount to translate.\n   * @param {number} y The vertical amount to translate.\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['translate'] = Polygon.prototype.translate = function (x, y) {\n    var i;\n    var points = this['points'];\n    var len = points.length;\n    for (i = 0; i < len; i++) {\n      points[i].x += x;\n      points[i].y += y;\n    }\n    return this;\n  };\n\n  // ## Box\n  //\n  // Represents an axis-aligned box, with a width and height.\n\n\n  // Create a new box, with the specified position, width, and height. If no position\n  // is given, the position will be `(0,0)`. If no width or height are given, they will\n  // be set to `0`.\n  /**\n   * @param {Vector=} pos A vector representing the top-left of the box.\n   * @param {?number=} w The width of the box.\n   * @param {?number=} h The height of the box.\n   * @constructor\n   */\n  function Box(pos, w, h) {\n    this['pos'] = pos || new Vector();\n    this['w'] = w || 0;\n    this['h'] = h || 0;\n  }\n  SAT['Box'] = Box;\n\n  // Returns a polygon whose edges are the same as this box.\n  /**\n   * @return {Polygon} A new Polygon that represents this box.\n   */\n  Box.prototype['toPolygon'] = Box.prototype.toPolygon = function() {\n    var pos = this['pos'];\n    var w = this['w'];\n    var h = this['h'];\n    return new Polygon(new Vector(pos['x'], pos['y']), [\n     new Vector(), new Vector(w, 0), \n     new Vector(w,h), new Vector(0,h)\n    ]);\n  };\n  \n  // ## Response\n  //\n  // An object representing the result of an intersection. Contains:\n  //  - The two objects participating in the intersection\n  //  - The vector representing the minimum change necessary to extract the first object\n  //    from the second one (as well as a unit vector in that direction and the magnitude\n  //    of the overlap)\n  //  - Whether the first object is entirely inside the second, and vice versa.\n  /**\n   * @constructor\n   */  \n  function Response() {\n    this['a'] = null;\n    this['b'] = null;\n    this['overlapN'] = new Vector();\n    this['overlapV'] = new Vector();\n    this.clear();\n  }\n  SAT['Response'] = Response;\n\n  // Set some values of the response back to their defaults.  Call this between tests if\n  // you are going to reuse a single Response object for multiple intersection tests (recommented\n  // as it will avoid allcating extra memory)\n  /**\n   * @return {Response} This for chaining\n   */\n  Response.prototype['clear'] = Response.prototype.clear = function() {\n    this['aInB'] = true;\n    this['bInA'] = true;\n    this['overlap'] = Number.MAX_VALUE;\n    return this;\n  };\n\n  // ## Object Pools\n\n  // A pool of `Vector` objects that are used in calculations to avoid\n  // allocating memory.\n  /**\n   * @type {Array.<Vector>}\n   */\n  var T_VECTORS = [];\n  for (var i = 0; i < 10; i++) { T_VECTORS.push(new Vector()); }\n  \n  // A pool of arrays of numbers used in calculations to avoid allocating\n  // memory.\n  /**\n   * @type {Array.<Array.<number>>}\n   */\n  var T_ARRAYS = [];\n  for (var i = 0; i < 5; i++) { T_ARRAYS.push([]); }\n\n  // ## Helper Functions\n\n  // Flattens the specified array of points onto a unit vector axis,\n  // resulting in a one dimensional range of the minimum and\n  // maximum value on that axis.\n  /**\n   * @param {Array.<Vector>} points The points to flatten.\n   * @param {Vector} normal The unit vector axis to flatten on.\n   * @param {Array.<number>} result An array.  After calling this function,\n   *   result[0] will be the minimum value,\n   *   result[1] will be the maximum value.\n   */\n  function flattenPointsOn(points, normal, result) {\n    var min = Number.MAX_VALUE;\n    var max = -Number.MAX_VALUE;\n    var len = points.length;\n    for (var i = 0; i < len; i++ ) {\n      // The magnitude of the projection of the point onto the normal\n      var dot = points[i].dot(normal);\n      if (dot < min) { min = dot; }\n      if (dot > max) { max = dot; }\n    }\n    result[0] = min; result[1] = max;\n  }\n  \n  // Check whether two convex polygons are separated by the specified\n  // axis (must be a unit vector).\n  /**\n   * @param {Vector} aPos The position of the first polygon.\n   * @param {Vector} bPos The position of the second polygon.\n   * @param {Array.<Vector>} aPoints The points in the first polygon.\n   * @param {Array.<Vector>} bPoints The points in the second polygon.\n   * @param {Vector} axis The axis (unit sized) to test against.  The points of both polygons\n   *   will be projected onto this axis.\n   * @param {Response=} response A Response object (optional) which will be populated\n   *   if the axis is not a separating axis.\n   * @return {boolean} true if it is a separating axis, false otherwise.  If false,\n   *   and a response is passed in, information about how much overlap and\n   *   the direction of the overlap will be populated.\n   */\n  function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {\n    var rangeA = T_ARRAYS.pop();\n    var rangeB = T_ARRAYS.pop();\n    // The magnitude of the offset between the two polygons\n    var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);\n    var projectedOffset = offsetV.dot(axis);\n    // Project the polygons onto the axis.\n    flattenPointsOn(aPoints, axis, rangeA);\n    flattenPointsOn(bPoints, axis, rangeB);\n    // Move B's range to its position relative to A.\n    rangeB[0] += projectedOffset;\n    rangeB[1] += projectedOffset;\n    // Check if there is a gap. If there is, this is a separating axis and we can stop\n    if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {\n      T_VECTORS.push(offsetV); \n      T_ARRAYS.push(rangeA); \n      T_ARRAYS.push(rangeB);\n      return true;\n    }\n    // This is not a separating axis. If we're calculating a response, calculate the overlap.\n    if (response) {\n      var overlap = 0;\n      // A starts further left than B\n      if (rangeA[0] < rangeB[0]) {\n        response['aInB'] = false;\n        // A ends before B does. We have to pull A out of B\n        if (rangeA[1] < rangeB[1]) { \n          overlap = rangeA[1] - rangeB[0];\n          response['bInA'] = false;\n        // B is fully inside A.  Pick the shortest way out.\n        } else {\n          var option1 = rangeA[1] - rangeB[0];\n          var option2 = rangeB[1] - rangeA[0];\n          overlap = option1 < option2 ? option1 : -option2;\n        }\n      // B starts further left than A\n      } else {\n        response['bInA'] = false;\n        // B ends before A ends. We have to push A out of B\n        if (rangeA[1] > rangeB[1]) { \n          overlap = rangeA[0] - rangeB[1];\n          response['aInB'] = false;\n        // A is fully inside B.  Pick the shortest way out.\n        } else {\n          var option1 = rangeA[1] - rangeB[0];\n          var option2 = rangeB[1] - rangeA[0];\n          overlap = option1 < option2 ? option1 : -option2;\n        }\n      }\n      // If this is the smallest amount of overlap we've seen so far, set it as the minimum overlap.\n      var absOverlap = Math.abs(overlap);\n      if (absOverlap < response['overlap']) {\n        response['overlap'] = absOverlap;\n        response['overlapN'].copy(axis);\n        if (overlap < 0) {\n          response['overlapN'].reverse();\n        }\n      }      \n    }\n    T_VECTORS.push(offsetV); \n    T_ARRAYS.push(rangeA); \n    T_ARRAYS.push(rangeB);\n    return false;\n  }\n  \n  // Calculates which Vornoi region a point is on a line segment.\n  // It is assumed that both the line and the point are relative to `(0,0)`\n  //\n  //            |       (0)      |\n  //     (-1)  [S]--------------[E]  (1)\n  //            |       (0)      |\n  /**\n   * @param {Vector} line The line segment.\n   * @param {Vector} point The point.\n   * @return  {number} LEFT_VORNOI_REGION (-1) if it is the left region, \n   *          MIDDLE_VORNOI_REGION (0) if it is the middle region, \n   *          RIGHT_VORNOI_REGION (1) if it is the right region.\n   */\n  function vornoiRegion(line, point) {\n    var len2 = line.len2();\n    var dp = point.dot(line);\n    // If the point is beyond the start of the line, it is in the\n    // left vornoi region.\n    if (dp < 0) { return LEFT_VORNOI_REGION; }\n    // If the point is beyond the end of the line, it is in the\n    // right vornoi region.\n    else if (dp > len2) { return RIGHT_VORNOI_REGION; }\n    // Otherwise, it's in the middle one.\n    else { return MIDDLE_VORNOI_REGION; }\n  }\n  // Constants for Vornoi regions\n  /**\n   * @const\n   */\n  var LEFT_VORNOI_REGION = -1;\n  /**\n   * @const\n   */\n  var MIDDLE_VORNOI_REGION = 0;\n  /**\n   * @const\n   */\n  var RIGHT_VORNOI_REGION = 1;\n  \n  // ## Collision Tests\n\n  // Check if two circles collide.\n  /**\n   * @param {Circle} a The first circle.\n   * @param {Circle} b The second circle.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   the circles intersect.\n   * @return {boolean} true if the circles intersect, false if they don't. \n   */\n  function testCircleCircle(a, b, response) {\n    // Check if the distance between the centers of the two\n    // circles is greater than their combined radius.\n    var differenceV = T_VECTORS.pop().copy(b['pos']).sub(a['pos']);\n    var totalRadius = a['r'] + b['r'];\n    var totalRadiusSq = totalRadius * totalRadius;\n    var distanceSq = differenceV.len2();\n    // If the distance is bigger than the combined radius, they don't intersect.\n    if (distanceSq > totalRadiusSq) {\n      T_VECTORS.push(differenceV);\n      return false;\n    }\n    // They intersect.  If we're calculating a response, calculate the overlap.\n    if (response) { \n      var dist = Math.sqrt(distanceSq);\n      response['a'] = a;\n      response['b'] = b;\n      response['overlap'] = totalRadius - dist;\n      response['overlapN'].copy(differenceV.normalize());\n      response['overlapV'].copy(differenceV).scale(response['overlap']);\n      response['aInB']= a['r'] <= b['r'] && dist <= b['r'] - a['r'];\n      response['bInA'] = b['r'] <= a['r'] && dist <= a['r'] - b['r'];\n    }\n    T_VECTORS.push(differenceV);\n    return true;\n  }\n  SAT['testCircleCircle'] = testCircleCircle;\n  \n  // Check if a polygon and a circle collide.\n  /**\n   * @param {Polygon} polygon The polygon.\n   * @param {Circle} circle The circle.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testPolygonCircle(polygon, circle, response) {\n    // Get the position of the circle relative to the polygon.\n    var circlePos = T_VECTORS.pop().copy(circle['pos']).sub(polygon['pos']);\n    var radius = circle['r'];\n    var radius2 = radius * radius;\n    var points = polygon['points'];\n    var len = points.length;\n    var edge = T_VECTORS.pop();\n    var point = T_VECTORS.pop();\n    \n    // For each edge in the polygon:\n    for (var i = 0; i < len; i++) {\n      var next = i === len - 1 ? 0 : i + 1;\n      var prev = i === 0 ? len - 1 : i - 1;\n      var overlap = 0;\n      var overlapN = null;\n      \n      // Get the edge.\n      edge.copy(polygon['edges'][i]);\n      // Calculate the center of the circle relative to the starting point of the edge.\n      point.copy(circlePos).sub(points[i]);\n      \n      // If the distance between the center of the circle and the point\n      // is bigger than the radius, the polygon is definitely not fully in\n      // the circle.\n      if (response && point.len2() > radius2) {\n        response['aInB'] = false;\n      }\n      \n      // Calculate which Vornoi region the center of the circle is in.\n      var region = vornoiRegion(edge, point);\n      // If it's the left region:\n      if (region === LEFT_VORNOI_REGION) { \n        // We need to make sure we're in the RIGHT_VORNOI_REGION of the previous edge.\n        edge.copy(polygon['edges'][prev]);\n        // Calculate the center of the circle relative the starting point of the previous edge\n        var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);\n        region = vornoiRegion(edge, point2);\n        if (region === RIGHT_VORNOI_REGION) {\n          // It's in the region we want.  Check if the circle intersects the point.\n          var dist = point.len();\n          if (dist > radius) {\n            // No intersection\n            T_VECTORS.push(circlePos); \n            T_VECTORS.push(edge);\n            T_VECTORS.push(point); \n            T_VECTORS.push(point2);\n            return false;\n          } else if (response) {\n            // It intersects, calculate the overlap.\n            response['bInA'] = false;\n            overlapN = point.normalize();\n            overlap = radius - dist;\n          }\n        }\n        T_VECTORS.push(point2);\n      // If it's the right region:\n      } else if (region === RIGHT_VORNOI_REGION) {\n        // We need to make sure we're in the left region on the next edge\n        edge.copy(polygon['edges'][next]);\n        // Calculate the center of the circle relative to the starting point of the next edge.\n        point.copy(circlePos).sub(points[next]);\n        region = vornoiRegion(edge, point);\n        if (region === LEFT_VORNOI_REGION) {\n          // It's in the region we want.  Check if the circle intersects the point.\n          var dist = point.len();\n          if (dist > radius) {\n            // No intersection\n            T_VECTORS.push(circlePos); \n            T_VECTORS.push(edge); \n            T_VECTORS.push(point);\n            return false;              \n          } else if (response) {\n            // It intersects, calculate the overlap.\n            response['bInA'] = false;\n            overlapN = point.normalize();\n            overlap = radius - dist;\n          }\n        }\n      // Otherwise, it's the middle region:\n      } else {\n        // Need to check if the circle is intersecting the edge,\n        // Change the edge into its \"edge normal\".\n        var normal = edge.perp().normalize();\n        // Find the perpendicular distance between the center of the \n        // circle and the edge.\n        var dist = point.dot(normal);\n        var distAbs = Math.abs(dist);\n        // If the circle is on the outside of the edge, there is no intersection.\n        if (dist > 0 && distAbs > radius) {\n          // No intersection\n          T_VECTORS.push(circlePos); \n          T_VECTORS.push(normal); \n          T_VECTORS.push(point);\n          return false;\n        } else if (response) {\n          // It intersects, calculate the overlap.\n          overlapN = normal;\n          overlap = radius - dist;\n          // If the center of the circle is on the outside of the edge, or part of the\n          // circle is on the outside, the circle is not fully inside the polygon.\n          if (dist >= 0 || overlap < 2 * radius) {\n            response['bInA'] = false;\n          }\n        }\n      }\n      \n      // If this is the smallest overlap we've seen, keep it. \n      // (overlapN may be null if the circle was in the wrong Vornoi region).\n      if (overlapN && response && Math.abs(overlap) < Math.abs(response['overlap'])) {\n        response['overlap'] = overlap;\n        response['overlapN'].copy(overlapN);\n      }\n    }\n    \n    // Calculate the final overlap vector - based on the smallest overlap.\n    if (response) {\n      response['a'] = polygon;\n      response['b'] = circle;\n      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);\n    }\n    T_VECTORS.push(circlePos); \n    T_VECTORS.push(edge); \n    T_VECTORS.push(point);\n    return true;\n  }\n  SAT['testPolygonCircle'] = testPolygonCircle;\n  \n  // Check if a circle and a polygon collide.\n  //\n  // **NOTE:** This is slightly less efficient than polygonCircle as it just\n  // runs polygonCircle and reverses everything at the end.\n  /**\n   * @param {Circle} circle The circle.\n   * @param {Polygon} polygon The polygon.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testCirclePolygon(circle, polygon, response) {\n    // Test the polygon against the circle.\n    var result = testPolygonCircle(polygon, circle, response);\n    if (result && response) {\n      // Swap A and B in the response.\n      var a = response['a'];\n      var aInB = response['aInB'];\n      response['overlapN'].reverse();\n      response['overlapV'].reverse();\n      response['a'] = response['b'];\n      response['b'] = a;\n      response['aInB'] = response['bInA'];\n      response['bInA'] = aInB;\n    }\n    return result;\n  }\n  SAT['testCirclePolygon'] = testCirclePolygon;\n  \n  // Checks whether polygons collide.\n  /**\n   * @param {Polygon} a The first polygon.\n   * @param {Polygon} b The second polygon.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testPolygonPolygon(a, b, response) {\n    var aPoints = a['points'];\n    var aLen = aPoints.length;\n    var bPoints = b['points'];\n    var bLen = bPoints.length;\n    // If any of the edge normals of A is a separating axis, no intersection.\n    for (var i = 0; i < aLen; i++) {\n      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, a['normals'][i], response)) {\n        return false;\n      }\n    }\n    // If any of the edge normals of B is a separating axis, no intersection.\n    for (var i = 0;i < bLen; i++) {\n      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, b['normals'][i], response)) {\n        return false;\n      }\n    }\n    // Since none of the edge normals of A or B are a separating axis, there is an intersection\n    // and we've already calculated the smallest overlap (in isSeparatingAxis).  Calculate the\n    // final overlap vector.\n    if (response) {\n      response['a'] = a;\n      response['b'] = b;\n      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);\n    }\n    return true;\n  }\n  SAT['testPolygonPolygon'] = testPolygonPolygon;\n\n  return SAT;\n}));",
    "/// <reference path=\"linker.js\" />\r\n\r\n/*\r\n    A place for generic math, set/get methods, and other small functions.\r\n    Also used for global data structures, enums, and functions.\r\n*/\r\nvar utils = (function () {\r\n    var cboxMenu;\r\n\r\n\r\n    return {\r\n        /*\r\n            extends an oldObj into a newObj\r\n            while keeping certain objects properties in sync\r\n        */\r\n        extend: function (newObj, oldObj) {\r\n            // merge-copy current oldObj into newObj\r\n            $.extend(newObj, oldObj);\r\n\r\n            // force newObj to get oldObj's imgReady property\r\n            var prop = \"imgReady\";\r\n            Object.defineProperty(newObj, prop, {\r\n                get: function () {\r\n                    return oldObj[prop];\r\n                },\r\n                //set: function (arg) {\r\n                //    oldObj[prop] = arg;\r\n                //},\r\n                //configurable: true\r\n            });\r\n\r\n        },\r\n\r\n        speed2scale: function(speed){\r\n            return -0.5*speed + 2;\r\n        },\r\n\r\n        /*\r\n            Returns a random float between a and b.\r\n\r\n            @param(number) min The min floating point number.\r\n            @param(number) max The max floating point number.\r\n            @param(?number) precision The number of decimal precision places. (2 (hundredths place) by default)\r\n        */\r\n        randF: function(min, max, precision){\r\n            if(typeof (precision) === \"undefined\") {\r\n                precision = 2; // hundredths place\r\n            }\r\n\r\n            return parseFloat(Math.min(min + (Math.random() * (max - min)), max).toFixed(precision));\r\n        },\r\n\r\n        repeatAction: function (timeStep, numTimes, callback) {\r\n            var num = 0;\r\n            var theAnimation = setInterval(function () {\r\n                if (num++ > numTimes) {\r\n                    clearInterval(theAnimation);\r\n                }\r\n                else {\r\n                    callback();\r\n                }\r\n            }, timeStep);\r\n        },\r\n\r\n        deathSequence: function(){\r\n            if (!game.over) {\r\n                game.over = true;\r\n\r\n                audio.heroDeath.play();\r\n                audio.bgMusic.muted = true;\r\n\r\n                setTimeout(function () {\r\n                    Graphics.fadeCanvas(function () {\r\n                        level.reset();\r\n                        level.curLvl.deinit();\r\n                        level.curLvl.init();\r\n\r\n                        if (audio.isOn)\r\n                            audio.bgMusic.muted = false;\r\n                    });\r\n                }, 2600);\r\n            }\r\n        },\r\n\r\n        degToRad: function(deg){\r\n            return deg * 0.0174532925199432957;\r\n        },\r\n\r\n        revFactorial: function(n){\r\n            var count = 2;\r\n            var result = n;\r\n\r\n            while(result !== 1) {\r\n                console.log(result + '/' + count + '=');\r\n                result /= count;\r\n\r\n                if(result === 0) {\r\n                    return -1;\r\n                }\r\n                else if(result === 1) {\r\n                    return count;\r\n                }\r\n                else {\r\n                    ++count;\r\n                }\r\n            }\r\n        },\r\n\r\n        getTimeObj: function (t) {\r\n            if (t === 0) {\r\n                return { min: \"00\", sec: \"00\" };\r\n            }\r\n            \r\n            var min = Math.floor(t / 60);\r\n            var sec = t % 60;\r\n\r\n            if (sec < 10) {\r\n                sec = '0' + sec;\r\n            }\r\n\r\n            if (min < 10) {\r\n                min = '0' + min;\r\n            }\r\n\r\n            return {\r\n                min: min,\r\n                sec: sec\r\n            };\r\n        },\r\n\r\n        browser: function(){\r\n            var ua = navigator.userAgent,\r\n                     tem,\r\n                     M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\\/))\\/?\\s*([\\d\\.]+)/i) || []\r\n            ;\r\n\r\n            if (/trident/i.test(M[1])) {\r\n                tem = /\\brv[ :]+(\\d+(\\.\\d+)?)/g.exec(ua) || [];\r\n                    return 'IE '+(tem[1] || '');\r\n            }\r\n\r\n            M = M[2]? [M[1], M[2]]:[navigator.appName, navigator.appVersion, '-?'];\r\n\r\n            if ((tem = ua.match(/version\\/([\\.\\d]+)/i)) != null)\r\n                M[2] = tem[1];\r\n\r\n            return M.join(' ');\r\n        },\r\n\r\n        /**** Debug Printers ****/\r\n        // A method to print to the console less frequently then within the game loop.\r\n        printSlow: function(msg){\r\n            if (game.actualTime % 10 === 0) {\r\n                console.log(msg);\r\n            }\r\n        },\r\n\r\n\t\tprintMouse: function () {\r\n\t\t    $(\"canvas\").on(\"mousemove\", function (e) {\r\n\t\t        console.log(e.offsetX, e.offsetY);\r\n\t\t    });\r\n\t\t},\r\n\r\n\t\tprintDir: function (dir) {\r\n\t\t    switch (dir) {\r\n\t\t        case 0:\r\n\t\t            console.log(\"Dir.NONE\");\r\n\t\t            break;\r\n\t\t        case 1:\r\n\t\t            console.log(\"Dir.TOP\");\r\n\t\t            break;\r\n\t\t        case 2:\r\n\t\t            console.log(\"Dir.BOT\");\r\n\t\t            break;\r\n\t\t        case 3:\r\n\t\t            console.log(\"Dir.LEFT\");\r\n\t\t            break;\r\n\t\t        case 4:\r\n\t\t            console.log(\"Dir.RIGHT\");\r\n\t\t            break;\r\n\t\t        case 5:\r\n\t\t            console.log(\"Dir.IN\");\r\n\t\t            break;\r\n\t\t        default:\r\n\t\t            console.log(\"Dir.unknown\");\r\n\t\t    }\r\n\t\t},\r\n\r\n\t\ttoggleMenu: function () {\r\n\r\n\t\t    if ($(\"#colorbox\").css(\"display\") === \"block\") {\r\n\t\t        cboxMenu.colorbox.close();\r\n\t\t    }\r\n\t\t    else {\r\n\t\t        cboxMenu = $.colorbox({\r\n\t\t            html: $(\".gameInstructions\").html(),\r\n\t\t            width: 320,\r\n\t\t            height: 530\r\n\t\t        });\r\n\t\t    }\r\n\t\t},\r\n\r\n\t\ttoggleFullScreen: function () {\r\n\r\n\r\n\t\t    // fill browser window\r\n\t\t    if ($(\"body\").hasClass(\"fullscreen\")) {\r\n\t\t        $(\".canvasWrap\").css({\r\n\t\t            width: \"\",\r\n\t\t            marginLeft: \"\"\r\n\t\t        });\r\n\r\n\t\t        $(\"body\").removeClass(\"fullscreen\");\r\n\t\t    }\r\n\t\t    else {\r\n\t\t        $(\"body\").addClass(\"fullscreen\");\r\n\r\n\t\t        var scaledW = $(window).height() * 1.777778;\r\n\r\n\t\t        $(\".canvasWrap\").css({\r\n\t\t            width: scaledW,\r\n\t\t            marginLeft: -scaledW / 2\r\n\t\t        });\r\n\t\t    }\r\n\r\n\r\n\r\n            // fullscreen API\r\n            //if (!document.fullscreenElement &&    // alternative standard method\r\n            //    !document.mozFullScreenElement && !document.webkitFullscreenElement) {  // current working methods\r\n\r\n            //    if (canvas.requestFullscreen) {\r\n            //        canvas.requestFullscreen();\r\n            //    }\r\n            //    else if (canvas.mozRequestFullScreen) {\r\n            //        canvas.mozRequestFullScreen();\r\n            //    }\r\n            //    else if (canvas.webkitRequestFullscreen) {\r\n            //        canvas.webkitRequestFullscreen(); //Element.ALLOW_KEYBOARD_INPUT\r\n            //    }\r\n            //}\r\n            //else {\r\n            //    if (document.cancelFullScreen) {\r\n            //        document.cancelFullScreen();\r\n            //    }\r\n            //    else if (document.mozCancelFullScreen) {\r\n            //        document.mozCancelFullScreen();\r\n            //    }\r\n            //    else if (document.webkitCancelFullScreen) {\r\n            //        document.webkitCancelFullScreen();\r\n            //    }\r\n            //}\r\n        }\r\n\r\n\t};\r\n})();\r\n\r\n\r\n// global enums\r\nvar Dir = Object.freeze({\r\n    NONE: 0,\r\n    TOP: 1,\r\n    BOT: 2,\r\n    LEFT: 3,\r\n    RIGHT: 4,\r\n    IN: 5,\r\n    UP: 6,\r\n    DOWN: 7\r\n});\r\n\r\nvar Color = Object.freeze({\r\n    LIGHT_BROWN: \"#c44525\",\r\n    DARK_BROWN: \"#672819\",\r\n    LIGHT_GREEN: \"#166a38\",\r\n    SILVER: \"#c0c0c0\",\r\n    BLACK: \"#000\",\r\n    GOLD: \"#ddaa13\",\r\n    ORANGE: \"#ff6a00\"\r\n});\r\n\r\n// global functions\r\nwindow.requestAnimFrame = (function () {\r\n    return window.requestAnimationFrame ||\r\n\t\t   window.webkitRequestAnimationFrame ||\r\n\r\n\t\t   function (callback) {\r\n\t\t       setTimeout(callback, 16.6666666667); // 60fps fallback\r\n\t\t   };\r\n})();\r\n",
    "var audio = (function () {\r\n\r\n    return {\r\n        bgMusic: new Audio(\"audio/firstChiptune/firstChiptune.mp3\"),\r\n        enterSound: new Audio(\"audio/synthetic_explosion_1.mp3\"),\r\n        exitSound: new Audio(\"audio/annulet.mp3\"),\r\n        itemPickedUp: new Audio(\"audio/life_pickup.mp3\"),\r\n        heartbeat: new Audio(\"audio/heartbeat.mp3\"),\r\n        jump: new Audio(\"audio/jump.mp3\"),\r\n        thud: new Audio(\"audio/thud.mp3\"),\r\n        step: new Audio(\"audio/step.mp3\"),\r\n        effort: new Audio(\"audio/woosh.mp3\"),\r\n        discovery: new Audio(\"audio/spell3.mp3\"),\r\n        enemyDeath: new Audio(\"audio/death.mp3\"),\r\n        heroDeath: new Audio(\"audio/DiscsOfTron_Cascade.mp3\"),\r\n        enchant: new Audio(\"audio/enchant.mp3\"),\r\n        isOn: false,\r\n\r\n\r\n        init: function(){\r\n            audio.bgMusic.loop = true;\r\n            audio.bgMusic.volume = 0.7;\r\n            audio.bgMusic.pause();\r\n\r\n            audio.enemyDeath.volume = 0.6;\r\n            audio.jump.volume = 0.4;\r\n            audio.thud.volume = 0.78;\r\n            audio.discovery.volume = 0.7;\r\n\r\n            audio.mute(true);\r\n            $(document).on(\"click\", \".audioState\", audio.handleMuteButton);\r\n\r\n            $(\".menu\").on(\"click\", function (e) {\r\n                e.preventDefault();\r\n                utils.toggleMenu();\r\n            })\r\n\r\n            //----- enable audio on start -----\r\n            audio.handleMuteButton()\r\n        },\r\n\r\n        lvlComplete: function () {\r\n            audio.bgMusic.pause();\r\n\r\n            var newBgMusic;\r\n            \r\n            switch(game.lvl) {\r\n                case 0:\r\n                    audio.enterSound.play();\r\n                    newBgMusic = \"inspiredBySparkMan/sparkBoy.mp3\";\r\n                    break;\r\n                default:\r\n                    audio.exitSound.play();\r\n                    newBgMusic = \"sweetAcoustic.mp3\";\r\n                    break;\r\n            }\r\n\r\n            setTimeout(function () {\r\n                audio.bgMusic = new Audio(\"audio/\" + newBgMusic);\r\n                audio.bgMusic.loop = true;\r\n                audio.bgMusic.volume = 0.45;\r\n\r\n                audio.isOn ?\r\n                    audio.bgMusic.play() :\r\n                    audio.bgMusic.pause();\r\n            }, 1000);\r\n        },\r\n\r\n        play: function (sound, stopPrev) {\r\n            stopPrev = (typeof (stopPrev) !== \"undefined\") ? stopPrev : true;\r\n\r\n            if (sound.ended)\r\n                sound.play();\r\n            else {\r\n                if (stopPrev || sound.currentTime === 0) {\r\n                    sound.pause();\r\n                    sound.currentTime = 0;\r\n                    sound.play();\r\n                }\r\n            }\r\n        },\r\n\r\n        handleMuteButton: function () {\r\n            if ($('.audioState').hasClass('off')) {\r\n                $('.audioState span').removeClass('icon-volume-mute').addClass('icon-volume-medium');\r\n                $('.audioState').removeClass('off');\r\n                $('.audioState').addClass('on');\r\n\r\n                audio.mute(false);\r\n            }\r\n            else {\r\n                $('.audioState span').removeClass('icon-volume-medium').addClass('icon-volume-mute');\r\n                $('.audioState').removeClass('on');\r\n                $('.audioState').addClass('off');\r\n\r\n                audio.mute(true);\r\n            }\r\n        },\r\n\r\n        mute: function (onOrOff) {\r\n            audio.discovery.muted =\r\n            audio.enterSound.muted =\r\n            audio.bgMusic.muted =\r\n            audio.itemPickedUp.muted =\r\n            audio.heartbeat.muted =\r\n            audio.effort.muted = \r\n            audio.thud.muted = \r\n            audio.jump.muted = \r\n            audio.step.muted = \r\n            audio.enemyDeath.muted =\r\n            audio.heroDeath.muted =\r\n            audio.enchant.muted =\r\n            audio.exitSound.muted =\r\n                onOrOff;\r\n\r\n            onOrOff ?\r\n                audio.bgMusic.pause() :\r\n                audio.bgMusic.play();\r\n\r\n            audio.isOn = !onOrOff;\r\n        }\r\n    };\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\n/*\r\n    A library of generic graphics functions.\r\n*/\r\nvar Graphics = (function () {\r\n\r\n    var alpha = 1,\r\n        canvasTransition = null,\r\n        swellN = 250,\r\n        swellTimer = swellN,\r\n        swellRadius = swellN\r\n    ;\r\n\r\n    return {\r\n        ticker: 1,              // 1.0 --> 0.0 --> 1.0 --> ...\r\n        tickerStep: 0.01,\r\n        fadeOut: false,\r\n        projectX: 8,\r\n        projectY: 11,\r\n\r\n\r\n        fadeCanvas: function (callback) {\r\n            if (utils.browser() === \"MSIE 9.0\") {\r\n                callback();\r\n            }\r\n            else {\r\n                $(canvas).removeClass(\"preTransition\");\r\n                $(canvas).addClass(\"duringTransition\");\r\n\r\n                canvasTransition = $(canvas).on(\"transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd\", function () {\r\n                    canvasTransition.off();\r\n\r\n                    $(this).removeClass(\"duringTransition\");\r\n                    $(this).addClass(\"preTransition\");\r\n\r\n                    callback();\r\n                });\r\n            }\r\n        },\r\n\r\n        blinkText: function (fontSize, x, y, str) {\r\n            str = (typeof (str) !== \"undefined\") ? str : \"PRESS ENTER\";\r\n\r\n            if (Graphics.ticker >= 1.35 || Graphics.ticker <= Graphics.tickerStep) {\r\n                Graphics.fadeOut = !Graphics.fadeOut;\r\n            }\r\n\r\n            if (Graphics.ticker >= 1) {\r\n                alpha = 1;\r\n            }\r\n            else if (Graphics.ticker <= Graphics.tickerStep) {\r\n                alpha = 0;\r\n            }\r\n            else {\r\n                alpha = Graphics.ticker;\r\n            }\r\n\r\n            ctx.font = fontSize + \"px 'Press Start 2P'\";\r\n            var tmpW = ctx.measureText(str).width;\r\n            ctx.fillStyle = \"rgba(233, 233, 233,\" + alpha + ')';\r\n            ctx.fillText(str, x - tmpW / 2, y);\r\n        },\r\n\r\n        /*\r\n            Converts a rectangle into a 'skewed rectangle' polygon\r\n\r\n            @param(number) x\r\n            @param(number) y\r\n            @param(number) w\r\n            @param(number) h\r\n            @return (SAT.Polygon)\r\n        */\r\n        getSkewedRect: function (x, y, w, h) {\r\n            y += Graphics.projectY / 2;\r\n\r\n            var poly = new SAT.Polygon(new SAT.Vector(x, y), [\r\n                new SAT.Vector(),\r\n                new SAT.Vector(w - Graphics.projectX, 0),\r\n                new SAT.Vector(w, Graphics.projectY),\r\n                new SAT.Vector(w, h),\r\n                new SAT.Vector(Graphics.projectX, h),\r\n                new SAT.Vector(0, h - Graphics.projectY)\r\n            ]);\r\n\r\n            return poly;\r\n        },\r\n\r\n        getStairPoly: function(x, y, w, h){\r\n            var poly = new SAT.Polygon(new SAT.Vector(x, y), [\r\n                new SAT.Vector(),\r\n                new SAT.Vector(w - Graphics.projectY, -h),\r\n                new SAT.Vector(w, -h + Graphics.projectY),\r\n                new SAT.Vector(w, 0),\r\n                new SAT.Vector(Graphics.projectX, h),\r\n                new SAT.Vector(0, h - Graphics.projectY)\r\n            ]);\r\n\r\n            return poly;\r\n        },\r\n\r\n        setClouds: function(){\r\n            var x = 0,\r\n                y = 0,\r\n                maxY = 180\r\n            ;\r\n\r\n            while(x < lvl1.width) {\r\n                var obj = new GameObj(JQObject.CLOUD, x, 10 + y, 0, 0, \"cloud.png\");\r\n                obj.speed = utils.randF(2, 3.3, 1);\r\n                level.bg.push(obj);\r\n\r\n                x += obj.w * utils.speed2scale(obj.speed) + Math.floor((Math.random() * 70) + 35);\r\n                y = Math.floor(Math.random() * maxY);\r\n            }\r\n        },\r\n\r\n        drawLadder: function (platform) {\r\n            var x = platform.pos.x,\r\n                y = platform.pos.y,\r\n                w = platform.edges[0].x,\r\n                h = platform.edges[1].y\r\n            ;\r\n\r\n            // sides\r\n            ctx.fillStyle = Color.LIGHT_BROWN;\r\n            ctx.fillRect(x, y, 5, h);\r\n            ctx.fillRect(x + w-5, y, 5, h);\r\n\r\n            // rungs\r\n            for (var i = 13; i < h; i+=20) {\r\n                ctx.fillRect(x, y+i, w, 8);\r\n            }\r\n        },\r\n\r\n        drawScale: function (platform) {\r\n            var x = platform.pos.x,\r\n                y = platform.pos.y,\r\n                w = platform.edges[0].x,\r\n                h = platform.edges[1].y\r\n            ;\r\n            \r\n            // draw top border 1px above bounding box\r\n            ctx.fillStyle = Color.BLACK;\r\n            ctx.fillRect(x, y - 1, w, 1);\r\n\r\n            // draw platform\r\n            ctx.fillStyle = Color.DARK_BROWN;\r\n            ctx.fillRect(x, y, w, h);\r\n        },\r\n\r\n        drawPoly: function(poly) {\r\n            var y = poly.pos.y; //- Graphics.projectY / 2;\r\n\r\n            ctx.fillStyle = \"orange\";\r\n            ctx.beginPath();\r\n            ctx.moveTo(poly.pos.x, y);\r\n\r\n            for(var i = 1; i < poly.points.length; ++i) {\r\n                ctx.lineTo(poly.pos.x + poly.points[i].x, y + poly.points[i].y);\r\n            }\r\n\r\n            ctx.closePath();\r\n            ctx.fill();\r\n        },\r\n\r\n        drawHill: function(poly) {\r\n            //var x = 112,\r\n            //    y = 497.5,\r\n            //    w = 300,\r\n            //    h = 100,\r\n            //    xw = x + w,\r\n            //    yh = y - h + 30\r\n            //;\r\n\r\n            //ctx.fillStyle = Color.LIGHT_BROWN;\r\n            //ctx.beginPath();\r\n            //ctx.moveTo(x, y);\r\n            //ctx.bezierCurveTo(x, yh, xw, yh, xw, y);\r\n            //ctx.closePath();\r\n            //ctx.fill();\r\n\r\n            //Graphics.drawPoly(poly);\r\n            //if(typeof (poly.tag) !== \"undefined\" && poly.tag === 1) {\r\n            //    ctx.fillStyle = Color.LIGHT_BROWN;\r\n            //    ctx.beginPath();\r\n            //    ctx.moveTo(poly.pos.x - Graphics.projectX, poly.pos.y);\r\n            //    ctx.lineTo(poly.pos.x, poly.pos.y);\r\n            //    ctx.lineTo(poly.pos.x, poly.pos.y + Graphics.projectY);\r\n            //    ctx.closePath();\r\n            //    ctx.fill();\r\n            //}\r\n\r\n            var repeatZ = function(z) {\r\n\r\n                var y = poly.pos.y - Graphics.projectY + z;\r\n\r\n                if(z === game.padFloor - 4)\r\n                    ctx.fillStyle = Color.DARK_BROWN;\r\n                else\r\n                    ctx.fillStyle = Color.LIGHT_BROWN;\r\n\r\n                var fixX = Math.round(poly.pos.x);\r\n\r\n                ctx.beginPath();\r\n                ctx.moveTo(fixX, y);\r\n\r\n                for(var i = 1; i < poly.points.length; ++i) {\r\n                    fixX = Math.round(poly.pos.x + poly.points[i].x);\r\n                    ctx.lineTo(fixX, y + poly.points[i].y);\r\n                }\r\n\r\n                ctx.closePath();\r\n                ctx.fill();\r\n            }\r\n\r\n            for(var i = 0; i < game.padFloor - 3; ++i) {\r\n                repeatZ(i);\r\n            }\r\n\r\n        },\r\n\r\n\r\n        // h must be a triangular number?\r\n        getHill: function(x, y, w, h) {\r\n\r\n            var objs = [],\r\n                totalH = 0,\r\n                prevH = 0,\r\n                nextH\r\n            ;\r\n\r\n\r\n            var tmp = Math.sqrt(h);\r\n            nextH = tmp;\r\n            //console.log(tmp);\r\n            var dtW = w / (tmp*2);\r\n\r\n\r\n            // left half\r\n            for(var i = 0; i < tmp; ++i) {\r\n                objs.push(new SAT.Polygon(new SAT.Vector(x + i*dtW, y - prevH), [\r\n                    new SAT.Vector(),\r\n                    new SAT.Vector(dtW, -nextH),\r\n                    new SAT.Vector(dtW, totalH),\r\n                    new SAT.Vector(0, totalH)\r\n                ]));\r\n                \r\n                prevH += nextH;\r\n                totalH += nextH--;\r\n            }\r\n            \r\n            // right half\r\n            x += tmp * dtW;\r\n            nextH = 0;\r\n            prevH = -totalH;\r\n\r\n            for(var i = 0; i < tmp; ++i) {\r\n                objs.push(new SAT.Polygon(new SAT.Vector(x + i*dtW, y + prevH), [\r\n                    new SAT.Vector(),\r\n                    new SAT.Vector(dtW, nextH),\r\n                    new SAT.Vector(dtW, totalH),\r\n                    new SAT.Vector(0, totalH)\r\n                ]));\r\n\r\n                prevH += nextH;\r\n                totalH -= nextH++;\r\n            }\r\n\r\n            return objs;\r\n        },\r\n\r\n        drawPlatform: function (poly) {\r\n            var y = poly.pos.y - Graphics.projectY / 2;\r\n\r\n            // top\r\n            ctx.fillStyle = Color.LIGHT_BROWN;\r\n            ctx.beginPath();\r\n            ctx.moveTo(poly.pos.x, y);\r\n            ctx.lineTo(poly.pos.x + poly.points[1].x, y + poly.points[1].y);\r\n            ctx.lineTo(poly.pos.x + poly.points[2].x, y + poly.points[2].y);\r\n            ctx.lineTo(poly.pos.x + Graphics.projectX, y + Graphics.projectY);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n\r\n            // body\r\n            ctx.fillStyle = Color.DARK_BROWN;\r\n            ctx.beginPath();\r\n            ctx.moveTo(poly.pos.x + poly.points[2].x, y + poly.points[2].y);\r\n            ctx.lineTo(poly.pos.x + poly.points[3].x, y + poly.points[3].y);\r\n            ctx.lineTo(poly.pos.x + poly.points[4].x, y + poly.points[4].y);\r\n            ctx.lineTo(poly.pos.x + poly.points[5].x, y + poly.points[5].y);\r\n            ctx.lineTo(poly.pos.x + poly.points[0].x, y + poly.points[0].y);\r\n            ctx.lineTo(poly.pos.x + Graphics.projectX, y + Graphics.projectY);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n        },\r\n\r\n        drawPlatformStatus: function (platform) {\r\n            var x = platform.pos.x,\r\n                y = platform.pos.y,\r\n                w = platform.w,\r\n                h = platform.h,\r\n                theShape = 26,\r\n                halfTheShape = theShape/2,\r\n                midX = x + w/2 - halfTheShape,\r\n                midY = y + h/2 - halfTheShape\r\n            ;\r\n\r\n            ctx.lineWidth = 3;\r\n\r\n            if (platform.holdingItem !== null && platform.holdingItem.type === JQObject.CRATE) {\r\n                // draw check mark\r\n                ctx.strokeStyle = \"green\";\r\n\r\n                --midY;\r\n                ctx.beginPath();\r\n                ctx.moveTo(midX, midY + halfTheShape);\r\n                ctx.lineTo(midX + halfTheShape, midY + theShape);\r\n                ctx.moveTo(midX + halfTheShape-1, midY + theShape);\r\n                ctx.lineTo(midX + theShape+2, midY+2);\r\n                ctx.stroke();\r\n                ctx.closePath();\r\n\r\n            }\r\n            else {\r\n                // draw 'X'\r\n                ctx.strokeStyle = \"red\";\r\n\r\n                ctx.beginPath();\r\n                ctx.moveTo(midX, midY);\r\n                ctx.lineTo(midX + theShape, midY + theShape);\r\n                ctx.moveTo(midX, midY + theShape);\r\n                ctx.lineTo(midX + theShape, midY);\r\n                ctx.stroke();\r\n                ctx.closePath();\r\n            }\r\n        },\r\n\r\n        // @param(GameObj) gObj A game object.\r\n        drawDoor: function (gObj) {\r\n            // alias\r\n            var x = gObj.pos.x;\r\n            var y = gObj.pos.y;\r\n            var w = gObj.w;\r\n            var h = gObj.h;\r\n\r\n            // door\r\n            ctx.fillStyle = Color.LIGHT_BROWN;\r\n            ctx.fillRect(x + 2, y + 2, w - 2, h - 2);\r\n\r\n            ctx.fillStyle = Color.DARK_BROWN;\r\n\r\n            ctx.fillRect(x, y, 2, h);   // left frame\r\n            ctx.fillRect(x, y, w, 2);   // top frame\r\n            ctx.fillRect(x + w, y, 2, h);   // right frame\r\n\r\n            // door handle\r\n            ctx.beginPath();\r\n            ctx.arc(x + w - (w / 3.2), y + h - (h / 3.4), 4, 0, 2 * Math.PI, false);\r\n            ctx.fill();\r\n            ctx.closePath();\r\n\r\n            // label\r\n            ctx.font = \"19px 'Press Start 2P'\";\r\n            ctx.fillStyle = Color.DARK_BROWN;\r\n            ctx.fillText(\"EXIT\", x - 15, y - 3);\r\n            ctx.fillStyle = Color.LIGHT_BROWN;\r\n            ctx.fillText(\"EXIT\", x - 18, y - 5);\r\n        },\r\n\r\n        getDoorBgGrad: function(){\r\n            var grad = ctx.createRadialGradient(\r\n                level.bgColor.gradX,\r\n                level.bgColor.gradY,\r\n                14,\r\n                level.bgColor.gradX,\r\n                level.bgColor.gradY,\r\n                490 - swellRadius\r\n            );\r\n\r\n            if(--swellTimer === -swellN) {\r\n                swellTimer = swellN;\r\n                swellRadius = swellN;\r\n            }\r\n            else if(swellTimer < 0) {\r\n                ++swellRadius;\r\n            }\r\n            else {\r\n                --swellRadius;\r\n            }\r\n\r\n            grad.addColorStop(0, \"rgb(203,163,0)\");\r\n            //grad.addColorStop(0, \"rgb(42,126,76)\");\r\n            //grad.addColorStop(1, \"rgb(22,106,56)\");\r\n            grad.addColorStop(1, \"#1F7DCF\");\r\n\r\n            return grad;\r\n        },\r\n\r\n        drawEllipse: function (x, y, w, h) {\r\n            var kappa = 0.5522848,\r\n\t\t\t\tox = (w / 2) * kappa, // control point offset horizontal\r\n\t\t\t\toy = (h / 2) * kappa, // control point offset vertical\r\n\t\t\t\txe = x + w, // x-end\r\n\t\t\t\tye = y + h, // y-end\r\n\t\t\t\txm = x + w / 2, // x-middle\r\n\t\t\t\tym = y + h / 2 // y-middle\r\n            ;\r\n\r\n            ctx.beginPath();\r\n            ctx.moveTo(x, ym);\r\n            ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\r\n            ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\r\n            //ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\r\n            //ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n        },\r\n\r\n        drawRotate: function (img, x, y, angle) {\r\n            ctx.save();\r\n\r\n            ctx.translate(x, y);\t\t\t\t\t\t\t\t// move co-ord sys to img origin\r\n            ctx.rotate(utils.degToRad(angle));\r\n            ctx.translate(-img.width * 0.5, -img.height * 0.5); // move to top left of img\r\n\r\n            //ctx.scale(0.75, 0.75);\r\n            ctx.drawImage(img, 0, 0);\r\n\r\n            ctx.restore();\r\n        }\r\n    };\r\n})();\r\n\r\n\r\n/* Images */\r\n//lvl = new Array(NUM_LEVELS),\r\n//lvlBgImg = {}\r\n//function loadBgImages(imgArr, callback) {\r\n//    var count = 0;\r\n\r\n//    for (var key in imgArr) {\r\n//        if (imgArr[key] !== \"none\") {\r\n//            lvlBgImg[key] = new Image();\r\n//            lvlBgImg[key].onload = function () {\r\n//                callback(this.num);\r\n//            };\r\n\r\n//            lvlBgImg[key].src = imgArr[key];\r\n//            lvlBgImg[key].num = count;\r\n//        }\r\n\r\n//        ++count;\r\n//    }\r\n//}\r\n\r\n//for (var i = 0; i < NUM_LEVELS; ++i) {\r\n//    lvl[i] = {\r\n//        status: false,\r\n//        bgColor: '#' + Math.floor(Math.random() * 16777215).toString(16)\r\n//    };\r\n//}\r\n\r\n//loadBgImages({\r\n//    lvl0: \"img/lvl0.jpg\",\r\n//    lvl1: \"none\"\r\n//}, function (num) {\r\n//    lvl[num].status = true;\r\n//});\r\n\r\n\r\n\r\n\r\n//var wasClicked = false;\r\n//$(\".resize\").on(\"click\", function(){\r\n//    if (wasClicked) {\r\n//        $(canvas).css({ width: \"\", height: \"\" });\r\n//        $(this).attr(\"class\", \"resize off\");\r\n//        $(this).children(\"span\").attr(\"class\", \"icon-expand\");\r\n//    }\r\n//    else {\r\n//        $(canvas).css({ width: \"100%\" });\r\n\r\n//        // fix for IE\r\n//        var width = $(canvas).width();\r\n//        $(canvas).css({ height: 0.611 * width });\r\n\r\n\r\n//        $(this).attr(\"class\", \"resize on\");\r\n//        $(this).children(\"span\").attr(\"class\", \"icon-contract\");\r\n//    }\r\n\r\n//    wasClicked = !wasClicked;\r\n//});\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\n// A library of generic physics functions.\r\nvar Physics = (function () {\r\n\r\n\r\n    return {\r\n        // TODO: speed up by checking if a does NOT intersect with b (i.e. using OR)\r\n        // Uses simple Speculative Contacts\r\n        isCollision: function (a, b, moe, isLvl) {\r\n            var aX = (typeof (isLvl) !== \"undefined\") ? a.pos.x + a.lvlX : a.pos.x;\r\n\r\n            if ((aX + moe <= (b.pos.x + b.w)) && // a is to the left of the right side of b\r\n\t\t\t\t(b.pos.x + moe <= (aX + a.w)) && // a is to the right of the left side of b\r\n\t\t\t\t(a.pos.y + moe <= (b.pos.y + b.h)) && // a is higher than the bot of b\r\n\t\t\t\t(b.pos.y + moe <= (a.pos.y + a.h)) \t  // a is lower than the top of b\r\n\t\t\t) {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        },\r\n        \r\n        // Checks for a collision between two polygons (uses SAT and AABB).\r\n        // @param(GameObj) a A game object.\r\n        // @param(GameObj) b A game object.\r\n        // @param(function) callback A function invoked with SAT.Response ONLY IF a collision occurred.\r\n        isSATcollision: function (a, b, callback) {\r\n            var r = new SAT.Response();\r\n            if (SAT.testPolygonPolygon(a, b, r)) {\r\n                callback(r);\r\n            }\r\n        },\r\n\r\n        // Tests collision between gObj and level.objs[]\r\n        // @param(GameObj) gObj A game object (or subclass).\r\n        // @param(function) callback A callback function.  Called with a SAT.Response().\r\n        testObjObjs: function (gObj, callback) {\r\n            var response = new SAT.Response();\r\n\r\n            for(var i = 0; i < level.objs.length; ++i) {\r\n\r\n                var obj = level.objs[i];\r\n\r\n                if (typeof(obj.collidable) === \"undefined\"\r\n                    //&& level.objs[i] !== gObj         // checks if object is in list (by reference)\r\n                ) {\r\n\r\n                    //var n = 1;\r\n                    //if(obj.type === JQObject.HILL) {\r\n                    //    n = obj.length;\r\n                    //}\r\n\r\n                    //var innerObj = obj;\r\n                    //for(var j = 0; j < n; ++j) {\r\n                    //    if(n > 1) {\r\n                    //        innerObj = obj[j];\r\n                    //    }\r\n\r\n                        // Check Level Object Collision\r\n                        var collided = SAT.testPolygonPolygon(gObj, obj, response);\r\n\r\n                        // Respond to Level Object Collision\r\n                        if(collided) {\r\n                            callback(response);\r\n                        }\r\n\r\n                        response.clear();\r\n                    //}\r\n                    \r\n                }\r\n            }\r\n\r\n            // idea to fix \"hooking\" around edges of platform\r\n            // http://stackoverflow.com/a/1355695/353166\r\n        },\r\n\r\n        // Tests collision between item and level.items[]\r\n        // @param(GameItem) item A game item.\r\n        // @param(function) callback A callback function.  Called with a SAT.Response().\r\n        testItemItems: function (item, callback) {\r\n            var response = new SAT.Response();\r\n\r\n            for (var i = 0; i < level.items.length; ++i) {\r\n                if (!level.items[i].isBeingHeld) {\r\n                        \r\n                    if (level.items[i].type !== JQObject.CRATE)       // TODO: allow non-crates\r\n                        continue;\r\n\r\n                    var collided = SAT.testPolygonPolygon(item, level.items[i], response);\r\n                        \r\n                    if (collided) {\r\n                        if (response.overlapN.y === 1) {   // a is on top of b\r\n                            response.a.pos.x -= response.overlapV.x;\r\n                            response.a.pos.y -= response.overlapV.y;\r\n\r\n                            callback(response);\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    response.clear();\r\n                }\r\n            }\r\n        },\r\n\r\n        // Tests collision between hero and the level.items[]\r\n        // @param(function) callback A callback function.  Called with a SAT.Response and the index of the item.\r\n        testHeroItems: function (callback) {\r\n            for (var i = 0; i < level.items.length; ++i) {\r\n                if (level.items[i].visible) {\r\n                    Physics.isSATcollision(hero, level.items[i], function (r) {\r\n                            callback(r, i);\r\n                    });\r\n                }\r\n            }\r\n        },\r\n\r\n        // Tests collision between items\r\n        //testAllItems: function () {\r\n        //    var response = new SAT.Response();\r\n\r\n        //    for (var i = 0; i < level.items.length; ++i) {\r\n        //        for (var j = 0; j < level.items.length; ++j) {\r\n        //            if (i !== j && !level.items[i].isBeingHeld && !level.items[j].isBeingHeld) {\r\n                        \r\n        //                if (level.items[i].type !== JQObject.CRATE || level.items[j].type !== JQObject.CRATE)       // TODO: allow non-crates\r\n        //                    continue;\r\n\r\n        //                var collided = SAT.testPolygonPolygon(level.items[i], level.items[j], response);\r\n                        \r\n        //                if (collided) {\r\n        //                    if (response.overlapN.y === 1) {   // a is on top of b\r\n        //                        response.a.pos.x -= response.overlapV.x;\r\n        //                        response.a.pos.y -= response.overlapV.y;\r\n\r\n        //                        response.a.isOnObj = true;\r\n        //                        response.a.onObj = response.b;\r\n        //                        response.b.grabbable = false;\r\n\r\n        //                        level.items.push(response.a);\r\n        //                    }\r\n        //                }\r\n\r\n        //                response.clear();\r\n        //            }\r\n        //        }\r\n        //    }\r\n        //}\r\n    };\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar JQObject = Object.freeze({\r\n    EMPTY: 0,\r\n    CRATE: 1,\r\n    LADDER: 2,\r\n    SACK: 3,\r\n    ENEMY: 4,\r\n    CASH: 5,\r\n    DOOR: 6,\r\n    SCALE: 7,\r\n    CLOUD: 8,\r\n    PLATFORM: 9,\r\n    SHURIKEN: 10,\r\n    SLOPE: 11,\r\n    POLY: 12,\r\n    HILL: 13,\r\n    ELEVATOR: 14,\r\n    SCALEBG: 15\r\n});\r\n\r\nvar JQObject_names = Object.freeze({\r\n    0: \"EMPTY\",\r\n    1: \"CRATE\",\r\n    2: \"LADDER\",\r\n    3: \"SACK\",\r\n    4: \"ENEMY\",\r\n    5: \"CASH\",\r\n    6: \"DOOR\",\r\n    7: \"SCALE\",\r\n    8: \"CLOUD\",\r\n    9: \"PLATFORM\",\r\n    10: \"SHURIKEN\",\r\n    11: \"SLOPE\",\r\n    12: \"POLY\",\r\n    13: \"HILL\",\r\n    14: \"ELEVATOR\",\r\n    15: \"SCALEBG\"\r\n});\r\n\r\n/*\r\n    GameObj is the base class from which all objects in the game inherit from.\r\n    Every GameObj has a SAT.Vector (pos);       TODO: make Vector not Polygon\r\n    \r\n    @param(JQObject) type The type of the object.\r\n    @param(number) x The x position of the object.\r\n    @param(number) y The y position of the object.\r\n    @param(number?) w The width of the object.\r\n    @param(number?) h The height of the object.\r\n    @param(Image?) src The filename of the object sprite.  unused by default\r\n    \r\n    @constructor\r\n*/\r\nvar GameObj = function (type, x, y, w, h, src) {\r\n    // this.pos\r\n    if (type === JQObject.PLATFORM || type === JQObject.ELEVATOR) {\r\n        $.extend(this, Graphics.getSkewedRect(x, y, w, h));\r\n    }\r\n    else if(type === JQObject.SLOPE) {\r\n        $.extend(this, Graphics.getStairPoly(x, y, w, h));\r\n    }\r\n    else if(type === JQObject.POLY) {\r\n        // custom polygon\r\n    }\r\n    else {\r\n        $.extend(this, new SAT.Box(new SAT.Vector(x, y), w, h).toPolygon());\r\n    }\r\n\r\n    this.type = type;\r\n    this.imgReady = false;     // TODO: make private\r\n\r\n    if (typeof (src) === \"undefined\") {\r\n        this.w = w;\r\n        this.h = h;\r\n    }\r\n    else {\r\n        this.w = 0;\r\n        this.h = 0;\r\n\r\n        this.img = new Image();\r\n\r\n        var that = this;\r\n        this.img.onload = function () {\r\n            that.imgReady = true;\r\n            that.w = this.width;\r\n            that.h = this.height;\r\n        };\r\n        \r\n        this.img.src = \"img/\" + src;\r\n    }\r\n};\r\n\r\nGameObj.prototype = {\r\n    draw: function () {\r\n        if (this.imgReady) {\r\n            ctx.drawImage(this.img, this.pos.x, this.pos.y);\r\n        }\r\n        else {\r\n            if(this.type === JQObject.SCALEBG) {\r\n                ctx.fillStyle = Color.LIGHT_BROWN;\r\n            }\r\n            else {\r\n                ctx.fillStyle = \"red\";\r\n            }\r\n\r\n            ctx.fillRect(this.pos.x, this.pos.y, this.w, this.h);\r\n        }\r\n    }\r\n};\r\n",
    "/*\r\n    GameItem extends GameObj\r\n    GameItem may extend SAT.Vector to be SAT.Polygon\r\n\r\n    @param(GameObj) gObj A game object.\r\n    @param(?bool) grabbable Whether the game item can be pickup up or not. (false by default)\r\n    @param(?number) val The value of the game item. (-1 by default)\r\n    @param(?bool) visible Whether the game item is displayed or not.  (true by default)\r\n*/\r\nvar GameItem = function (gObj, grabbable, val, visible) {\r\n    utils.extend(this, gObj);\r\n    \r\n    this.grabbable = (typeof (grabbable) !== \"undefined\") ? grabbable : false;\r\n    this.val = (typeof(val) !== \"undefined\") ? val : -1;\r\n    this.visible = (typeof (visible) !== \"undefined\") ? visible : true;\r\n\r\n    this.vY = 0;\r\n    this.isOnObj = false;   // TODO: allow setting to true to avoid \"thud\" sound on level start\r\n    this.onObj = null;      // contains the object holding up the object (directly below)\r\n\r\n    this.isBeingHeld = false;\r\n\r\n    // TODO: make private/prototype\r\n    var parentDraw = this.draw;\r\n    this.draw = function () {\r\n        if (this.visible) {\r\n            parentDraw.apply(this);\r\n        }\r\n    };\r\n};\r\n\r\n//GameItem.prototype = {\r\n//};\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar HUD = (function () {\r\n\r\n    var cash = null,\r\n        medKit = null,\r\n        shuriken = null,\r\n        syringe = null\r\n    ;\r\n\r\n\r\n    function drawHealth(){\r\n        for(var i=0; i < hero.health; ++i){\r\n            ctx.fillStyle = \"red\";\r\n            ctx.fillRect(77 + i*21, FULLH + 8, 19, 8);\r\n        }\r\n    }\r\n\t\r\n    function drawMana(){\r\n        for(var i=0; i < hero.mana; ++i){\r\n            ctx.fillStyle = \"#00b6ff\";\r\n            ctx.fillRect(77 + i*21, FULLH + 26, 19, 8);\r\n        }\r\n    }\r\n\t\r\n    function drawXP() {\r\n        ctx.fillStyle = \"#ddd\";\r\n        ctx.font = \"12px 'Press Start 2P'\";\r\n        \t\r\n        var zero = (hero.xp < 10) ? '0' : '';\r\n        ctx.fillText(zero + hero.xp + '/' + hero.xpNeeded, 77, FULLH + 54);\r\n    }\r\n\r\n\r\n    return {\r\n        init: function () {\r\n            // HUD icons\r\n            cash = new GameObj(JQObject.EMPTY, 548, FULLH + 20, 22, 24, \"cash.png\");\r\n            medKit = new GameObj(JQObject.EMPTY, 238, FULLH + 15, 31, 30, \"medKit.png\");\r\n            shuriken = new GameObj(JQObject.EMPTY, 447, FULLH + 15, 31, 31, \"shuriken.png\");\r\n            syringe = new GameObj(JQObject.EMPTY, 342, FULLH + 18, 25, 25, \"syringe.png\");\r\n        },\r\n\r\n        draw: function () {// TODO: break out static parts\r\n            // background\r\n            ctx.fillStyle = \"#070707\";\r\n            ctx.fillRect(0, FULLH, FULLW, game.padHUD);\r\n\r\n            ctx.fillStyle = \"#ddd\";\r\n            ctx.font = \"11px 'Press Start 2P'\";\r\n\r\n\r\n            ctx.fillText(\"HP-\" + hero.healthLvl, 7, FULLH + 18);\r\n            ctx.fillText(\"MP-\" + hero.manaLvl, 7, FULLH + 37);\r\n            ctx.fillText(\"XP\", 7, FULLH + 54);\r\n            \r\n            drawHealth();\r\n            drawMana();\r\n            drawXP();\r\n\r\n            // hp kit\r\n            ctx.fillText(hero.medKits, 210, FULLH + 37);\r\n            medKit.draw();\r\n\r\n            // mp kit\r\n            ctx.fillText(hero.manaKits, 315, FULLH + 37);\r\n            syringe.draw();\r\n\r\n            // ammo\r\n            ctx.fillText(hero.ammo, 410, FULLH + 37);\r\n            shuriken.draw();\r\n\r\n            // money\r\n            ctx.fillText(hero.cash, 515, FULLH + 37);\r\n            cash.draw();\r\n\r\n            // time\r\n            var time = utils.getTimeObj(game.actualTime);\r\n            ctx.fillText(time.min + ':' + time.sec, FULLW - 78, FULLH + 24);\r\n        }\r\n    };\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar JQEnemy = Object.freeze({\r\n    STILL: 0,\r\n    PATROL: 1,\r\n    FOLLOW: 2\r\n});\r\n\r\n\r\n/*\r\n    Enemy extends GameObj\r\n\r\n    @param(GameObj) gObj A game object (super class).\r\n    @param(EnemyType) enemy_t The type of the enemy.\r\n    @param(number) health The hp of the enemy.\r\n    @param(number) leftXBound The left x coordinate boundary.\r\n    @param(number) rightXBound The right x coordinate boundary.\r\n    @param(bool?) active Is the enemy allowed to move?\r\n    @constructor\r\n*/\r\nvar Enemy = function (gObj, enemy_t, health, leftXBound, rightXBound, active) {\r\n    utils.extend(this, gObj);\r\n\r\n    this.initHealth = this.health = health;\r\n    this.enemy_t = enemy_t;\r\n    this.leftXBound = leftXBound;\r\n    this.rightXBound = rightXBound;\r\n    this.active = (typeof (active) !== \"undefined\") ? active : false;\r\n    this.deadOffScreen = false;\r\n\r\n    // TODO: make private (and initHealth)\r\n    this.dir = Dir.RIGHT;\r\n    this.alive = true;\r\n    this.deadOnScreen = false;\r\n    this.clearDir = true;\t\t// true = right; false = left;\r\n\r\n    // draw\r\n    function drawHealth(that) {\r\n        var healthLen = (that.w / that.initHealth) * that.health;\r\n\r\n        ctx.fillStyle = \"red\";\r\n        ctx.fillRect(that.x, that.y - 12, healthLen, 4);\r\n    }\r\n\r\n    var parentDraw = this.draw;\r\n    this.draw = function () {\r\n        if (this.alive || this.deadOnScreen) {\r\n            if (this.initHealth > 1) {\r\n                drawHealth(this);\r\n            }\r\n\r\n            ctx.save();\r\n            if (this.deadOnScreen) {\r\n                ctx.globalAlpha = 0.3;\r\n            }\r\n\r\n            parentDraw.apply(this);\r\n            ctx.restore();\r\n        }\r\n    }\r\n};\r\n\r\nEnemy.prototype = {\r\n\r\n    update: function () {\r\n        if (this.deadOnScreen) {\r\n            this.pos.x += this.clearDir ? 2 : -2;\r\n            this.pos.y -= 9;\r\n\r\n            if (this.pos.x < 0 || this.pos.x > FULLW) {\r\n                this.deadOnScreen = false;\r\n                this.deadOffScreen = true;\r\n            }\r\n        }\r\n        else if (this.active && game.totalTicks % 3 === 0) {\r\n            this.movement();\r\n        }\r\n    },\r\n\r\n    // TODO: make private\r\n    movement: function() {\r\n        if (this.enemy_t === JQEnemy.PATROL) {\r\n            if (this.pos.x + hero.lvlX <= this.leftXBound)\r\n                this.dir = Dir.RIGHT;\r\n            else if (this.pos.x + hero.lvlX >= this.rightXBound)\r\n                this.dir = Dir.LEFT;\r\n\r\n            if (this.dir === Dir.RIGHT) {\r\n                ++this.pos.x;\r\n            }\r\n            else {\r\n                --this.pos.x;\r\n            }\r\n        }\r\n        else if (this.enemy_t === JQEnemy.FOLLOW) {\r\n            if (this.pos.x < hero.pos.x)\r\n                ++this.pos.x;\r\n            else if (this.pos.x > hero.pos.x)\r\n                --this.pos.x;\r\n        }\r\n    },\r\n\r\n    death: function () {\r\n        this.clearDir = (hero.dir == Dir.RIGHT);\r\n\r\n        audio.enemyDeath.play();\r\n        hero.xp += 15;\r\n        this.alive = false;\r\n        this.deadOnScreen = true;\r\n    }\r\n};",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar level = (function () {\r\n\r\n    var maxVy = 10; // applys to GameObj's and GameItem's\r\n\r\n\r\n    /********** Update **********/\r\n    function updateObjsView() {\r\n        for (var i = 0; i < level.objs.length; ++i) {\r\n            level.objs[i].pos.x -= hero.vX;\r\n\r\n            if(level.objs[i].type === JQObject.SCALEBG) {\r\n                level.objs[i].x2 -= hero.vX;\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    function updateItemsView() {\r\n        for (var i = 0; i < level.items.length; ++i) {\r\n            level.items[i].pos.x -= hero.vX;\r\n        }\r\n    }\r\n\r\n    function updateBgView() {\r\n        // color layer\r\n        level.bgColor.gradX -= hero.vX;\r\n        level.bgColor.fillStyle = Graphics.getDoorBgGrad();\r\n\r\n        // objects\r\n        for(var i = 0; i < level.bg.length; ++i) {\r\n            level.bg[i].pos.x -= hero.vX / level.bg[i].speed;\r\n        }\r\n\r\n    }\r\n\r\n    function updateEnemiesView() {\r\n        for (var i = 0; i < level.enemies.length; ++i) {\r\n            level.enemies[i].pos.x -= hero.vX;\r\n        }\r\n    }\r\n\r\n\r\n    function updateItems() {\r\n        for (var i = 0; i < level.items.length; ++i) {\r\n            if (level.items[i].visible && !level.items[i].isOnObj) {\r\n                // gravity/position\r\n                if (level.items[i].vY < maxVy)\r\n                    level.items[i].vY += game.gravity;\r\n                else\r\n                    level.items[i].vY = maxVy;\r\n\r\n                level.items[i].pos.y += level.items[i].vY;\r\n\r\n                // obj collision\r\n                Physics.testObjObjs(level.items[i], function(r) {\r\n                    // a is level.items[i]\r\n                    // b is in level.objs\r\n\r\n                    r.a.pos.x -= r.overlapV.x;\r\n                    r.a.pos.y -= r.overlapV.y;\r\n\r\n                    if (r.overlapN.y === 1) {    // on top of platform\r\n                        audio.thud.play();\r\n                        r.a.vY = 0;\r\n                        r.a.isOnObj = true;\r\n                        r.a.recentlyHeld = false;\r\n\r\n                        if(r.b.type === JQObject.SCALE && r.b.holdingItem === null) {\r\n                            r.a.grabbable = false;\r\n                            r.b.holdingItem = r.a;\r\n\r\n                            utils.repeatAction(42, 14, function () {\r\n                                if(r.b.side === Dir.LEFT) {\r\n                                    ++r.a.pos.y;\r\n                                    ++r.b.pos.y;\r\n\r\n                                    ++r.b.hBar.pos.y;\r\n\r\n                                    --r.b.otherSide.pos.y;\r\n                                    --r.b.hBar.y2;\r\n\r\n                                    if(r.b.otherSide.holdingItem !== null) {\r\n                                        --r.b.otherSide.holdingItem.pos.y;\r\n                                        // TODO: chain of crates on top\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    ++r.a.pos.y;\r\n                                    ++r.b.pos.y;\r\n\r\n                                    ++r.b.hBar.y2;\r\n\r\n                                    --r.b.hBar.pos.y;\r\n                                    --r.b.otherSide.pos.y;\r\n\r\n                                    if(r.b.otherSide.holdingItem !== null) {\r\n                                        --r.b.otherSide.holdingItem.pos.y;\r\n                                        // TODO: chain of crates on top\r\n                                    }\r\n                                }\r\n\r\n                            });\r\n                        }\r\n                    }\r\n\r\n                });\r\n\r\n                // item collision\r\n                Physics.testItemItems(level.items[i], function (r) {\r\n                    r.a.isOnObj = true;\r\n                    r.a.onObj = r.b;\r\n                    r.b.grabbable = false;\r\n                    r.a.recentlyHeld = false;\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    function updateEnemies() {\r\n        for (var i = 0; i < level.enemies.length; ++i) {\r\n            level.enemies[i].update();\r\n\r\n            // TODO: move to hero??\r\n\r\n            if(level.enemies[i].health > 0) {\r\n                // hero and enemy\r\n                if(SAT.testPolygonPolygon(hero, level.enemies[i])) {\r\n                    level.enemies[i].active = true;\r\n\r\n                    if(!hero.invincible) {\r\n                        audio.play(audio.heartbeat, true);\r\n\r\n                        hero.invincible = true;\r\n                        --hero.health;\r\n                    }\r\n                }\r\n\r\n                // projectiles and enemy\r\n                for (var j = 0; j < hero.bulletArr.length; ++j) {\r\n                    if(SAT.testPolygonPolygon(hero.bulletArr[j], level.enemies[i])) {\r\n                        audio.play(audio.thud, true);\r\n                        level.enemies[i].active = true;\r\n\r\n                        hero.bulletArr.splice(j, 1); // remove jth item\r\n                        --level.enemies[i].health;\r\n\r\n                        if (level.enemies[i].health <= 0) {\r\n                            level.enemies[i].death();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /********** Render **********/\r\n    // the parallax background\r\n    function drawBg() {\r\n        // color background\r\n        ctx.fillStyle = \"#000\";\r\n        ctx.fillRect(0, FULLH - game.padFloor, FULLW, game.padFloor);\r\n        ctx.fillStyle = level.bgColor.fillStyle;\r\n        ctx.fillRect(0, 0, FULLW, FULLH - game.padFloor);\r\n\r\n        // background objects\r\n        for (var i = 0; i < level.bg.length; ++i) {\r\n            //level.bg[i].draw();\r\n            var t = level.bg[i];\r\n            var scale = utils.speed2scale(t.speed);\r\n\r\n            ctx.drawImage(t.img, t.pos.x, t.pos.y, t.w * scale, t.h * scale);\r\n        }\r\n    }\r\n\r\n    // all of the collision rectangles in the level\r\n    function drawObjs() {\r\n        for (var i = 0; i < level.objs.length; ++i) {\r\n            var obj = level.objs[i];\r\n\r\n            // check if visible; TODO: all objs should have visible property (fix api)\r\n            if (typeof (obj.visible) !== \"undefined\" && !obj.visible) {\r\n                continue;\r\n            }\r\n            \r\n\r\n            if(obj.type === JQObject.LADDER) {           // ladder\r\n                Graphics.drawLadder(obj);\r\n            }\r\n            else if(obj.type === JQObject.SCALE) {       // scale\r\n                Graphics.drawScale(obj);\r\n                Graphics.drawPlatformStatus(obj);\r\n            }\r\n            else if(obj.type === JQObject.PLATFORM || obj.type === JQObject.SLOPE || obj.type === JQObject.ELEVATOR) {\r\n                Graphics.drawPlatform(obj);\r\n            }\r\n            else if(obj.type === JQObject.DOOR) {\r\n                Graphics.drawDoor(obj);\r\n            }\r\n            else if(obj.type === JQObject.POLY) {\r\n                Graphics.drawPoly(obj);\r\n            }\r\n            else if(obj.type === JQObject.HILL) {\r\n                Graphics.drawHill(obj);\r\n            }\r\n            else {\r\n                obj.draw();\r\n            }\r\n        }\r\n    }\r\n\r\n    function drawItems() {\r\n        for (var i = 0; i < level.items.length; ++i) {\r\n            level.items[i].draw();\r\n        }\r\n    }\r\n\r\n    function drawEnemies() {\r\n        for (var i = 0; i < level.enemies.length; ++i) {\r\n            if (!level.enemies[i].deadOffScreen) {\r\n                level.enemies[i].draw();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return {\r\n        bgColor: {},\r\n        bg: [],             // dynamically holds all of the background objects for the level\r\n        objs: [],           // dynamically holds all of the objects for the level\r\n        items: [],          // dynamically holds all of the items for the level\r\n        enemies: [],        // dynamically holds all of the enemies for the level\r\n        curLvl: null,       // alias for the current level object e.g. lvl1\r\n        isCutscene: false,\r\n        time: 0,\r\n        hiddenItemsFound: 0,\r\n        hiddenItems: 0,\r\n        isTransitioning: false,\r\n        \r\n\r\n        init: function() {\r\n            level.reset();\r\n            level.curLvl = new StartScreen();     // level '0'\r\n        },\r\n\r\n        // called before start of level\r\n        reset: function () {\r\n            // reset game stats\r\n            game.over = false;\r\n            game.actualTime = 0;\r\n\r\n            // reset level\r\n            level.hiddenItemsFound = 0;\r\n            hero.lvlX = 0;\r\n            level.bgColor = {\r\n                fillStyle: \"#000\"\r\n            };\r\n            level.bg = [];\r\n            level.objs = [];\r\n            level.items = [];\r\n            level.enemies = [];\r\n\r\n            // reset hero\r\n            hero.pos.x = 23;\r\n            hero.pos.y = FULLH - game.padFloor - hero.h + 4;    // TODO: find out '4' offset??\r\n            hero.vX = hero.vY = 0;\r\n            hero.isJumping = false;\r\n            hero.bulletArr.length = 0;\t\t// prevents leftover thrown shurikens\r\n            hero.invincible = false;\r\n            hero.isHolding = false;\r\n            hero.curItem = null;\r\n            hero.dir = Dir.RIGHT;\r\n            hero.health = hero.maxHealth;\r\n        },\r\n\r\n        // called at end of level\r\n        complete: function () {\r\n            level.isTransitioning = true;\r\n            audio.lvlComplete();\r\n\r\n            // reset graphics timers (to fix blink text)\r\n            Graphics.ticker = 1;\r\n            Graphics.fadeOut = true;\r\n\r\n            Graphics.fadeCanvas(function () {\r\n                level.isTransitioning = false;\r\n\r\n                level.curLvl = lvlComplete;\r\n                level.isCutscene = true;\r\n                level.time = game.actualTime;\r\n\r\n                // TODO: audio.lvlCompleted.play()\r\n            });\r\n        },\r\n\r\n        /******************** Update ********************/\r\n        update: function () {\r\n            if (!level.isTransitioning) {\r\n                updateItems();\r\n                updateEnemies();\r\n\r\n                level.curLvl.update();\r\n            }\r\n        },\r\n\r\n        // fix positions relative to the \"camera\" view\r\n        updateView: function(){\r\n            updateObjsView();\r\n            updateItemsView();\r\n            updateBgView();\r\n            updateEnemiesView();\r\n        },\r\n\r\n\r\n        /******************** Render ********************/\r\n        render: function () {\r\n            drawBg();\r\n            drawObjs();\r\n            drawItems();\r\n            drawEnemies();\r\n            \r\n            level.curLvl.render();\r\n        }\r\n    };\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar lvlComplete = (function () {\r\n\r\n    return {\r\n        update: function () {\r\n            if (keysDown[KeyCode.ENTER] || game.lvl === 0 || window.DEBUG) {\r\n                lastKeyDown = KeyCode.EMPTY;\r\n\r\n                level.reset();\r\n\r\n                switch (++game.lvl) {\r\n                    case 1:\r\n                        lvl1.init();\r\n                        level.curLvl = lvl1;\r\n                        break;\r\n                    case 2:\r\n                        lvl2.init();\r\n                        level.curLvl = lvl2;\r\n                        break;\r\n                }\r\n\r\n                level.isCutscene = false;\r\n            }\r\n        },\r\n\r\n        render: function () {\r\n            // background\r\n            ctx.fillStyle = \"#000\";\r\n            ctx.fillRect(0, 0, FULLW, canvas.height);\r\n\r\n            // title\r\n            ctx.font = \"24px 'Press Start 2P'\";\r\n            var title = \"LEVEL \" + game.lvl + \" COMPLETE\";\r\n            var titleW = ctx.measureText(title).width;\r\n            ctx.fillStyle = Color.ORANGE;\r\n            ctx.fillText(title, HALFW - titleW/2, 70);\r\n            \r\n            // level time\r\n            ctx.font = \"18px 'Press Start 2P'\";\r\n            var time = utils.getTimeObj(level.time);\r\n            var timeTxt = \"LEVEL TIME......\" + time.min + ':' + time.sec;\r\n            var timeW = ctx.measureText(timeTxt).width;\r\n            ctx.fillStyle = \"#e1e1e1\";\r\n            ctx.fillText(timeTxt, HALFW - titleW / 2, 150);\r\n\r\n            // hidden items\r\n            ctx.font = \"18px 'Press Start 2P'\";\r\n            var hdnItems = \"HIDDEN ITEMS.....\" + level.hiddenItemsFound + '/' + level.hiddenItems;\r\n            var hdnItemsW = ctx.measureText(hdnItems).width;\r\n            ctx.fillStyle = \"#e1e1e1\";\r\n            ctx.fillText(hdnItems, HALFW - hdnItemsW / 2, 190);\r\n\r\n            // cta\r\n            Graphics.blinkText(16, HALFW, HALFH + 120);\r\n        }\r\n    };\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\n// level '0'\r\nfunction StartScreen() {\r\n    this.width = FULLW;\r\n\r\n    level.isCutscene = true;\r\n}\r\n\r\nStartScreen.prototype = (function() {\r\n    var copyTitle1 = \"JON'S\",\r\n        copyTitle2 = \"QUEST\",\r\n        copyLine = String.fromCharCode(\"169\") + \" 2013 JON WIEDMANN\"\r\n    ;\r\n\r\n    return {\r\n        update: function(){\r\n            if (lastKeyDown === KeyCode.ENTER) {\r\n                level.complete();\r\n            }\r\n        },\r\n\r\n        render: function(){\r\n            //---- title\r\n\r\n            // title 1\r\n            ctx.font = \"29px 'Press Start 2P'\";\r\n            var startX = HALFW - ctx.measureText(copyTitle1).width / 2 + 11,\r\n                startY = 58;\r\n\r\n            ctx.setTransform(1, 0, -0.4, 1.4, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('J', startX + 4, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('J', startX, startY);\r\n            ctx.setTransform(1, 0, -0.2, 1.4, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('O', startX + 32, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('O', startX + 28, startY);\r\n            ctx.setTransform(1, 0, 0.05, 1.41, 0, -1);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('N', startX + 58, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('N', startX + 54, startY);\r\n            ctx.setTransform(1, 0, 0.23, 1.4, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText(\"'\", startX + 78, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText(\"'\", startX + 74, startY);\r\n            ctx.setTransform(1, 0, 0.42, 1.4, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('S', startX + 95, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('S', startX + 91, startY);\r\n\r\n\r\n            // title 2\r\n            ctx.font = \"36px 'Press Start 2P'\";\r\n            startX = HALFW - ctx.measureText(copyTitle2).width / 2 + 30;\r\n            startY = 98;\r\n\r\n            ctx.setTransform(1, 0, -0.5, 1.6, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('Q', startX + 4, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('Q', startX, startY);\r\n            ctx.setTransform(1, 0, -0.25, 1.6, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('U', startX + 26, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('U', startX + 22, startY);\r\n            ctx.setTransform(1, 0, 0.03, 1.6, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('E', startX + 50, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('E', startX + 46, startY);\r\n            ctx.setTransform(1, 0, 0.25, 1.6, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('S', startX + 74, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('S', startX + 70, startY);\r\n            ctx.setTransform(1, 0, 0.5, 1.6, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('T', startX + 90, startY + 4);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('T', startX + 86, startY);\r\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\t// reset\r\n\r\n            //---- press enter\r\n            Graphics.blinkText(22, HALFW, HALFH + 81);\r\n\r\n            //---- copyright\r\n            ctx.fillStyle = \"#000\";\r\n            ctx.fillRect(0, FULLH, FULLW, game.padHUD);\r\n            ctx.font = \"13px 'Press Start 2P'\";\r\n            ctx.fillStyle = \"#c9c9c9\";\r\n\r\n            ctx.fillText(copyLine, HALFW - ctx.measureText(copyLine).width / 2, FULLH + 24);\r\n        }\r\n    };\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar lvl1 = (function () {\r\n\r\n    var hiddenCash,\r\n\t\tdoor,\r\n        ladder,\r\n        doLadder = false,\r\n        scales = [],\r\n        vBar,\r\n        hBar\r\n    ;\r\n\r\n    function handleScale() {\r\n        var numCratesOnScales = 0;\r\n\r\n        for (var i = 0; i < level.objs.length; ++i) {\r\n            if (level.objs[i].type === JQObject.SCALE &&\r\n                typeof (level.objs[i].holdingItem) !== \"undefined\" && level.objs[i].holdingItem !== null &&\r\n                level.objs[i].holdingItem.type === JQObject.CRATE\r\n            ) {\r\n                ++numCratesOnScales;\r\n            }\r\n        }\r\n\r\n        doLadder = (numCratesOnScales === 2);\r\n\r\n        if(doLadder) {\r\n            audio.discovery.play();\r\n\r\n            var result = $.grep(level.objs, function (e) {\r\n                return e.type === JQObject.LADDER;\r\n            });\r\n            result[0].visible = true;\r\n        }\r\n    }\r\n\r\n\r\n    function setBackground() {\r\n        //---- color layer\r\n        level.bgColor.gradX = door.pos.x + door.w/2;\r\n        level.bgColor.gradY = door.pos.y + door.h/2;\r\n\r\n        level.bgColor.fillStyle = Graphics.getDoorBgGrad();\r\n\r\n        //---- objects\r\n        Graphics.setClouds();\r\n    }\r\n\r\n    function setObjs() {\r\n        // floor + 3 initial platforms\r\n        level.objs.push(\r\n            new GameObj(JQObject.PLATFORM, -Graphics.projectX, FULLH - game.padFloor - 1, lvl1.width + Graphics.projectX * 2, game.padFloor + 1),\r\n            new GameObj(JQObject.PLATFORM, 200, 206, 267, 62),\r\n            new GameObj(JQObject.PLATFORM, 575, 310, 300, 62),\r\n            new GameObj(JQObject.PLATFORM, 605, 125, 220, 62)\r\n        );\r\n\r\n        // scales\r\n        for(var i = 0; i < 2; ++i) {\r\n            scales[i] = new GameObj(JQObject.SCALE, 1500 + i * 300, FULLH - game.padFloor - 137, 150, 46);\r\n            scales[i].holdingItem = null;//JQObject.EMPTY; // TODO: fix api\r\n        }\r\n\r\n        vBar = new GameObj(JQObject.SCALEBG, \r\n            scales[0].pos.x + scales[0].w + 70, \r\n            HALFH - game.padFloor,\r\n            10,\r\n            HALFH\r\n        );\r\n        vBar.collidable = false;\r\n\r\n        hBar = new GameObj(JQObject.SCALEBG,\r\n            scales[0].pos.x + scales[0].w / 2,\r\n            HALFH,\r\n            300,\r\n            10\r\n        );\r\n        hBar.x2 = hBar.pos.x + hBar.w;\r\n        hBar.y2 = hBar.pos.y;\r\n        hBar.collidable = false;\r\n        hBar.visible = false;\r\n\r\n        scales[0].hBar = hBar;\r\n        scales[0].side = Dir.LEFT;\r\n        scales[0].otherSide = scales[1];\r\n\r\n        scales[1].hBar = hBar;\r\n        scales[1].side = Dir.RIGHT;\r\n        scales[1].otherSide = scales[0];\r\n\r\n        level.objs.push(vBar, hBar, scales[0], scales[1]);\r\n\r\n\r\n        // stairs, platform, and door\r\n        var stairs = new GameObj(JQObject.SLOPE, 2143, 208, 252, 62);\r\n        var doorPlat = new GameObj(JQObject.PLATFORM, stairs.pos.x + stairs.w - 11, stairs.pos.y - stairs.h - 5, 200, 62);\r\n        door = new GameObj(JQObject.DOOR, doorPlat.pos.x + doorPlat.w - 63, doorPlat.pos.y - 62 - Graphics.projectY / 2, 33, 62);\r\n        level.objs.push(doorPlat, stairs, door);\r\n\r\n        // TODO: move to setItems() ??\r\n        ladder = new GameItem(new GameObj(JQObject.LADDER, stairs.pos.x - 37, stairs.pos.y - 1, 38, FULLH - stairs.pos.y - game.padFloor), false, 0, false);\r\n        ladder.collidable = false;      // allows ladder to not be in normal collision detection\r\n        level.objs.push(ladder);\r\n\r\n    }\r\n\r\n    function setItems() {\r        // crates\r        var crate = [];\r        for (var i = 0; i < 3; ++i) {\r\n            crate.push(\r\n                new GameItem(\r\n                    new GameObj(JQObject.CRATE, 446, FULLH - game.padFloor - 26 + 5, 34, 37, \"crate.png\"),\r\n                    true\r\n                )\r\n            );\r\n        }\r\n        crate[1].pos.x = scales[0].pos.x + scales[0].w / 2 - crate[0].w / 2;\r\n        crate[2].pos.x = scales[1].pos.x + scales[1].w / 2 - crate[0].w / 2;\r\r        // sack\r\n        var sack = new GameItem(new GameObj(JQObject.SACK, 680, 111 + Graphics.projectY / 2, 30, 34, \"sack.png\"), false, 5);\r\n\r\n        // hidden cash; TODO: only add to level.items after visible???\r\n        hiddenCash = new GameItem(new GameObj(JQObject.CASH, 113, 80, 22, 24, \"cash.png\"), false, 10, false);\r\n\r\n        level.items.push(crate[0], crate[1], crate[2], sack, hiddenCash);\r\n    }\r\n\r\n    function setEnemies() {\r\n        var cyborg = new Enemy(\r\n            new GameObj(JQObject.ENEMY, 1200, FULLH - game.padFloor - 55 + Graphics.projectY/2, 40, 55, \"cyborgBnW.png\"),\r\n            JQEnemy.FOLLOW,\r\n            1,\r\n            1087,\r\n            1600,\r\n            false\r\n        );\r\n        cyborg.collidable = false;  // TODO: fix api\r        level.enemies.push(cyborg);\r\n    }\r\n\r\n    function drawScaleChains(x, y, scale) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(x, y);\r\n        ctx.lineTo(scale.pos.x, scale.pos.y);\r\n        ctx.stroke();\r\n        ctx.closePath();\r\n\r\n        ctx.beginPath();\r\n        ctx.moveTo(x, y);\r\n        ctx.lineTo(scale.pos.x + scale.w / 2, scale.pos.y);\r\n        ctx.stroke();\r\n        ctx.closePath();\r\n\r\n        ctx.beginPath();\r\n        ctx.moveTo(x, y);\r\n        ctx.lineTo(scale.pos.x + scale.w, scale.pos.y);\r\n        ctx.stroke();\r\n        ctx.closePath();\r\n    }\r\n\r\n\r\n    return {\r\n        width: 2650,\r\n\r\n\r\n        init: function () {\r\n            level.hiddenItems = 1;\r\n\r            setObjs();\r            setItems();\r\n            setEnemies();\r\n\r\n            setBackground();\r\n        },\r\n\r\n        deinit: function(){\r\n            hiddenCash = null;\r\n            door = null;\r\n            ladder = null;\r\n            doLadder = false;\r\n        },\r\n\r\n        update: function () {\r\n            // TODO: move to better location\r\n            if (window.DEBUG) {\r\n                level.complete();\r\n            }\r\n\r\n            if(doLadder) {\r\n                hero.onLadder = SAT.testPolygonPolygon(hero, ladder);\r\n            }\r\n            else {\r\n                handleScale();\r\n            }\r\n\r\n            // hidden cash\r\n            if (!hiddenCash.visible) {\r\n                for (var i = 0; i < hero.bulletArr.length; ++i) {\r\n                    if (Physics.isCollision(hero.bulletArr[i], hiddenCash, -17)) {\r\n                        hiddenCash.visible = true;\r\n                        audio.discovery.play();\r\n                        ++level.hiddenItemsFound;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // door\r\n            if (!game.over && Physics.isCollision(hero, door, 0)) {     // TODO: why checking game.over???\r\n                level.complete();\r\n            }\r\n\r\n            //hBar.x2 -= hero.vX;\r\n        },\r\n\r\n        render: function () {\r\n            ctx.fillStyle = \"#000\";\r\n            ctx.fillRect(vBar.x, vBar.y, vBar.w, vBar.h);   // vBar\r\n\r\n            ctx.strokeStyle = \"#000\";\r\n            ctx.lineWidth = 10;\r\n\r\n            // hBar\r\n            ctx.beginPath();\r\n            ctx.moveTo(hBar.pos.x, hBar.pos.y);\r\n            ctx.lineTo(hBar.x2, hBar.y2);\r\n            ctx.stroke();\r\n            ctx.closePath();\r\n            \r\n            // left scale\r\n            drawScaleChains(hBar.pos.x, hBar.pos.y, scales[0]);\r\n\r\n            // right scale\r\n            drawScaleChains(hBar.x2, hBar.y2, scales[1]);\r\n        }\r\n    };\r\n\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar lvl2 = (function () {\r\n\r\n    var elevator = [];\r\n\r\n    function setBackground() {\r\n        level.bgColor.gradX = 0;\r\n        level.bgColor.gradY = 0;\r\n\r\n        level.bgColor.fillStyle = Graphics.getDoorBgGrad();\r\n        Graphics.setClouds();\r\n    }\r\n\r\n    function setObjs() {\r\n        // floor\r\n        var floor1 = new GameObj(\r\n            JQObject.PLATFORM,\r\n            -Graphics.projectX,\r\n            FULLH - game.padFloor,\r\n            FULLW / 3 + 40,\r\n            game.padFloor\r\n        );\r\n\r\n        var floor2 = new GameObj(\r\n            JQObject.PLATFORM,\r\n            HALFW,\r\n            FULLH - game.padFloor,\r\n            120,\r\n            game.padFloor\r\n        );\r\n\r\n        var floorPlat = new GameObj(\r\n            JQObject.PLATFORM,\r\n            floor2.pos.x + floor2.w - Graphics.projectX,\r\n            floor2.pos.y - floor2.h - 30,\r\n            900,\r\n            180\r\n        );\r\n\r\n        var colL = new GameObj(\r\n            JQObject.PLATFORM,\r\n            floorPlat.pos.x + floor2.w,\r\n            floorPlat.pos.y - 90 + Graphics.projectY,\r\n            100,\r\n            85\r\n        );\r\n\r\n        var colR = new GameObj(\r\n            JQObject.PLATFORM,\r\n            floorPlat.pos.x + floor2.w + 680,\r\n            floorPlat.pos.y - 90 + Graphics.projectY,\r\n            100,\r\n            85\r\n        );\r\n\r\n        var bridge = new GameObj(\r\n            JQObject.PLATFORM,\r\n            colL.pos.x + 170,\r\n            colL.pos.y - 135,\r\n            443,\r\n            30\r\n        );\r\n\r\n        level.objs.push(\r\n            floorPlat,\r\n            floor1,\r\n            floor2,\r\n            colL,\r\n            colR,\r\n            bridge\r\n        );\r\n\r\n        // elevators\r\n        for(var i = 0; i < 3; ++i) {\r\n            elevator[i] = new GameObj(JQObject.ELEVATOR, colR.pos.x + 200 + i * 300, colR.pos.y - i*50, 200, 40);\r\n            elevator[i].dir = Dir.DOWN;\r\n            level.objs.push(elevator[i]);\r\n        }\r\n\r\n\r\n        var hillArr = Graphics.getHill(bridge.pos.x + 140, bridge.pos.y + 6, 180, 40);\r\n        for(var i = 0; i < hillArr.length; ++i) {\r\n            hillArr[i].type = JQObject.HILL;\r\n            level.objs.push(hillArr[i]);\r\n        }\r\n\r\n\r\n        // after elevators\r\n        var aPlat = new GameObj(\r\n            JQObject.PLATFORM,\r\n            elevator[2].pos.x + 270,\r\n            FULLH - game.padFloor,\r\n            943,\r\n            game.padFloor\r\n        );\r\n        level.objs.push(aPlat);\r\n\r\n        var hillArr2 = Graphics.getHill(aPlat.pos.x + 400, floor1.pos.y + 6, 280, 70);\r\n        for(var i = 0; i < hillArr.length; ++i) {\r\n            hillArr2[i].type = JQObject.HILL;\r\n            level.objs.push(hillArr2[i]);\r\n        }\r\n\r\n        //var hill = new SAT.Polygon(new SAT.Vector(aPlat.pos.x + 400, floor1.pos.y + 6, 280, 70), [\r\n            \r\n        //]);\r\n\r\n    }\r\n\r\n    function setItems() {\r\n        //var crate = new GameItem(\r\n        //    new GameObj(JQObject.CRATE, 206, FULLH - game.padFloor - 26 + 5, 24, 26, \"crate.png\"),\r\n        //    true\r\n        //);\r\n\r\n        var sack = new GameItem(\r\n            new GameObj(JQObject.SACK, 1200, 302, 30, 36, \"sack.png\"),\r\n            true,\r\n            5\r\n        );\r\n\r\n        level.items.push(sack);\r\n    }\r\n\r\n    function setEnemies(f2) {\r\n        var enemy = new Enemy(\r\n            new GameObj(JQObject.ENEMY, 834, 404, 40, 55, \"cyborgBnW.png\"),\r\n            JQEnemy.PATROL,\r\n            1,\r\n            834,\r\n            1369,\r\n            true\r\n        );\r\n        enemy.collidable = true;        // TODO: fix api\r\n        level.enemies.push(enemy);\r\n    }\r\n\r\n    return {\r\n        width: 3700,\r\n\r\n\r\n        init: function () {\r\n            level.hiddenItems = 0;\r\n\r\n            setBackground();\r\n            setObjs();\r\n            setItems();\r\n            setEnemies();\r\n        },\r\n\r\n        deinit: function(){\r\n            \r\n        },\r\n\r\n        update: function() {\r\n            // elevators\r\n            for(var i = 0; i < elevator.length; ++i) {\r\n                if(elevator[i].dir === Dir.UP && elevator[i].pos.y < 100) {\r\n                    elevator[i].dir = Dir.DOWN;\r\n                }\r\n                else if(elevator[i].dir === Dir.DOWN && elevator[i].pos.y > 400) {\r\n                    elevator[i].dir = Dir.UP;\r\n                }\r\n\r\n                elevator[i].vY = (elevator[i].dir === Dir.DOWN) ? 1 : -1;   // used by hero\r\n                elevator[i].pos.y += elevator[i].vY;\r\n            }\r\n\r\n        },\r\n\r\n        render: function() {\r\n\r\n        }\r\n    };\r\n})();",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar game = (function () {\r\n\tvar\tavgFPS = 0,\r\n        renderTimePrev = 0,\r\n        renderTimeBtw = 16,\r\n\t\tfpsHistory = [60],\r\n        updateFpsHistory = [120],\r\n        updateTimePrev = 0,\r\n        updateTimeBtw = 8,\r\n        //lag = 0,\r\n        renderLoop,\r\n        updateLoop\r\n\t;\r\n\t\r\n\tfunction update() {\r\n//\t    var updateTimeCur = new Date().getTime();\r\n\r\n//\t    // timers\r\n//\t    if((updateTimeCur - updateTimePrev) > 0) {\r\n//\t        updateTimeBtw = updateTimeCur - updateTimePrev;\r\n////\t        console.log(updateTimeBtw);\r\n//\t    }\r\n//\t    updateTimePrev = updateTimeCur;\r\n\r\n\r\n\t    if (!level.isCutscene && !level.isTransitioning && !game.over) {\r\n\t        hero.update();\r\n\t    }\r\n\r\n\t\tlevel.update();\r\n\t}\r\n\t\r\n\tfunction render(renderTimeCur) {\r\n        // timers\r\n\t    if ((renderTimeCur - renderTimePrev) > 0) {\r\n\t        renderTimeBtw = renderTimeCur - renderTimePrev;\r\n\t    }\r\n\t    renderTimePrev = renderTimeCur;\r\n\r\n\r\n\t    renderLoop = requestAnimFrame(render);\r\n\r\n        \r\n\t    // drawing\r\n\t    level.render();\r\n\r\n\t    if (!level.isCutscene) {\r\n            if(!game.over)\r\n                hero.render();\r\n\r\n\t        HUD.draw();\r\n\t        drawFPS();\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction drawFPS(fps) {\r\n\t    fpsHistory.push(1000 / renderTimeBtw);\r\n\t    \r\n    \tif (game.totalTicks % 120 === 0) {\r\n    \t    var tot = 0,\r\n                i = fpsHistory.length\r\n    \t    ;\r\n    \t    \r\n    \t    while (--i) {\r\n        \t\ttot += fpsHistory[i];\r\n        \t}\r\n    \t    \r\n    \t    if (fpsHistory.length > 0) {\r\n    \t        avgFPS = Math.floor(tot / fpsHistory.length);\r\n    \t    }\r\n    \t    else {\r\n    \t        avgFPS = 0;\r\n    \t    }\r\n\r\n    \t    while (fpsHistory.length > 0) {\r\n    \t        fpsHistory.pop();\r\n    \t    }\r\n        }\r\n    \t\r\n    \tctx.fillStyle = \"#ddd\";\r\n    \tctx.font = \"11px 'Press Start 2P'\";\r\n\t  \tctx.fillText(avgFPS + \" FPS\", FULLW - 77, FULLH + 50);\r\n\t}\r\n   \t\r\n\r\n\treturn {\r\n        over: false,        // indicates the game is finished\r\n\t    gravity: 0.13,\r\n\t    padHUD: 58,\r\n\t    padFloor: 16,\r\n\t    lvl: 0,\r\n\t    totalTicks: 0,      // ticks are update iterations\r\n\t    actualTime: 0,\r\n\r\n\r\n\t    start: function () {\r\n            // update at fixed time interval\r\n\t        updateLoop = setInterval(function () {\r\n\t            ++game.totalTicks;\r\n\t            Graphics.ticker += Graphics.fadeOut ? -Graphics.tickerStep : Graphics.tickerStep;\r\n\r\n\t            //var updateTimeCur = new Date().getTime();\r\n\r\n\t            //if ((updateTimeCur - updateTimePrev) > 0) {\r\n\t            //game.updateTimeBtw = updateTimeCur - updateTimePrev;\r\n\t            //}\r\n\r\n\t            //updateTimePrev = updateTimeCur;\r\n\t            //lag += game.updateTimeBtw;\r\n\r\n\t            //while (lag >= game.updateTimeBtw) {      // TODO: interpolate if needed\r\n\t            update();\r\n\t            //lag -= game.updateTimeBtw;\r\n\t            //}\r\n\t        }, 8.3333); // 1000 / 120 ==> 2x target rate of 60fps\r\n\t        \r\n            // render w/vsync (let browser decide)\r\n\t        render();\r\n\t    },\r\n\r\n\t    stop: function () {\r\n\t        window.cancelAnimationFrame(renderLoop);\r\n\t        clearInterval(updateLoop);\r\n\t    }\r\n\t};\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar Shuriken = {\r\n    w: 31,\r\n    h: 31,\r\n    speed: 4.4\r\n};\r\n\r\n// The hero object.  TODO: convert to be of GameObj type\r\nvar hero = (function () {\r\n    var input = null,           // the hero input component\r\n        graphics = null,        // the hero graphics component\r\n        physics = null,         // the hero physics component\r\n        imgReady = false,\r\n\t\timg = null,\r\n\t\tspriteArr = [],\r\n\t\tinvincibleTimer = 170,\r\n        invincibleTimer0 = 170\r\n\t;\r\n\t\r\n\t\t\r\n\t/*********************** Update ***********************/\r\n    function checkHealth() {\r\n        if (hero.invincible)\r\n            --invincibleTimer;\r\n\r\n        if (invincibleTimer <= 0) {\r\n            hero.invincible = false;\r\n            invincibleTimer = invincibleTimer0;\r\n        }\r\n        \r\n        if (hero.health <= 0 && !game.over) {\r\n            utils.deathSequence();\r\n        }\r\n    }\r\n\r\n    function getSpritePos() {\r\n\t\tvar pos = {x: 0, y: 0};\r\n\t\t\r\n\t\tif (hero.isHolding && hero.vX === 0) {\r\n\t\t\tpos = spriteArr[\"playerDown\"];\r\n\t\t}\r\n\t\telse if (hero.onLadder) {               // TODO: check if holding crate (shouldn't be allowed on ladder)\r\n\t\t    pos = spriteArr[\"playerUp\"];\r\n\t\t}\r\n\t\telse if (hero.dir === Dir.RIGHT || hero.dir === Dir.LEFT) {\r\n\t\t    var dirR = (hero.dir === Dir.RIGHT);\r\n\t\t    var theDir = \"player\" + (dirR ? \"Right\" : \"Left\");\r\n\r\n\t\t    if (dirR && hero.vX > 0 ||  // right\r\n\t\t        !dirR && hero.vX < 0    // left\r\n            ) {\r\n\t\t        var runTimer = (game.totalTicks % 96);\r\n\r\n\t\t        if(!hero.isOnObj){\r\n\t\t            pos = spriteArr[theDir + \"_Run1\"];\r\n\t\t        }\r\n                else if(Math.abs(hero.vX) <= hero.aX*10){\r\n\t\t            pos = spriteArr[theDir + \"_Step\"];\r\n\t\t        }\r\n\t\t        else if(runTimer >= 0 && runTimer < 24) {\r\n\t\t            pos = spriteArr[theDir + \"_Run1\"];\r\n\r\n\t\t            if(!hero.isJumping) {\r\n\t\t                audio.step.play();\r\n\t\t            }\r\n\t\t        }\r\n\t\t        else if (runTimer >= 24 && runTimer < 48) {\r\n\t\t            pos = spriteArr[theDir + \"_Run2\"];\r\n\t\t        }\r\n\t\t        else if(runTimer >= 48 && runTimer < 72){\r\n\t\t            pos = spriteArr[theDir + \"_Run3\"];\r\n\r\n\t\t            if(!hero.isJumping) {\r\n\t\t                audio.step.play();\r\n\t\t            }\r\n\t\t        }\r\n\t\t        else {\r\n\t\t            pos = spriteArr[theDir + \"_Run2\"];\r\n\t\t        }\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tpos = spriteArr[theDir];\r\n\t\t}\r\n\t\t\r\n        // idle animation\r\n\t\tif(!hero.onLadder && hero.vX === 0 && hero.vY === 0) {\r\n\t\t    ++hero.idleTime;\r\n\t\t}\r\n\t\telse {\r\n\t\t    hero.idleTime = 0;\r\n\t\t}\r\n\r\n\t\tif (hero.idleTime > 210) {\r\n\t\t    var foo = hero.idleTime % 200;\r\n\t\t    \r\n\t\t    if (foo >= 0 && foo <= 50 || foo > 100 && foo <= 150 || hero.isHolding)\r\n\t\t        pos = spriteArr[\"playerDown\"];\r\n\t\t    else if (foo > 50  && foo <= 100)\r\n\t\t        pos = spriteArr[\"playerDown_breatheIn\"];\r\n\t\t    else if (foo > 150 && foo <= 200)\r\n\t\t        pos = spriteArr[\"playerDown_breatheOut\"];\r\n\t\t}\r\n\r\n        // invincible\r\n\t\tvar inv = invincibleTimer % 40;\r\n\t\t\r\n\t\tif(hero.invincible && (inv >= 0 && inv <= 16)){\r\n\t\t\tpos = {x: -1, y: -1};\r\n\t\t}\r\n\r\n\t\t\r\n\t\thero.sx = pos.x;\r\n\t\thero.sy = pos.y;\r\n\t}\r\n\t\r\n\t/*********************** Render ***********************/\r\n\tfunction drawHero(){\r\n\t    if (imgReady && hero.sx >= 0 && hero.sy >= 0) {\r\n\t\t    ctx.drawImage(img, hero.sx, hero.sy, hero.w, hero.h, Math.round(hero.pos.x), Math.round(hero.pos.y), hero.w, hero.h);\r\n    \t}\r\n\t}\r\n\t\t\r\n    // used to draw things over the hero\r\n\tfunction drawAfterHero() {\r\n\t    if (hero.isHolding) {\r\n\t        hero.curItem.draw();\r\n\t    }\r\n\t}\r\n\t\t\r\n\treturn {\r\n\t\tsx: 0,\t\t\t\t// sprite position\r\n\t\tsy: 0,\r\n\t\tlvlX: 0,\t\t\t\r\n\t\tw: 48,\r\n\t\th: 65,\r\n\t\tvX: 0,              // maxVx/maxVy are in heroInput.js\r\n\t\tvY: 0,\r\n\t\taX: 0.17,\r\n\t\taY: 0.82,\r\n\t\tjumpMod: 4,\r\n\t\tjumpMod0: 4,\r\n        idleTime: 0,\r\n\t\tdir: Dir.RIGHT,\r\n\t\tonLadder: false,\r\n\t\tinvincible: false,\r\n\t\tisJumping: false,\r\n\t\tisHolding: false,\r\n\t\tisOnObj: true,\r\n\t\tcurItem: null,      // the item in hand\r\n\t\thealth: 3,\r\n\t\tmaxHealth: 3,\r\n\t\tmedKits: 1,\r\n\t\thealthLvl: 1,\r\n\t\tmana: 0,\r\n\t\tmaxMana: 4,\r\n\t\tmanaKits: 1,\r\n\t\tmanaLvl: 1,\r\n\t\tammo: 20,\r\n\t\tcash: 0,\r\n\t\tlvl: 1,\r\n\t\txp: 0,\r\n\t\txpNeeded: 50,\r\n\t\tbulletArr: [],\r\n\t\t\r\n\r\n\t\tinit: function(){\r\n\t\t\timg = new Image();\r\n\t\t\timg.onload = function () { imgReady = true; };\r\n\t\t\timg.src = \"/games/common/img/sprites/player/player.png\";\r\n\t\t\t\r\n\t\t\t// grab texturePacker's sprite coords\r\n\t\t\t$.get(\"/games/common/img/sprites/player/player.xml\", function(xml){\r\n\t\t\t\tvar wrap = $(xml).find(\"sprite\");\r\n\t\t\t\t\r\n\t\t\t\t$(wrap).each(function(){\r\n\t\t\t\t\tvar name = $(this).attr('n'),\r\n\t\t\t\t\t\tx = $(this).attr('x'),\r\n\t\t\t\t\t\ty = $(this).attr('y');\r\n\t\t\t\t\t\r\n\t\t\t\t\tname = name.substring(0, name.length-4);\r\n\t\t\t\t\tspriteArr[name] = {x: x, y: y};\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tinput = HeroInputComponent();\r\n\t\t\tphysics = HeroPhysicsComponent();\r\n\t\t\tgraphics = HeroGraphicsComponent();\r\n\r\n            // setup hero bounding box for collision detection\r\n\t\t\t$.extend(hero, new SAT.Box(new SAT.Vector(0, 0), hero.w, hero.h).toPolygon());\r\n\t\t},\r\n\t\t\r\n\t\tupdate: function () {\r\n\t\t    input.check();                      // updates velocities\r\n\t\t\tphysics.updatePosition();          // updates positions\r\n\t\t\tphysics.checkCollision();          // fix positions\r\n\t\t\t\r\n\t\t\tcheckHealth();\r\n\t\t\tgetSpritePos();\r\n\t\t},\r\n\t\r\n\t\trender: function () {\r\n\t\t    drawHero();\r\n\t\t    graphics.drawBullets();\r\n\t\t    drawAfterHero();\r\n\t\t},\r\n\r\n\t\tlanded: function(y) {\r\n\t\t    hero.isOnObj = true;\r\n\t\t    hero.isJumping = false;\r\n\t\t    hero.vY = 0;\r\n\t\t    hero.pos.y -= y;\r\n\t\t}\r\n\t};\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\n/*\r\n    The graphics component of hero.\r\n*/\r\nvar HeroGraphicsComponent = function () {\r\n\r\n    var shurikenReady = false,\r\n        shuriken = new Image()\r\n    ;\r\n\r\n    shuriken.src = \"img/shuriken.png\";\r\n    shuriken.onload = function () {\r\n        shurikenReady = true;\r\n    };\r\n\r\n    return {\r\n        drawBullets: function(){\r\n\t\t    for(var i=0; i < hero.bulletArr.length; ++i){\r\n\t\t        var dirOffset = hero.bulletArr[i].dirR ?\r\n    \t\t\t\t\t\t\t    hero.w : \r\n    \t\t\t\t\t\t\t    0;\r\n\t            \r\n\t\t        hero.bulletArr[i].deg += 5;\r\n            \r\n\t\t        if (shurikenReady) {\r\n\t\t            Graphics.drawRotate(\r\n                        shuriken,\r\n                        hero.bulletArr[i].pos.x + dirOffset,\r\n                        hero.bulletArr[i].pos.y + 20,\r\n                        hero.bulletArr[i].deg\r\n                    );\r\n\t\t        }\r\n\t\t    }\r\n        }\r\n    };\r\n};\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\n// The physics component of hero.\r\nvar HeroPhysicsComponent = function () {\r\n\r\n    /*\r\n        Updates projectiles position.\r\n\r\n        Tests for projectile collision against screen.\r\n        Tests for projectile collision against objects.\r\n    */\r\n    function projectileHandler() {\r\n        for (var i = 0; i < hero.bulletArr.length; ++i) {\r\n            hero.bulletArr[i].pos.x += hero.bulletArr[i].dirR ? Shuriken.speed : -Shuriken.speed;   // update position\r\n\r\n            if (hero.bulletArr[i].pos.x > FULLW || hero.bulletArr[i].pos.x < 0) {\t\t    // projectile and screen\r\n                hero.bulletArr.splice(i, 1); // remove ith item\r\n            }\r\n            else {\r\n                Physics.testObjObjs(hero.bulletArr[i], function(){                  // projectile and objects\r\n                    hero.bulletArr.splice(i, 1);\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    function screenCollision() {\r\n        if (hero.pos.y < -hero.h) {                 // feet above top of screen\r\n            hero.pos.y = -hero.h;\r\n            hero.vY = 0;\r\n        }\r\n        else if (hero.pos.y >= FULLH + hero.h*2) {  // 2x below bottom of screen\r\n            if (!game.over) {\r\n                utils.deathSequence();\r\n            }\r\n        }\r\n\r\n        if (hero.pos.x < 0) { \t\t\t\t\t\t// left\r\n            hero.pos.x = 0;\r\n            hero.vX = 0;\r\n        }\r\n        else if (hero.pos.x > (FULLW - hero.w)) { \t// right \r\n            hero.pos.x = FULLW - hero.w;\r\n            hero.vX = 0;\r\n        }\r\n    }\r\n\r\n    function levelCollision() {\r\n        hero.isOnObj = false;   // prevents jumping after walking off platform\r\n\r\n        Physics.testObjObjs(hero, function(r) {\r\n            // alias the collision direction\r\n            var dir = {\r\n                x: Dir.NONE,\r\n                y: Dir.NONE\r\n            };\r\n\r\n            if(r.overlapN.y === 1)\r\n                dir.y = Dir.TOP;\r\n            else if(r.overlapN.y === -1)\r\n                dir.y = Dir.BOT;\r\n\r\n            if(r.overlapN.x === 1)\r\n                dir.x = Dir.LEFT;\r\n            else if(r.overlapN.y === -1)\r\n                dir.x = Dir.RIGHT;\r\n\r\n\r\n            // check object type\r\n            if(r.b.type === JQObject.SLOPE || r.b.type === JQObject.POLY || r.b.type === JQObject.HILL) {\r\n                //r.a.pos.x -= r.overlapV.x;\r\n\r\n                if(hero.vY >= 0) { // prevents hooking on edge\r\n                    hero.landed(r.overlapV.y);\r\n                }\r\n            }\r\n            else if(r.b.type === JQObject.ELEVATOR) {\r\n                if(dir.y === Dir.TOP && hero.vY >= 0) {\r\n                    hero.isOnObj = true;\r\n                    hero.isJumping = false;\r\n                    hero.vY = (r.b.vY > 0) ? r.b.vY : 0;\r\n\r\n                    r.a.pos.y -= r.overlapV.y;\r\n                }\r\n            }\r\n            else {\r\n                r.a.pos.x -= r.overlapV.x;\r\n\r\n                if(dir.y === Dir.TOP && hero.vY >= 0) {  // prevents hooking on edge\r\n                    hero.landed(r.overlapV.y);\r\n                }\r\n                else if(dir.y === Dir.BOT && hero.vY <= 0) {  // prevents hooking on edge\r\n                    hero.vY = 0;\r\n                    r.a.pos.y -= r.overlapV.y;\r\n                }\r\n            }\r\n        });\r\n        \r\n        if (hero.isHolding) {\r\n            if (hero.vX === 0) {\r\n                hero.curItem.pos.x = hero.pos.x + 7;\r\n                hero.curItem.pos.y = hero.pos.y + 20;\r\n            }\r\n            else {\r\n                hero.curItem.pos.x = hero.pos.x + ((hero.dir === Dir.RIGHT) ? 45 : -32);\r\n                hero.curItem.pos.y = hero.pos.y + 16;\r\n            }\r\n        }\r\n\r\n        Physics.testHeroItems(function (r, idx) {\r\n            if (r.b.type === JQObject.CRATE) {      // TODO: make more generic\r\n                if (r.overlapN.y === 1) {           // on top\r\n                    hero.pos.y -= r.overlapV.y;\r\n                    hero.isOnObj = true;\r\n                    hero.isJumping = false;\r\n                    hero.vY = 0;\r\n                }\r\n                else if (!hero.isHolding && r.b.grabbable && !r.b.recentlyHeld) {\r\n                    if (r.b.isOnObj === true) {\r\n                        r.b.isOnObj = false;\r\n\r\n                        if (r.b.onObj !== null) {\r\n                            r.b.onObj.grabbable = true;\r\n                            r.b.onObj = null;\r\n                        }\r\n                    }\r\n\r\n                    r.b.isBeingHeld = true;\r\n\r\n                    hero.curItem = r.b;\r\n                    hero.isHolding = true;\r\n\r\n                    level.items.splice(idx, 1);\r\n                }\r\n            }\r\n            else {\r\n                audio.itemPickedUp.play();\r\n\r\n                if (r.b.type === JQObject.SACK) {\r\n                    hero.ammo += r.b.val;\r\n                }\r\n                else if (r.b.type === JQObject.CASH) {\r\n                    hero.cash += r.b.val;\r\n                }\r\n\r\n                level.items.splice(idx, 1);\r\n            }\r\n        });\r\n    }\r\n\r\n    return {\r\n        updatePosition: function (){\t\r\n            // TODO: buggy at edges, quickly changing direction incorrectly causes an updateView()\r\n            \r\n            if(((hero.dir === Dir.RIGHT && hero.pos.x >= (HALFW + 35)) ||\r\n               (hero.dir === Dir.LEFT && hero.pos.x <= (HALFW - 45))) &&\r\n               (hero.lvlX + hero.vX >= 0) &&\r\n               (hero.lvlX + hero.vX <= level.curLvl.width - FULLW)\r\n            ){\r\n                hero.lvlX += hero.vX;\r\n                level.updateView();\r\n            }\r\n            else {\r\n                hero.pos.x += hero.vX;\r\n            }\r\n\r\n            if (!hero.onLadder) {\r\n                hero.pos.y += hero.vY;\r\n            }\r\n        },\r\n\r\n        checkCollision: function () {\r\n            projectileHandler();\r\n            screenCollision();\t    // hero and screen\r\n            levelCollision();\r\n        }\r\n    };\r\n};\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar KeyCode = Object.freeze({\r\n    ENTER: 13,\r\n    CTRL: 17,\r\n    A: 65,\r\n    D: 68,\r\n    F: 70,\r\n    H: 72,\r\n    J: 74,\r\n    K: 75,\r\n    M: 77,\r\n    O: 79,\r\n    R: 82,\r\n    S: 83,\r\n    W: 87,\r\n    EMPTY: -1,\r\n    SPACEBAR: 32\r\n});\r\n\r\n// The input component of hero.\r\nvar HeroInputComponent = function () {\r\n\r\n    var maxVx = 3,\r\n        maxVy = 10\r\n    ;\r\n\r\n    // global key vars\r\n    keysDown = {};\r\n    lastKeyDown = -1;\r\n\r\n    $(document).on(\"click\", \".resize\", function () {\r\n        if ($(this).hasClass(\"off\")) {\r\n            $(this).removeClass(\"off\").addClass(\"on\");\r\n            $(this).children(\"span\").removeClass(\"icon-expand\").addClass(\"icon-contract\");\r\n        }\r\n        else if ($(this).hasClass(\"on\")) {\r\n            $(this).removeClass(\"on\").addClass(\"off\");\r\n            $(this).children(\"span\").removeClass(\"icon-contract\").addClass(\"icon-expand\");\r\n        }\r\n\r\n        utils.toggleFullScreen();\r\n    });\r\n\r\n    addEventListener(\"keydown\", function (e) {\r\n        if (e.keyCode === KeyCode.SPACEBAR)\r\n            e.preventDefault(); \t\t\t    // scrolling to bottom of page\r\n        else if (e.keyCode === KeyCode.M)\t    // mute/unmute\r\n            audio.handleMuteButton();\r\n        else if (e.keyCode === KeyCode.F)        // resize\r\n            $(\".resize\").trigger(\"click\");\r\n        else if (e.keyCode === KeyCode.K &&\t\t// jump; TODO: move to check() function\r\n               (!hero.isJumping && ((lastKeyDown !== KeyCode.K) || !(keysDown[KeyCode.K]))) &&\r\n               hero.isOnObj\r\n        ) {\r\n            audio.jump.play();\r\n            hero.vY = 0;\r\n            hero.isJumping = true;\r\n            hero.isOnObj = false;\r\n        }\r\n        else if (e.keyCode === KeyCode.J &&\t\t// shoot; TODO: move to check() function\r\n                ((lastKeyDown != KeyCode.J) || !(keysDown[KeyCode.J]))\r\n        ) {\r\n            if (hero.ammo > 0 && !hero.isHolding) {\r\n                audio.play(audio.effort);\r\n\r\n                var projectile = new GameObj(JQObject.SHURIKEN, hero.pos.x, hero.pos.y + Shuriken.h/2, Shuriken.w, Shuriken.h);\r\n                projectile.dirR = (hero.dir === Dir.RIGHT);\r\n                projectile.deg = 0;\r\n\r\n                hero.bulletArr.push(projectile);\r\n\r\n                --hero.ammo;\r\n                hero.idleTime = 0;\r\n            }\r\n        }\r\n        else if (e.keyCode == KeyCode.O) {      // options\r\n            utils.toggleMenu();\r\n        }\r\n\r\n        lastKeyDown = e.keyCode;\r\n        keysDown[e.keyCode] = true;\r\n    }, false);\r\n\r\n    addEventListener(\"keyup\", function (e) {\r\n        delete keysDown[e.keyCode];\r\n    }, false);\r\n\r\n\r\n    return {\r\n        check: function () {\r\n            var doGravity = false;\r\n\r\n            // jumping\r\n            if (hero.isJumping) {\r\n                if (hero.jumpMod > 0) {\r\n                    hero.vY -= hero.aY * hero.jumpMod--;\r\n                }\r\n                else {\r\n                    doGravity = true;\r\n                }\r\n            }\r\n            else {\r\n                hero.jumpMod = hero.jumpMod0;\r\n                doGravity = true;\r\n            }\r\n\r\n            if (doGravity && !hero.onLadder) {\r\n                var fixVy = hero.vY + game.gravity*2;\r\n\r\n                if (fixVy > maxVy) {\r\n                    hero.vY = maxVy;\r\n                }\r\n                else {\r\n                    hero.vY = fixVy;\r\n                }\r\n            }\r\n\r\n\r\n            // --------- keys pressed --------\r\n            var leftOrRight = false;\r\n            // left\r\n            if(keysDown[KeyCode.A]){\r\n                hero.vX = (Math.abs(hero.vX - hero.aX) > maxVx) ? -maxVx : (hero.vX - hero.aX);\r\n                hero.dir = Dir.LEFT;\r\n                leftOrRight = true;\r\n            }\r\n\r\n            // right\r\n            if (keysDown[KeyCode.D]) {\r\n                hero.vX = (Math.abs(hero.vX + hero.aX) > maxVx) ? maxVx : (hero.vX + hero.aX);\r\n                hero.dir = Dir.RIGHT;\r\n                leftOrRight = true;\r\n            }\r\n\t    \r\n            if(Math.abs(hero.vX) < hero.aX){    \r\n                hero.vX = 0;\r\n            }\r\n            else if(!leftOrRight){\r\n                //hero.vX += (hero.vX > 0) ? -game.friction : game.friction;\r\n                hero.vX /= 1.26;\r\n            }\r\n\t    \r\n\r\n            // up\r\n            if (keysDown[KeyCode.W]) {\r\n                if (hero.onLadder) {\r\n                    --hero.pos.y;\r\n                }\r\n            }\r\n\r\n            // down\r\n            if (keysDown[KeyCode.S]) {\r\n                if (hero.onLadder) {\r\n                    ++hero.pos.y;\r\n                }\r\n            }\r\n\r\n\t    \r\n            // drop \r\n            if (keysDown[KeyCode.SPACEBAR]) {\r\n                if (hero.isHolding) {\r\n                    hero.isHolding = false;\r\n                    hero.curItem.isBeingHeld = false;\r\n                    hero.curItem.recentlyHeld = true;       // TODO: fix api\r\n                    level.items.push(hero.curItem);\r\n                    hero.curItem = null;\r\n                }\r\n            }\r\n\r\n\t\t\r\n            //----- heal (h)\r\n            if(keysDown[KeyCode.H]){\r\n                if(hero.medKits > 0 && hero.health < hero.maxHealth){\r\n                    ++hero.health;\r\n                    --hero.medKits;\r\n\r\n                    audio.play(audio.enchant, true);\r\n                }\r\n            }\r\n\t\t\r\n\t\t\r\n            // restore\r\n            if(keysDown[KeyCode.R] && !(keysDown[KeyCode.CTRL])){\r\n                if(hero.manaKits > 0 && hero.mana < hero.maxMana){\r\n                    ++hero.mana;\r\n                    --hero.manaKits;\r\n\r\n                    audio.play(audio.enchant, true);\r\n                }\r\n            }\r\n\t\t\r\n        }\r\n    };\r\n};\r\n",
    "/// <reference path=\"linker.js\" />\r\n\r\nvar Main = (function () {\r\n\r\n    function setCanvasGlobals() {\r\n        canvas = $(\"canvas\")[0];\r\n        ctx = canvas.getContext(\"2d\");\r\n        \r\n        FULLW = canvas.width;\r\n        FULLH = canvas.height - game.padHUD;\r\n        HALFW = FULLW / 2;\r\n        HALFH = FULLH / 2;\r\n    }\r\n\r\n    function loadingScreen() {\r\n        ctx.fillStyle = \"#e1e1e1\";\r\n        ctx.font = \"25px 'Press Start 2P'\";\r\n        ctx.fillText(\"LOADING...\", HALFW - 80, HALFH + 20);\r\n    }\r\n\r\n    function debug() {\r\n        // dev enviroment\r\n        if (location.host === \"jon\") {\r\n            window.DEBUG = true;\r\n\r\n            // speed up canvas transition\r\n            $(canvas).css({\"transition\": \"opacity 0.01s\"});\r\n\r\n            // skip start screen\r\n            lastKeyDown = KeyCode.ENTER;\r\n\r\n            // mute audio\r\n            audio.handleMuteButton();\r\n        }\r\n    }\r\n\r\n\r\n    return {\r\n        init: function () {\r\n            setCanvasGlobals();\r\n            loadingScreen();\r\n\r\n            hero.init();\r\n            audio.init();\r\n            level.init();\r\n            HUD.init();\r\n\r\n            // wait for google font\r\n            $(document).on(\"fontLoaded\", function () {\r\n                // game timer\r\n                setInterval(function () {\r\n                    ++game.actualTime;\r\n                }, 1000);\r\n\r\n                // start the game\r\n                game.start();\r\n\r\n\r\n                debug();\r\n            });\r\n        }\r\n    }\r\n})();\r\n\r\n$(function () {\r\n    // load font\r\n    window.WebFontConfig = {\r\n        google: {\r\n            families: ['Press Start 2P']\r\n        },\r\n        active: function () {\r\n            $(document).trigger(\"fontLoaded\");\r\n        },\r\n        inactive: function () {\r\n            alert(\"There was a problem loading a font from google, some text may not render correctly (refreshing the page may fix the issue).\");\r\n            $(document).trigger(\"fontLoaded\");\r\n        }\r\n    };\r\n\r\n    (function () {\r\n        var wf = document.createElement(\"script\");\r\n        wf.src = \"//ajax.googleapis.com/ajax/libs/webfont/1/webfont.js\";\r\n        wf.type = \"text/javascript\";\r\n        wf.async = \"true\";\r\n        var s = document.getElementsByTagName(\"script\")[0];\r\n        s.parentNode.insertBefore(wf, s);\r\n    })();\r\n\r\n\r\n    Main.init();\r\n});\r\n"
  ]
}