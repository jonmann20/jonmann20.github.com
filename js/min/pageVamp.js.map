{
  "version": 3,
  "file": "pageVamp.js",
  "sources": [
    "games/common/js/GameEngine.js",
    "games/common/js/GameSave.js",
    "games/common/js/GameInput.js",
    "games/common/js/GameView.js",
    "games/common/js/SAT.js",
    "games/vamp/js/TitleView.js",
    "games/vamp/js/LevelView.js",
    "games/vamp/js/main.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,I;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,Q;ACnwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K",
  "sourcesContent": [
    "function GameEngine() {\r\n    var wrap = document.createElement(\"div\");\r\n    wrap.className = \"canvasWrap\";\r\n    canvas = document.createElement(\"canvas\");\r\n    canvas.setAttribute(\"width\", 16*63);\r\n    canvas.setAttribute(\"height\", 9*63);\r\n    wrap.appendChild(canvas);\r\n    document.body.appendChild(wrap);\r\n\r\n    ctx = canvas.getContext(\"2d\");\r\n\r\n    input = new GameInput();\r\n    view = new GameView();\r\n\r\n    function update() {\r\n        view.update();\r\n    }\r\n\r\n    function render() {\r\n        requestAnimationFrame(render);\r\n        view.render();\r\n    }\r\n\r\n    return {\r\n        start: function () {\r\n            setInterval(update, 1000 / 60);\r\n            requestAnimationFrame(render);\r\n        }\r\n    };\r\n}",
    "/// <reference path=\"../../vamp/js/linker.js\" />\r\n\r\nfunction GameSave() {\r\n\r\n}\r\n\r\nGameSave.prototype = (function () {\r\n    return {\r\n        load: function (slot) {\r\n            return localStorage[\"slot\" + slot];\r\n        },\r\n\r\n        getList: function () {\r\n            var zero = this.load(0),\r\n                one = this.load(1),\r\n                two = this.load(2),\r\n                def = \"---\"\r\n            ;\r\n            return list = [\r\n                (typeof(zero) !== \"undefined\") ? zero : def,\r\n                (typeof (one) !== \"undefined\") ? one : def,\r\n                (typeof (two) !== \"undefined\") ? two : def\r\n            ];\r\n        },\r\n\r\n        save: function (slot, data) {\r\n            localStorage[\"slot\" + slot] = data;\r\n        },\r\n\r\n        erase: function(slot){\r\n            localStorage.removeItem(\"slot\" + slot);\r\n            return this.getList();\r\n        }\r\n    };\r\n})();\r\n\r\nfunction GameSaveView(returnView, callback) {\r\n    this.returnView = returnView;\r\n    this.callback = callback;\r\n    this.init();\r\n}\r\n\r\nGameSaveView.prototype = (function () {\r\n    var title = \"Select a save slot\";\r\n    var cta = \"Press Delete to erase a save\";\r\n\r\n    var storage = new GameSave();\r\n    var list = storage.getList();\r\n    var arrow;\r\n\r\n    return {\r\n        init: function(){\r\n            arrow = {\r\n                img: \">>\",\r\n                slot: 0,\r\n                x: canvas.width / 2 - ctx.measureText(list[0]).width/2 - 60,\r\n                y: 200\r\n            };\r\n        },\r\n\r\n        update: function () {\r\n            \r\n            if (lastKeyUp === KeyCode.ENTER) {\r\n                lastKeyUp = KeyCode.EMPTY;\r\n\r\n                var date = new Date();\r\n                var m = date.getMonth();\r\n                var d = date.getDay();\r\n                var y = date.getYear();\r\n                var t = date.toLocaleTimeString();\r\n\r\n                storage.save(arrow.slot, m + '/' + d + '/' + y + ' ' + t);\r\n                this.callback();\r\n            }\r\n            else if (lastKeyUp === KeyCode.DELETE) {\r\n                lastKeyUp = KeyCode.EMPTY;\r\n\r\n                list = storage.erase(arrow.slot);\r\n            }\r\n            else if (arrow.slot !== 2 && lastKeyUp === KeyCode.DOWN) {\r\n                lastKeyUp = KeyCode.EMPTY;\r\n\r\n                ++arrow.slot;\r\n                arrow.x = canvas.width / 2 - ctx.measureText(list[arrow.slot]).width / 2 - 60;\r\n                arrow.y += 80;\r\n            }\r\n            else if (arrow.slot !== 0 && lastKeyUp === KeyCode.UP) {\r\n                lastKeyUp = KeyCode.EMPTY;\r\n\r\n                --arrow.slot;\r\n                arrow.x = canvas.width / 2 - ctx.measureText(list[arrow.slot]).width / 2 - 60;\r\n                arrow.y -= 80;\r\n            }\r\n        },\r\n\r\n        render: function () {\r\n            ctx.fillStyle = \"#111\";\r\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n            ctx.font = \"36px Arial\"\r\n            ctx.fillStyle = \"#fff\";\r\n            ctx.fillText(title, canvas.width / 2 - ctx.measureText(title).width / 2, 80);\r\n\r\n            ctx.font = \"24px Arial\"\r\n\r\n            for (var i = 0; i < list.length; ++i) {\r\n                ctx.fillText(list[i], canvas.width / 2 - ctx.measureText(list[i]).width/2, 200 + i * 80);\r\n            }\r\n\r\n            ctx.fillText(arrow.img, arrow.x, arrow.y);\r\n        }\r\n    };\r\n})();",
    "var KeyCode = Object.freeze({\r\n    EMPTY: -1,\r\n    ENTER: 13,\r\n    CTRL: 17,\r\n    ESC: 27,\r\n    SPACEBAR: 32,\r\n    UP: 38,\r\n    DOWN: 40,\r\n    DELETE: 46,\r\n    A: 65,\r\n    D: 68,\r\n    F: 70,\r\n    H: 72,\r\n    J: 74,\r\n    K: 75,\r\n    M: 77,\r\n    O: 79,\r\n    R: 82,\r\n    S: 83,\r\n    W: 87\r\n});\r\n\r\nvar KeyCodeNames = {};\r\nKeyCodeNames[-1] = \"EMPTY\";\r\nKeyCodeNames[13] = \"ENTER\";\r\nKeyCodeNames[17] = \"CTRL\";\r\nKeyCodeNames[27] = \"ESC\";\r\nKeyCodeNames[32] = \"SPACEBAR\";\r\nKeyCodeNames[38] = \"UP\";\r\nKeyCodeNames[40] = \"DOWN\";\r\nKeyCodeNames[46] = \"DELETE\";\r\nKeyCodeNames[65] = \"A\";\r\nKeyCodeNames[68] = \"D\";\r\nKeyCodeNames[70] = \"F\";\r\nKeyCodeNames[72] = \"H\";\r\nKeyCodeNames[74] = \"J\";\r\nKeyCodeNames[75] = \"K\";\r\nKeyCodeNames[77] = \"M\";\r\nKeyCodeNames[79] = \"O\";\r\nKeyCodeNames[82] = \"R\";\r\nKeyCodeNames[83] = \"S\";\r\nKeyCodeNames[87] = \"W\";\r\n\r\nfunction GameInput() {\r\n    keysDown = {};\r\n    lastKeyUp = KeyCode.EMPTY;\r\n\r\n    function fixKey(key) {\r\n        if (key === KeyCode.W)\r\n            key = KeyCode.UP;\r\n        else if (key === KeyCode.S)\r\n            key = KeyCode.DOWN;\r\n\r\n        return key;\r\n    }\r\n\r\n    addEventListener(\"keydown\", function (e) {\r\n        keysDown[fixKey(e.keyCode)] = true;\r\n    }, true);\r\n\r\n    addEventListener(\"keyup\", function (e) {\r\n        lastKeyUp = fixKey(e.keyCode);\r\n        delete keysDown[lastKeyUp];\r\n    }, false);\r\n}\r\n\r\n//Input.prototype = function () {\r\n\r\n//    return {\r\n//        update: function () {\r\n\r\n//        }\r\n//    };\r\n//};",
    "/// <reference path=\"commonLinker.js\" />\r\n\r\nfunction GameView() {\r\n\r\n}\r\n\r\nGameView.prototype = (function () {\r\n\r\n    return {\r\n        update: function () {\r\n\r\n        },\r\n\r\n        render: function () {\r\n            ctx.fillStyle = \"#ccc\";\r\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n            //ctx.font = \"36px Arial\";\r\n            //ctx.fillStyle = \"#000\";\r\n            //ctx.fillText(\"hello\", 10, 100);\r\n        }\r\n    };\r\n})();",
    "/*! \r\n    Authored by Jim Riecken - released under the MIT License. \r\n    Modified by Jon Wiedmann\r\n*/\r\n\r\n/*\r\n    A simple library for determining intersections of circles and\r\n    polygons using the Separating Axis Theorem.\r\n\r\n    jshint shadow:true, sub:true, forin:true, noarg:true, noempty:true, \r\n    eqeqeq:true, bitwise:true, strict:true, undef:true, \r\n    curly:true, browser:true \r\n*/\r\n\r\nvar SAT = {};\r\n(function(SAT) {\r\n    \"use strict\";\r\n  \r\n    /*\r\n        Represents a vector in two dimensions.\r\n     \r\n        @param {?number=} x The x position.\r\n        @param {?number=} y The y position.\r\n        @constructor\r\n    */\r\n    var Vector = function(x, y) {\r\n        this.x = x || 0;\r\n        this.y = y || 0;\r\n    };\r\n    SAT.Vector = Vector;\r\n\r\n    /*\r\n        Copy the values of another Vector into this one.\r\n    \r\n        @param {Vector} other The other Vector.\r\n        @return {Vector} This for chaining.\r\n    */\r\n    Vector.prototype.copy = function(other) {\r\n        this.x = other.x; \r\n        this.y = other.y;\r\n\r\n        return this;\r\n    };\r\n    \r\n    /*\r\n        Rotate this vector by 90 degrees\r\n    \r\n        @return {Vector} This for chaining.\r\n    */\r\n    Vector.prototype.perp = function() {\r\n        var x = this.x;\r\n        this.x = this.y; \r\n        this.y = -x;\r\n\r\n        return this;\r\n    };\r\n    \r\n    /*\r\n        Reverse this vector.\r\n    \r\n        @return {Vector} This for chaining.\r\n    */\r\n    Vector.prototype.reverse = function() {\r\n        this.x = -this.x; \r\n        this.y = -this.y;\r\n\r\n        return this;\r\n    };\r\n  \r\n    /*\r\n        Normalize (make unit length) this vector.\r\n        \r\n        @return {Vector} This for chaining.\r\n    */\r\n    Vector.prototype.normalize = function() {\r\n        var d = this.len();\r\n\r\n        if(d > 0) {\r\n            this.x = this.x / d; \r\n            this.y = this.y / d;\r\n        }\r\n\r\n        return this;\r\n    };\r\n  \r\n    /*\r\n        Add another vector to this one.\r\n    \r\n        @param {Vector} other The other Vector.\r\n        @return {Vector} This for chaining.\r\n    */\r\n    Vector.prototype.add = function(other) {\r\n        this.x += other.x; \r\n        this.y += other.y;\r\n\r\n        return this;\r\n    };\r\n  \r\n    /*\r\n        Subtract another vector from this one.\r\n    \r\n        @param {Vector} other The other Vector.\r\n        @return {Vector} This for chaiing.\r\n    */\r\n    Vector.prototype.sub = function(other) {\r\n        this.x -= other.x;\r\n        this.y -= other.y;\r\n\r\n        return this;\r\n    };\r\n  \r\n    /*\r\n        Scale this vector.\r\n    \r\n        @param {number} x The scaling factor in the x direction.\r\n        @param {?number=} y The scaling factor in the y direction.  If this\r\n        is not specified, the x scaling factor will be used.\r\n        @return {Vector} This for chaining.\r\n    */\r\n    Vector.prototype.scale = function(x,y) {\r\n        this.x *= x; \r\n        this.y *= y || x;\r\n\r\n        return this; \r\n    };\r\n  \r\n    /*\r\n        Project this vector on to another vector.\r\n    \r\n        @param {Vector} other The vector to project onto.\r\n        @return {Vector} This for chaining.\r\n    */\r\n    Vector.prototype.project = function(other) {\r\n        var amt = this.dot(other) / other.len2();\r\n\r\n        this.x = amt * other.x; \r\n        this.y = amt * other.y;\r\n\r\n        return this;\r\n    };\r\n  \r\n    /*\r\n        Project this vector onto a vector of unit length.\r\n    \r\n        @param {Vector} other The unit vector to project onto.\r\n        @return {Vector} This for chaining.\r\n    */\r\n    Vector.prototype.projectN = function(other) {\r\n    var amt = this.dot(other);\r\n    this.x = amt * other.x; \r\n    this.y = amt * other.y;\r\n    return this;\r\n    };\r\n    Vector.prototype['projectN'] = Vector.prototype.projectN;\r\n  \r\n    /*\r\n        Reflect this vector on an arbitrary axis.\r\n    \r\n        @param {Vector} axis The vector representing the axis.\r\n        @return {Vector} This for chaining.\r\n    */\r\n    Vector.prototype.reflect = function(axis) {\r\n        var x = this.x;\r\n        var y = this.y;\r\n\r\n        this.project(axis).scale(2);\r\n\r\n        this.x -= x;\r\n        this.y -= y;\r\n\r\n        return this;\r\n    };\r\n  \r\n    /*\r\n        Reflect this vector on an arbitrary axis (represented by a unit vector)\r\n    \r\n        @param {Vector} axis The unit vector representing the axis.\r\n        @return {Vector} This for chaining.\r\n    */\r\n    Vector.prototype.reflectN = function(axis) {\r\n        var x = this.x;\r\n        var y = this.y;\r\n\r\n        this.projectN(axis).scale(2);\r\n\r\n        this.x -= x;\r\n        this.y -= y;\r\n\r\n        return this;\r\n    };\r\n  \r\n    /*\r\n        Get the dot product of this vector against another.\r\n     \r\n        @param {Vector}  other The vector to dot this one against.\r\n        @return {number} The dot product.\r\n    */\r\n    Vector.prototype.dot = function(other) {\r\n        return this.x * other.x + this.y * other.y;\r\n    };\r\n  \r\n    /*\r\n        Get the length^2 of this vector.\r\n    \r\n        @return {number} The length^2 of this vector.\r\n    */\r\n    Vector.prototype.len2 = function() {\r\n        return this.dot(this);\r\n    };\r\n  \r\n    /*\r\n        Get the length of this vector.\r\n    \r\n        @return {number} The length of this vector.\r\n    */\r\n    Vector.prototype.len = function() {\r\n        return Math.sqrt(this.len2());\r\n    };\r\n  \r\n\r\n    /*\r\n        A circle.\r\n    \r\n        @param {Vector=} pos A vector representing the position of the center of the circle\r\n        @param {?number=} r The radius of the circle\r\n        @constructor\r\n    */\r\n    //var Circle = function(pos, r) {\r\n    //    this.pos = pos || new Vector();\r\n    //    this.r = r || 0;\r\n    //};\r\n    //SAT.Circle = Circle;\r\n  \r\n\r\n    /*\r\n        A *convex* clockwise polygon.\r\n    \r\n        @param {Vector=} pos A vector representing the origin of the polygon. (all other\r\n            points are relative to this one)\r\n        @param {Array.<Vector>=} points An array of vectors representing the points in the polygon,\r\n            in clockwise order.\r\n        @constructor\r\n    */\r\n    var Polygon = function(pos, points) {\r\n        this.pos = pos || new Vector();\r\n        this.points = points || [];\r\n\r\n        this.recalc();\r\n    };\r\n    SAT.Polygon = Polygon;\r\n  \r\n    /*\r\n        Recalculate the edges and normals of the polygon.  This\r\n        MUST be called if the points array is modified at all and\r\n        the edges or normals are to be accessed.\r\n    */\r\n    Polygon.prototype.recalc = function() {\r\n        var points = this.points;\r\n        var len = points.length;\r\n\r\n        this.edges = []; \r\n        this.normals = [];\r\n\r\n        for (var i = 0; i < len; i++) {\r\n            var p1 = points[i]; \r\n            var p2 = i < len - 1 ? points[i + 1] : points[0];\r\n\r\n            var e = new Vector().copy(p2).sub(p1);\r\n            var n = new Vector().copy(e).perp().normalize();\r\n\r\n            this.edges.push(e);\r\n            this.normals.push(n);\r\n        }\r\n    };\r\n    \r\n  \r\n    /*\r\n        An axis-aligned box, with width and height.\r\n    \r\n        @param {Vector=} pos A vector representing the top-left of the box.\r\n        @param {?number=} w The width of the box.\r\n        @param {?number=} h The height of the box.\r\n        @constructor\r\n    */\r\n    var Box = function(pos, w, h) {\r\n        this.pos = pos || new Vector();\r\n        this.w = w || 0; \r\n        this.h = h || 0;\r\n    };\r\n    SAT.Box = Box;\r\n\r\n    /*\r\n        Create a polygon that is the same as this box.\r\n    \r\n        @return {Polygon} A new Polygon that represents this box.\r\n    */\r\n    Box.prototype.toPolygon = function() {\r\n        var pos = this.pos;\r\n        var w = this.w;\r\n        var h = this.h;\r\n\r\n        return new Polygon(new Vector(pos.x, pos.y), [\r\n            new Vector(), new Vector(w, 0), \r\n            new Vector(w,h), new Vector(0,h)\r\n        ]);\r\n    };\r\n  \r\n    /*\r\n        Pool of Vectors used in calculations.\r\n    \r\n        @type {Array.<Vector>}\r\n    */\r\n    var T_VECTORS = [];\r\n    for (var i = 0; i < 10; ++i) { T_VECTORS.push(new Vector()); }\r\n\r\n    /*\r\n        Pool of Arrays used in calculations.\r\n    \r\n        @type {Array.<Array.<*>>}\r\n    */\r\n    var T_ARRAYS = [];\r\n    for (var i = 0; i < 5; ++i) { T_ARRAYS.push([]); }\r\n\r\n    /*\r\n        An object representing the result of an intersection. Contain information about:\r\n            - The two objects participating in the intersection\r\n            - The vector representing the minimum change necessary to extract the first object\r\n              from the second one.\r\n            - Whether the first object is entirely inside the second, or vice versa.\r\n    \r\n        @constructor\r\n    */  \r\n    var Response = function() {\r\n        this.a = null;\r\n        this.b = null;\r\n\r\n        this.overlapN = new Vector(); // Unit vector in the direction of overlap\r\n        this.overlapV = new Vector(); // Subtract this from a's position to extract it from b\r\n\r\n        this.clear();\r\n    };\r\n    SAT.Response = Response;\r\n\r\n    /*\r\n        Set some values of the response back to their defaults.  Call this between tests if \r\n        you are going to reuse a single Response object for multiple intersection tests (recommented)\r\n    \r\n        @return {Response} This for chaining\r\n    */\r\n    Response.prototype.clear = function() {\r\n        this.aInB = true; // Is a fully inside b?\r\n        this.bInA = true; // Is b fully inside a?\r\n        this.overlap = Number.MAX_VALUE; // Amount of overlap (magnitude of overlapV). Can be 0 (if a and b are touching)\r\n\r\n        return this;\r\n    };\r\n  \r\n    /*\r\n        Flattens the specified array of points onto a unit vector axis,\r\n        resulting in a one dimensional range of the minimum and \r\n        maximum value on that axis.\r\n    \r\n        @param {Array.<Vector>} points The points to flatten.\r\n        @param {Vector} normal The unit vector axis to flatten on.\r\n        @param {Array.<number>} result An array.  After calling this function,\r\n            result[0] will be the minimum value,\r\n        result[1] will be the maximum value.\r\n    */\r\n    var flattenPointsOn = function(points, normal, result) {\r\n        var min = Number.MAX_VALUE;\r\n        var max = -Number.MAX_VALUE;\r\n        var len = points.length;\r\n\r\n        for (var i = 0; i < len; ++i ) {\r\n            // Get the magnitude of the projection of the point onto the normal\r\n            var dot = points[i].dot(normal);\r\n\r\n            if (dot < min) { min = dot; }\r\n            if (dot > max) { max = dot; }\r\n        }\r\n\r\n        result[0] = min;\r\n        result[1] = max;\r\n    };\r\n  \r\n    /*\r\n        Check whether two convex clockwise polygons are separated by the specified\r\n        axis (must be a unit vector).\r\n    \r\n        @param {Vector} aPos The position of the first polygon.\r\n        @param {Vector} bPos The position of the second polygon.\r\n        @param {Array.<Vector>} aPoints The points in the first polygon.\r\n        @param {Array.<Vector>} bPoints The points in the second polygon.\r\n        @param {Vector} axis The axis (unit sized) to test against.  The points of both polygons\r\n            will be projected onto this axis.\r\n        @param {Response=} response A Response object (optional) which will be populated\r\n            if the axis is not a separating axis.\r\n        @return {boolean} true if it is a separating axis, false otherwise.  If false,\r\n            and a response is passed in, information about how much overlap and\r\n            the direction of the overlap will be populated.\r\n    */\r\n    var isSeparatingAxis = function(aPos, bPos, aPoints, bPoints, axis, response) {\r\n        var rangeA = T_ARRAYS.pop();\r\n        var rangeB = T_ARRAYS.pop();\r\n\r\n        // Get the magnitude of the offset between the two polygons\r\n        var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);\r\n        var projectedOffset = offsetV.dot(axis);\r\n\r\n        // Project the polygons onto the axis.\r\n        flattenPointsOn(aPoints, axis, rangeA);\r\n        flattenPointsOn(bPoints, axis, rangeB);\r\n\r\n        // Move B's range to its position relative to A.\r\n        rangeB[0] += projectedOffset;\r\n        rangeB[1] += projectedOffset;\r\n\r\n        // Check if there is a gap. If there is, this is a separating axis and we can stop\r\n        if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {\r\n            T_VECTORS.push(offsetV); \r\n            T_ARRAYS.push(rangeA); \r\n            T_ARRAYS.push(rangeB);\r\n\r\n            return true;\r\n        }\r\n\r\n        // If we're calculating a response, calculate the overlap.\r\n        if (response) {\r\n            var overlap = 0;\r\n\r\n            // A starts further left than B\r\n            if (rangeA[0] < rangeB[0]) {\r\n                response.aInB = false;\r\n\r\n                // A ends before B does. We have to pull A out of B\r\n                if (rangeA[1] < rangeB[1]) { \r\n                    overlap = rangeA[1] - rangeB[0];\r\n                    response.bInA = false;\r\n                }\r\n                else {  // B is fully inside A.  Pick the shortest way out.\r\n                    var option1 = rangeA[1] - rangeB[0];\r\n                    var option2 = rangeB[1] - rangeA[0];\r\n                    overlap = option1 < option2 ? option1 : -option2;\r\n                }\r\n            \r\n            }\r\n            else {  // B starts further left than A\r\n                response.bInA = false;\r\n\r\n                // B ends before A ends. We have to push A out of B\r\n                if (rangeA[1] > rangeB[1]) { \r\n                    overlap = rangeA[0] - rangeB[1];\r\n                    response.aInB = false;\r\n                }\r\n                else {  // A is fully inside B.  Pick the shortest way out.\r\n                    var option1 = rangeA[1] - rangeB[0];\r\n                    var option2 = rangeB[1] - rangeA[0];\r\n\r\n                    overlap = option1 < option2 ? option1 : -option2;\r\n                }\r\n            }\r\n\r\n            // If this is the smallest amount of overlap we've seen so far, set it as the minimum overlap.\r\n            var absOverlap = Math.abs(overlap);\r\n            if (absOverlap < response.overlap) {\r\n                response.overlap = absOverlap;\r\n                response.overlapN.copy(axis);\r\n\r\n                if (overlap < 0) {\r\n                    response.overlapN.reverse();\r\n                }\r\n            }      \r\n        }\r\n\r\n        T_VECTORS.push(offsetV); \r\n        T_ARRAYS.push(rangeA); \r\n        T_ARRAYS.push(rangeB);\r\n\r\n        return false;\r\n    };\r\n  \r\n    /*\r\n        Calculates which Vornoi region a point is on a line segment.\r\n        It is assumed that both the line and the point are relative to (0, 0)\r\n    \r\n                 |       (0)      | \r\n          (-1)  [0]--------------[1]  (1)\r\n                 |       (0)      | \r\n     \r\n        @param {Vector} line The line segment.\r\n        @param {Vector} point The point.\r\n        @return {number} LEFT_VORNOI_REGION (-1) if it is the left region, \r\n               MIDDLE_VORNOI_REGION (0) if it is the middle region, \r\n               RIGHT_VORNOI_REGION (1) if it is the right region.\r\n    */\r\n    var vornoiRegion = function(line, point) {\r\n        var len2 = line.len2();\r\n        var dp = point.dot(line);\r\n\r\n        if (dp < 0) { return LEFT_VORNOI_REGION; }\r\n        else if (dp > len2) { return RIGHT_VORNOI_REGION; }\r\n        else { return MIDDLE_VORNOI_REGION; }\r\n    };\r\n\r\n    // @const\r\n    var LEFT_VORNOI_REGION = -1;\r\n\r\n    // @const\r\n    var MIDDLE_VORNOI_REGION = 0;\r\n    \r\n    // @const\r\n    var RIGHT_VORNOI_REGION = 1;\r\n  \r\n    /*\r\n        Check if two circles intersect.\r\n    \r\n        @param {Circle} a The first circle.\r\n        @param {Circle} b The second circle.\r\n        @param {Response=} response Response object (optional) that will be populated if\r\n            the circles intersect.\r\n        @return {boolean} true if the circles intersect, false if they don't. \r\n    */\r\n    //SAT.testCircleCircle = function (a, b, response) {\r\n    //    var differenceV = T_VECTORS.pop().copy(b.pos).sub(a.pos);\r\n    //    var totalRadius = a.r + b.r;\r\n    //    var totalRadiusSq = totalRadius * totalRadius;\r\n    //    var distanceSq = differenceV.len2();\r\n\r\n    //    if (distanceSq > totalRadiusSq) {\r\n    //        // They do not intersect \r\n    //        T_VECTORS.push(differenceV);\r\n    //        return false;\r\n    //    }\r\n\r\n    //    // They intersect.  If we're calculating a response, calculate the overlap.\r\n    //    if (response) {\r\n    //        var dist = Math.sqrt(distanceSq);\r\n    //        response.a = a;\r\n    //        response.b = b;\r\n    //        response.overlap = totalRadius - dist;\r\n    //        response.overlapN.copy(differenceV.normalize());\r\n    //        response.overlapV.copy(differenceV).scale(response.overlap);\r\n    //        response.aInB = a.r <= b.r && dist <= b.r - a.r;\r\n    //        response.bInA = b.r <= a.r && dist <= a.r - b.r;\r\n    //    }\r\n\r\n    //    T_VECTORS.push(differenceV);\r\n\r\n    //    return true;\r\n    //};\r\n  \r\n    /*\r\n        Check if a polygon and a circle intersect.\r\n    \r\n        @param {Polygon} polygon The polygon.\r\n        @param {Circle} circle The circle.\r\n        @param {Response=} response Response object (optional) that will be populated if\r\n            they interset.\r\n        @return {boolean} true if they intersect, false if they don't.\r\n    */\r\n    //var testPolygonCircle = function(polygon, circle, response) {\r\n    //    var circlePos = T_VECTORS.pop().copy(circle.pos).sub(polygon.pos);\r\n    //    var radius = circle.r;\r\n    //    var radius2 = radius * radius;\r\n    //    var points = polygon.points;\r\n    //    var len = points.length;\r\n    //    var edge = T_VECTORS.pop();\r\n    //    var point = T_VECTORS.pop();\r\n    \r\n    //    // For each edge in the polygon\r\n    //    for (var i = 0; i < len; ++i) {\r\n    //        var next = i === len - 1 ? 0 : i + 1;\r\n    //        var prev = i === 0 ? len - 1 : i - 1;\r\n    //        var overlap = 0;\r\n    //        var overlapN = null;\r\n      \r\n    //        // Get the edge\r\n    //        edge.copy(polygon.edges[i]);\r\n\r\n    //        // Calculate the center of the cirble relative to the starting point of the edge\r\n    //        point.copy(circlePos).sub(points[i]);\r\n      \r\n    //        // If the distance between the center of the circle and the point\r\n    //        // is bigger than the radius, the polygon is definitely not fully in\r\n    //        // the circle.\r\n    //        if (response && point.len2() > radius2) {\r\n    //            response.aInB = false;\r\n    //        }\r\n      \r\n    //        // Calculate which Vornoi region the center of the circle is in.\r\n    //        var region = vornoiRegion(edge, point);\r\n    //        if (region === LEFT_VORNOI_REGION) { \r\n    //            // Need to make sure we're in the RIGHT_VORNOI_REGION of the previous edge.\r\n    //            edge.copy(polygon.edges[prev]);\r\n    //            // Calculate the center of the circle relative the starting point of the previous edge\r\n    //            var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);\r\n    //            region = vornoiRegion(edge, point2);\r\n    //            if (region === RIGHT_VORNOI_REGION) {\r\n    //                // It's in the region we want.  Check if the circle intersects the point.\r\n    //                var dist = point.len();\r\n    //                if (dist > radius) {\r\n    //                    // No intersection\r\n    //                    T_VECTORS.push(circlePos); \r\n    //                    T_VECTORS.push(edge);\r\n    //                    T_VECTORS.push(point); \r\n    //                    T_VECTORS.push(point2);\r\n\r\n    //                    return false;\r\n    //                }\r\n    //                else if (response) {\r\n    //                    // It intersects, calculate the overlap\r\n    //                    response.bInA = false;\r\n    //                    overlapN = point.normalize();\r\n    //                    overlap = radius - dist;\r\n    //                }\r\n    //            }\r\n\r\n    //            T_VECTORS.push(point2);\r\n    //        }\r\n    //        else if (region === RIGHT_VORNOI_REGION) {\r\n    //            // Need to make sure we're in the left region on the next edge\r\n    //            edge.copy(polygon.edges[next]);\r\n\r\n    //            // Calculate the center of the circle relative to the starting point of the next edge\r\n    //            point.copy(circlePos).sub(points[next]);\r\n    //            region = vornoiRegion(edge, point);\r\n\r\n    //            if (region === LEFT_VORNOI_REGION) {\r\n    //                // It's in the region we want.  Check if the circle intersects the point.\r\n    //                var dist = point.len();\r\n    //                if (dist > radius) {\r\n    //                    // No intersection\r\n    //                    T_VECTORS.push(circlePos); \r\n    //                    T_VECTORS.push(edge); \r\n    //                    T_VECTORS.push(point);\r\n\r\n    //                    return false;              \r\n    //                }\r\n    //                else if (response) {\r\n    //                    // It intersects, calculate the overlap\r\n    //                    response.bInA = false;\r\n    //                    overlapN = point.normalize();\r\n    //                    overlap = radius - dist;\r\n    //                }\r\n    //            }\r\n                \r\n    //        }\r\n    //        else {  // MIDDLE_VORNOI_REGION\r\n    //            // Need to check if the circle is intersecting the edge,\r\n    //            // Change the edge into its \"edge normal\".\r\n    //            var normal = edge.perp().normalize();\r\n\r\n    //            // Find the perpendicular distance between the center of the \r\n    //            // circle and the edge.\r\n    //            var dist = point.dot(normal);\r\n    //            var distAbs = Math.abs(dist);\r\n\r\n    //            // If the circle is on the outside of the edge, there is no intersection\r\n    //            if (dist > 0 && distAbs > radius) {\r\n    //                T_VECTORS.push(circlePos); \r\n    //                T_VECTORS.push(normal); \r\n    //                T_VECTORS.push(point);\r\n\r\n    //                return false;\r\n    //            }\r\n    //            else if (response) {\r\n    //                // It intersects, calculate the overlap.\r\n    //                overlapN = normal;\r\n    //                overlap = radius - dist;\r\n\r\n    //                // If the center of the circle is on the outside of the edge, or part of the\r\n    //                // circle is on the outside, the circle is not fully inside the polygon.\r\n    //                if (dist >= 0 || overlap < 2 * radius) {\r\n    //                    response.bInA = false;\r\n    //                }\r\n    //            }\r\n    //        }\r\n      \r\n    //        // If this is the smallest overlap we've seen, keep it. \r\n    //        // (overlapN may be null if the circle was in the wrong Vornoi region)\r\n    //        if (overlapN && response && Math.abs(overlap) < Math.abs(response.overlap)) {\r\n    //            response.overlap = overlap;\r\n    //            response.overlapN.copy(overlapN);\r\n    //        }\r\n    //    }\r\n    \r\n    //    // Calculate the final overlap vector - based on the smallest overlap.\r\n    //    if (response) {\r\n    //        response.a = polygon;\r\n    //        response.b = circle;\r\n    //        response.overlapV.copy(response.overlapN).scale(response.overlap);\r\n    //    }\r\n\r\n    //    T_VECTORS.push(circlePos); \r\n    //    T_VECTORS.push(edge); \r\n    //    T_VECTORS.push(point);\r\n\r\n    //    return true;\r\n    //};\r\n    //SAT.testPolygonCircle = testPolygonCircle;\r\n  \r\n    /*\r\n        Check if a circle and a polygon intersect.\r\n    \r\n        NOTE: This runs slightly slower than polygonCircle as it just\r\n            runs polygonCircle and reverses everything at the end.\r\n    \r\n        @param {Circle} circle The circle.\r\n        @param {Polygon} polygon The polygon.\r\n        @param {Response=} response Response object (optional) that will be populated if\r\n            they interset.\r\n        @return {boolean} true if they intersect, false if they don't.\r\n    */\r\n    //SAT.testCirclePolygon = function (circle, polygon, response) {\r\n    //    var result = testPolygonCircle(polygon, circle, response);\r\n\r\n    //    if (result && response) {\r\n    //        // Swap A and B in the response.\r\n    //        var a = response.a;\r\n    //        var aInB = response.aInB;\r\n    //        response.overlapN.reverse();\r\n    //        response.overlapV.reverse();\r\n    //        response.a = response.b;\r\n    //        response.b = a;\r\n    //        response.aInB = response.bInA;\r\n    //        response.bInA = aInB;\r\n    //    }\r\n\r\n    //    return result;\r\n    //};\r\n  \r\n    /*\r\n        Checks whether two convex, clockwise polygons intersect.\r\n    \r\n        @param {Polygon} a The first polygon.\r\n        @param {Polygon} b The second polygon.\r\n        @param {Response=} response Response object (optional) that will be populated if\r\n        they interset.\r\n        @return {boolean} true if they intersect, false if they don't.\r\n    */\r\n    SAT.testPolygonPolygon = function (a, b, response) {\r\n        var aPoints = a.points;\r\n        var aLen = aPoints.length;\r\n        var bPoints = b.points;\r\n        var bLen = bPoints.length;\r\n\r\n        // If any of the edge normals of A is a separating axis, no intersection.\r\n        for (var i = 0; i < aLen; i++) {\r\n            if (isSeparatingAxis(a.pos, b.pos, aPoints, bPoints, a.normals[i], response)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // If any of the edge normals of B is a separating axis, no intersection.\r\n        for (var i = 0; i < bLen; i++) {\r\n            if (isSeparatingAxis(a.pos, b.pos, aPoints, bPoints, b.normals[i], response)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Since none of the edge normals of A or B are a separating axis, there is an intersection\r\n        // and we've already calculated the smallest overlap (in isSeparatingAxis).  Calculate the\r\n        // final overlap vector.\r\n        if (response) {\r\n            response.a = a;\r\n            response.b = b;\r\n            response.overlapV.copy(response.overlapN).scale(response.overlap);\r\n        }\r\n\r\n        return true;\r\n    };\r\n}(SAT));",
    "/// <reference path=\"linker.js\" />\r\n\r\nfunction TitleView(callback) {\r\n    this.callback = callback;\r\n}\r\n\r\nTitleView.prototype = (function () {\r\n    var title = \"Vamp: The Great and Powerful\";\r\n    var cta = \"Press Enter\";\r\n\r\n    return {\r\n        update: function () {\r\n            if (lastKeyUp === KeyCode.ENTER) {\r\n                lastKeyUp = KeyCode.EMPTY;\r\n                view = new GameSaveView(this, this.callback);\r\n            }\r\n        },\r\n\r\n        render: function () {\r\n            ctx.fillStyle = \"#000\";\r\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n            ctx.font = \"36px Arial\"\r\n            ctx.fillStyle = \"#fff\";\r\n            ctx.fillText(title, canvas.width / 2 - ctx.measureText(title).width / 2, 100);\r\n\r\n            ctx.font = \"24px Arial\"\r\n            ctx.fillText(cta, canvas.width / 2 - ctx.measureText(cta).width / 2, canvas.height / 2);\r\n        }\r\n    };\r\n})();",
    "function LevelView() {\r\n\r\n}\r\n\r\nLevelView.prototype = (function () {\r\n    return {\r\n        update: function () {\r\n\r\n        },\r\n\r\n        render: function () {\r\n            ctx.fillStyle = \"brown\";\r\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n        }\r\n    };\r\n})();",
    "(function Main() {\r\n    var game = new GameEngine();\r\n    game.start();\r\n\r\n    view = new TitleView(function () {\r\n        view = new LevelView();\r\n    });\r\n\r\n})();"
  ]
}